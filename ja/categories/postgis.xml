<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>shisaa.be (postgis)</title><link>http://shisaa.be/</link><description></description><atom:link href="http://shisaa.be/ja/categories/postgis.xml" type="application/rss+xml" rel="self"></atom:link><language>ja</language><lastBuildDate>Mon, 05 Jan 2015 12:42:50 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Postgis and PostgreSQL in Action - Timezones</title><link>http://shisaa.be/ja/postset/postgis-and-postgresql-in-action-timezones.html</link><dc:creator>Tim van der Linden</dc:creator><description>&lt;div&gt;&lt;h3&gt;Preface&lt;/h3&gt;
&lt;p&gt;Recently, I was lucky to be part of an &lt;em&gt;awesome&lt;/em&gt; project called the &lt;a href="http://breakingboundariestour.com"&gt;Breaking Boundaries Tour&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This project is about two brothers, Omar and Greg Colin, who take their Stella scooters to make a full round trip across the United States.
And, while they are at it, try to raise funding for &lt;a href="http://surfershealing.org/"&gt;Surfer's Healing Folly Beach&lt;/a&gt; - an organization that does great work enhancing the lives of children with autism through surfing .
To accommodate this trip, they wished to have a site where visitors could follow their trail &lt;em&gt;live&lt;/em&gt;, as it happened.
A marker would travel across the map, with them, 24/7.&lt;/p&gt;
&lt;p&gt;Furthermore, they needed the ability to jump off their scooters, snap a few pictures, edit a video, write some side info and push it on the net, for whole the world to see.
Immediately after they made their post, it had to appear on the exact spot they where at when snapping their moments of beauty.&lt;/p&gt;
&lt;p&gt;To aid in the live tracking of their global position, they acquired a dedicated GPS tracking device which sends a latitude/longitude coordinate via a mobile data network every 5 minutes.&lt;/p&gt;
&lt;p&gt;Now, this (short) post is not about how I build the entire application, but rather about how I used PostGIS and PostgreSQL for a rather peculiar matter: deducting timezone information.&lt;/p&gt;
&lt;p&gt;For those who are interested though: the site is entirely build in Python using the Flask "micro framework" and, of course, PostgreSQL as the database.&lt;/p&gt;
&lt;h3&gt;Timezone information?&lt;/h3&gt;
&lt;p&gt;Yes. Time, dates, timezones: hairy worms in hairy cans which many developers hate to open, but have to sooner or later.&lt;/p&gt;
&lt;p&gt;In the case of Breaking Boundaries Tour, we had one major occasion where we needed the correct timezone information: where did the post happen?&lt;/p&gt;
&lt;h3&gt;Where did it happen?&lt;/h3&gt;
&lt;p&gt;A feature we wanted to implement was one to help visitors get a better view of when a certain post was written.
To be able to see when a post was written in your local timezone is much more convenient then seeing the post time in some foreign zone.&lt;/p&gt;
&lt;p&gt;We are lazy and do not wish to count back- or forward to figure out when a post popped up in our frame of time.&lt;/p&gt;
&lt;p&gt;The reasoning is simple, always calculate all the times involved back to simple UTC (GMT). Then figure out the clients timezone using JavaScript, apply the time difference and done!&lt;/p&gt;
&lt;p&gt;Simple eh?&lt;/p&gt;
&lt;p&gt;Correct, except for one small detail in the feature request, in what zone was the post actually made?&lt;/p&gt;
&lt;p&gt;Well...damn.&lt;/p&gt;
&lt;p&gt;While you heart might be at the right place while thinking: "Simple, just look at the locale of the machine (laptop, mobile phone, ...) that was used to post!", this information if just too fragile. Remember, the bothers are &lt;em&gt;crossing&lt;/em&gt; the USA, riding through at least three major timezones.
You can simply not expect all the devices involved when posting to always adjust their locale automatically depending on where they are.&lt;/p&gt;
&lt;p&gt;We need a more robust solution. We need PostGIS.&lt;/p&gt;
&lt;p&gt;But, how can a spatial database help us to figure out the timezone?&lt;/p&gt;
&lt;p&gt;Well, thanks to the hard labor delivered to us by Eric Muller from &lt;a href="http://efele.net"&gt;efele.net&lt;/a&gt;, we have a &lt;em&gt;complete&lt;/em&gt; and &lt;em&gt;maintained&lt;/em&gt; shapefile of the entire world, containing polygons that represent the different timezones accompanied by the official timezone declarations.&lt;/p&gt;
&lt;p&gt;This enables us to use the latitude and longitude information from the dedicated tracking device to pin point in which timezone they where while writing their post.&lt;/p&gt;
&lt;p&gt;So let me take you on a short trip to show you how I used the above data in conjunction with PostGIS and PostgreSQL.&lt;/p&gt;
&lt;h3&gt;Getting the data&lt;/h3&gt;
&lt;p&gt;The first thing to do, obviously, is to download the shapefile data and load it in to our PostgreSQL database.
Navigate to the &lt;a href="http://efele.net/maps/tz/world/"&gt;Timezone World&lt;/a&gt; portion of the efele.net site and download the "tz_world" shapefile.&lt;/p&gt;
&lt;p&gt;This will give you a zip which you can extract:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;unzip tz_world.zip
&lt;/pre&gt;


&lt;p&gt;Unzipping will create a directory called "world" in which you can find the needed shapefile package files.&lt;/p&gt;
&lt;p&gt;Next you will need to make sure that your database is PostGIS ready. Connect to your desired database (let us call it &lt;em&gt;bar&lt;/em&gt;) &lt;em&gt;as a superuser&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;psql -U postgres bar
&lt;/pre&gt;


&lt;p&gt;And create the PostGIS extension:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;EXTENSION&lt;/span&gt; &lt;span class="n"&gt;postgis&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now go back to your terminal and load the shapefile into your database using the original owner of the database (here called &lt;em&gt;foo&lt;/em&gt;):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;shp2pgsql -S -s &lt;span class="m"&gt;4326&lt;/span&gt; -I tz_world &lt;span class="p"&gt;|&lt;/span&gt; psql -U foo bar
&lt;/pre&gt;


&lt;p&gt;As you might remember from the PostGIS series, this loads in the geometry from the shapefile using only simple geometry (not "MULTI..." types) with a SRID of 4326.&lt;/p&gt;
&lt;h3&gt;What have we got?&lt;/h3&gt;
&lt;p&gt;This will take a couple of seconds and will create one table and two indexes. If you describe your database (assuming you have not made any tables yourself):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;public &lt;span class="p"&gt;|&lt;/span&gt; geography_columns &lt;span class="p"&gt;|&lt;/span&gt; view     &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; geometry_columns  &lt;span class="p"&gt;|&lt;/span&gt; view     &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; raster_columns    &lt;span class="p"&gt;|&lt;/span&gt; view     &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; raster_overviews  &lt;span class="p"&gt;|&lt;/span&gt; view     &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; spatial_ref_sys   &lt;span class="p"&gt;|&lt;/span&gt; table    &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; tz_world          &lt;span class="p"&gt;|&lt;/span&gt; table    &lt;span class="p"&gt;|&lt;/span&gt; foo
public &lt;span class="p"&gt;|&lt;/span&gt; tz_world_gid_seq  &lt;span class="p"&gt;|&lt;/span&gt; sequence &lt;span class="p"&gt;|&lt;/span&gt; foo
&lt;/pre&gt;


&lt;p&gt;You will see the standard PostGIS bookkeeping and you will find the &lt;em&gt;tz_world&lt;/em&gt; table together with a &lt;em&gt;gid&lt;/em&gt; sequence.&lt;/p&gt;
&lt;p&gt;Let us describe the table:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;tz_world&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And get:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;Column &lt;span class="p"&gt;|&lt;/span&gt;          Type          &lt;span class="p"&gt;|&lt;/span&gt;                       Modifiers                        
--------+------------------------+--------------------------------------------------------
gid    &lt;span class="p"&gt;|&lt;/span&gt; integer                &lt;span class="p"&gt;|&lt;/span&gt; not null default nextval&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'tz_world_gid_seq'&lt;/span&gt;::regclass&lt;span class="o"&gt;)&lt;/span&gt;
tzid   &lt;span class="p"&gt;|&lt;/span&gt; character varying&lt;span class="o"&gt;(&lt;/span&gt;30&lt;span class="o"&gt;)&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt; 
geom   &lt;span class="p"&gt;|&lt;/span&gt; geometry&lt;span class="o"&gt;(&lt;/span&gt;Polygon,4326&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; 
Indexes:
    &lt;span class="s2"&gt;"tz_world_pkey"&lt;/span&gt; PRIMARY KEY, btree &lt;span class="o"&gt;(&lt;/span&gt;gid&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="s2"&gt;"tz_world_geom_gist"&lt;/span&gt; gist &lt;span class="o"&gt;(&lt;/span&gt;geom&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;So we have:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;gid&lt;/em&gt;: an arbitrary id column&lt;/li&gt;
&lt;li&gt;&lt;em&gt;tzid&lt;/em&gt;: holding the standards compliant textual timezone identification&lt;/li&gt;
&lt;li&gt;&lt;em&gt;geom&lt;/em&gt;: holding polygons in &lt;em&gt;SRID&lt;/em&gt; 4326.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Also notice we have two indexes made for us:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;tz_world_pkey&lt;/em&gt;: a simple B-tree index on our gid&lt;/li&gt;
&lt;li&gt;&lt;em&gt;tz_world_geom_gist&lt;/em&gt;: a GiST index on our geometry&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;This is a rather nice set, would you not say?&lt;/p&gt;
&lt;h3&gt;Using the data&lt;/h3&gt;
&lt;p&gt;So how do we go about using this data?&lt;/p&gt;
&lt;p&gt;As I have said above, we need to figure out in which polygon (timezone) a certain point resides.&lt;/p&gt;
&lt;p&gt;Let us take an arbitrary point on the earth:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;latitude: 35.362852&lt;/li&gt;
&lt;li&gt;longitude: 140.196131&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;This is a spot in the Chiba prefecture, central Japan.&lt;/p&gt;
&lt;p&gt;Using the &lt;em&gt;Simple Features functions&lt;/em&gt; we have available in PostGIS, it is trivial to find out in which polygon a certain point resides:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;tzid&lt;/span&gt; 
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;tz_world&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;ST_Intersects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ST_GeomFromText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POINT(140.196131 35.362852)'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4326&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;geom&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;    tzid    
------------
 Asia/Tokyo
&lt;/pre&gt;


&lt;p&gt;&lt;em&gt;Awesome!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In the above query I used the function &lt;em&gt;ST_Intersects&lt;/em&gt; which checks if a given piece of geometry (our point) &lt;em&gt;shares any space&lt;/em&gt; with another piece.
If we would check the execute plan of this query:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;EXPLAIN&lt;/span&gt; &lt;span class="k"&gt;ANALYZE&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;tzid&lt;/span&gt; 
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;tz_world&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;ST_Intersects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ST_GeomFromText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POINT(140.196131 35.362852)'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4326&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;geom&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;                                                      QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
Index Scan using tz_world_geom_gist on tz_world  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.28..8.54 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;15&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.591..0.592 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
    Index Cond: &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'0101000020E61000006BD784B446866140E3A430EF71AE4140'&lt;/span&gt;::geometry &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; geom&lt;span class="o"&gt;)&lt;/span&gt;
    Filter: _st_intersects&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'0101000020E61000006BD784B446866140E3A430EF71AE4140'&lt;/span&gt;::geometry, geom&lt;span class="o"&gt;)&lt;/span&gt;
Total runtime: 0.617 ms
&lt;/pre&gt;


&lt;p&gt;That is not bad at all, a runtime of little over 0.6 Milliseconds and it is using our GiST index.&lt;/p&gt;
&lt;p&gt;But, if a lookup is using our GiST index, a small alarm bell should go off inside your head. Remember my last chapter on the PostGIS series?
I kept on babbling about index usage and how geometry functions or operators can only use GiST indexes when they perform &lt;em&gt;bounding box&lt;/em&gt; calculations.&lt;/p&gt;
&lt;p&gt;The latter might pose a problem in our case, for bounding boxes are a &lt;em&gt;very&lt;/em&gt; rough approximations of the actual geometry.
This means that when we arrive near timezone borders, our calculations might just give us the wrong timezone.&lt;/p&gt;
&lt;p&gt;So how can we fix this?&lt;/p&gt;
&lt;p&gt;This time, we do not need to.&lt;/p&gt;
&lt;p&gt;This is one of the few &lt;em&gt;blessed&lt;/em&gt; functions that makes use of both an index &lt;em&gt;and&lt;/em&gt; is very accurate.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;ST_Intersects&lt;/em&gt; first uses the index to perform bounding box calculations. This filters out the majority of available geometry.
Then it performs a more expensive, but more accurate calculation (on a small subset) to check if the given point is &lt;em&gt;really&lt;/em&gt; inside the returned matches.&lt;/p&gt;
&lt;p&gt;We can thus simply use this function without any more magic...life is simple!&lt;/p&gt;
&lt;h3&gt;Implementation&lt;/h3&gt;
&lt;p&gt;Now it is fair to say that we do not wish to perform this calculation every time a user views a post, that would not be very efficient nor smart.&lt;/p&gt;
&lt;p&gt;Rather, it is a good idea to generate this information at post time, and save it for later use.&lt;/p&gt;
&lt;p&gt;The way I have setup to save this information is twofold:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;I only save a UTC (GTM) generalized timestamp of when the post was made.&lt;/li&gt;
&lt;li&gt;I made an extra column in my so-called "posts" table where I only save the string that represents the timezone (Asia/Tokyo in the above case).&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;This keeps the date/time information in the database naive of any timezone and makes for easier calculations to give the time in either the clients timezone or in the timezone the post was originally written.
You simply have one "root" time which you can move around timezones.&lt;/p&gt;
&lt;p&gt;On every insert of a new post I have created a trigger that fetches the timezone and inserts it into the designated column.
You could also fetch the timezone and update the post record using Python, but opting for an in-database solution saves you a few extra, unneeded round trips and is most likely a lot faster.&lt;/p&gt;
&lt;p&gt;Let us see how we could create such a trigger.&lt;/p&gt;
&lt;p&gt;A trigger in PostgreSQL is an event you can set to fire when certain conditions are met. The event(s) that fire have to be encapsulated inside a PostgreSQL function.
Let us thus first start by creating the function that will insert our timezone string.&lt;/p&gt;
&lt;h3&gt;Creating functions&lt;/h3&gt;
&lt;p&gt;In PostgreSQL you can write functions in either &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;Procedural&lt;/em&gt; languages (PgSQL, Perl, Python) or plain &lt;em&gt;SQL&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Creating functions with plain SQL is the most straightforward and most easy way. However, since we want to write a function that is to be used inside a trigger, we have even a better option.
We could employ the power of the embedded PostgreSQL procedural language to easily access and manipulate our newly insert data.&lt;/p&gt;
&lt;p&gt;First, let us see which query we would use to fetch the timezone and update our post record:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;UPDATE&lt;/span&gt; &lt;span class="n"&gt;posts&lt;/span&gt;
  &lt;span class="k"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;tzid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;timezone&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tzid&lt;/span&gt;
  &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;tzid&lt;/span&gt;
          &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;tz_world&lt;/span&gt;
          &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;ST_Intersects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;ST_SetSRID&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
              &lt;span class="n"&gt;ST_MakePoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;140&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;196131&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;362852&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="mi"&gt;4326&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="n"&gt;geom&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;timezone&lt;/span&gt;
  &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This query will fetch the timezone string using a subquery and then update the correct record (a post with "pid" 1 in this example).&lt;/p&gt;
&lt;p&gt;How do we pour this into a function?&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;OR&lt;/span&gt; &lt;span class="k"&gt;REPLACE&lt;/span&gt; &lt;span class="k"&gt;FUNCTION&lt;/span&gt; &lt;span class="n"&gt;set_timezone&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;RETURNS&lt;/span&gt; &lt;span class="k"&gt;TRIGGER&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="err"&gt;$$&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="k"&gt;UPDATE&lt;/span&gt; &lt;span class="n"&gt;posts&lt;/span&gt;
    &lt;span class="k"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;tzid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;timezone&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tzid&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;tzid&lt;/span&gt; 
            &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;tz_world&lt;/span&gt;
              &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;ST_Intersects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;ST_SetSRID&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                  &lt;span class="n"&gt;ST_MakePoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;NEW&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;longitude&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;NEW&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;latitude&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                &lt;span class="mi"&gt;4326&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
              &lt;span class="n"&gt;geom&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;timezone&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;NEW&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;RETURN&lt;/span&gt; &lt;span class="k"&gt;NEW&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="err"&gt;$$&lt;/span&gt;
&lt;span class="k"&gt;LANGUAGE&lt;/span&gt; &lt;span class="n"&gt;PLPGSQL&lt;/span&gt; &lt;span class="k"&gt;IMMUTABLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;First we use the syntax &lt;em&gt;CREATE OR REPLACE FUNCTION&lt;/em&gt; to indicate we want to create (or replace) a custom function.
Then we tell PostgreSQL that this function will return type &lt;em&gt;TRIGGER&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;You might notice that we do not give this function any arguments. The reasoning here is that this function is "special".
Functions which are used as triggers magically get information about the inserted data available.&lt;/p&gt;
&lt;p&gt;Inside the function you can see we access our latitude and longitude prefixed with &lt;em&gt;NEW&lt;/em&gt;. These keywords, &lt;em&gt;NEW&lt;/em&gt; and &lt;em&gt;OLD&lt;/em&gt;, refer to the &lt;em&gt;record&lt;/em&gt; after and before the trigger(s) happened.
In our case we could have used both, since we do not alter the latitude or longitude data, we simply fill a column that is NULL by default.
There are more keywords available (&lt;em&gt;TG_NAME&lt;/em&gt;, &lt;em&gt;TG_RELID&lt;/em&gt;, &lt;em&gt;TG_NARGS&lt;/em&gt;, ...) which refer to properties of the trigger itself, but that is beyond today's scope.&lt;/p&gt;
&lt;p&gt;The actual SQL statement is wrapped between double dollar signs (&lt;em&gt;$$&lt;/em&gt;). This is called &lt;em&gt;dollar quoting&lt;/em&gt; and is the preferred way to quote your SQL string (as opposed to using single quotes).
The body of the function, which in our case is mostly the SQL statement, is surrounded with a &lt;em&gt;BEGIN&lt;/em&gt; and &lt;em&gt;END&lt;/em&gt; keyword.&lt;/p&gt;
&lt;p&gt;A trigger function always needs a &lt;em&gt;RETURN&lt;/em&gt; statement that is used to provide the data for the updated record. This too has to reside in the body of the function.&lt;/p&gt;
&lt;p&gt;Near the end of our function we need to declare in which language this function was written, in our case &lt;em&gt;PLPGSQL&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;em&gt;IMMUTABLE&lt;/em&gt; keyword tells PostgreSQL that this function is rather "functional", meaning: if the inputs are the same, the output will also, &lt;em&gt;always&lt;/em&gt; be the same.
Using this &lt;em&gt;caching&lt;/em&gt; keyword gives our famous PostgreSQL planner the ability to make decisions based on this knowledge.&lt;/p&gt;
&lt;h3&gt;Creating triggers&lt;/h3&gt;
&lt;p&gt;Now that we have this functionality wrapped into a tiny PLPGSQL function, we can go ahead and create the trigger.&lt;/p&gt;
&lt;p&gt;First you have the event on which a trigger can execute, these are:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;INSERT&lt;/li&gt;
&lt;li&gt;UPDATE&lt;/li&gt;
&lt;li&gt;DELETE&lt;/li&gt;
&lt;li&gt;TRUNCATE&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Next, for each event you can specify at what timing your trigger has to fire:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BEFORE&lt;/li&gt;
&lt;li&gt;AFTER&lt;/li&gt;
&lt;li&gt;INSTEAD OF&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;The last one is a special timing by which you can replace the default behavior of the mentioned events.&lt;/p&gt;
&lt;p&gt;For our use case, we are interested in executing our function &lt;em&gt;AFTER INSERT&lt;/em&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TRIGGER&lt;/span&gt; &lt;span class="n"&gt;set_timezone&lt;/span&gt;
    &lt;span class="k"&gt;AFTER&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;posts&lt;/span&gt;
    &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="k"&gt;EACH&lt;/span&gt; &lt;span class="k"&gt;ROW&lt;/span&gt;
    &lt;span class="k"&gt;EXECUTE&lt;/span&gt; &lt;span class="k"&gt;PROCEDURE&lt;/span&gt; &lt;span class="n"&gt;set_timezone&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will setup the trigger that fires after the insert of a new record.&lt;/p&gt;
&lt;h3&gt;Wrapping it up&lt;/h3&gt;
&lt;p&gt;Good, that all there is to it.&lt;/p&gt;
&lt;p&gt;We use a query, wrapped in a function, triggered by an insert event to inject the official timezone string which is deducted by PostGIS's spatial abilities.&lt;/p&gt;
&lt;p&gt;Now you can use this information to get the exact timezone of where the post was made and use this to present the surfing client both the post timezone time and their local time.&lt;/p&gt;
&lt;p&gt;For the curious ones out there: I used the &lt;a href="http://momentjs.com/%20MomentJS%20JavaScript%20library"&gt;MomentJS&lt;/a&gt; library for the client side time parsing. This library offers a timezone extension which accepts these official timezone strings to calculate offsets. A lifesaver, so go check it out.&lt;/p&gt;
&lt;p&gt;Also, be sure to follow the bros while they scooter across the States!&lt;/p&gt;
&lt;p&gt;And as always...thanks for reading!&lt;/p&gt;&lt;/div&gt;</description><guid>http://shisaa.be/ja/postset/postgis-and-postgresql-in-action-timezones.html</guid><pubDate>Wed, 20 Aug 2014 10:00:00 GMT</pubDate></item><item><title>Postgis, PostgreSQL's spatial partner - Part 3</title><link>http://shisaa.be/ja/postset/postgis-postgresqls-spatial-partner-part-3.html</link><dc:creator>Tim van der Linden</dc:creator><description>&lt;div&gt;&lt;p&gt;You have arrived at the final chapter of this PostGIS introduction  series. Before continuing, I recommend you read &lt;a href="http://shisaa.be/postset/postgis-postgresqls-spatial-partner-part-1.html" title="Part one of this series."&gt;chapter one&lt;/a&gt; and &lt;a href="http://shisaa.be/postset/postgis-postgresqls-spatial-partner-part-2.html" title="Part one of this series."&gt;chapter two&lt;/a&gt; first.&lt;/p&gt;
&lt;p&gt;In the last chapter we finished by doing some real world distance measuring and we saw how different projections pushed forward different results.&lt;/p&gt;
&lt;p&gt;Today I would like to take this practical approach a bit further and continue our work with real world data by showing you around the town of Kin in Okinawa. The town where I live.&lt;/p&gt;
&lt;h3&gt;A word before we start&lt;/h3&gt;
&lt;p&gt;In this chapter I want to do a few experiments together with you on real world data.
To gather this data, I would like to use OpenStreetMap because it is not only &lt;em&gt;open&lt;/em&gt; but also gives us handy tools to export map information.&lt;/p&gt;
&lt;p&gt;We will use a tool called &lt;em&gt;osm2pgsql&lt;/em&gt; to load our OSM data into PostGIS enable tables.&lt;/p&gt;
&lt;p&gt;However, it is more common to import and export real world GIS data by using the semi-closed ESRI standard &lt;em&gt;shapefile&lt;/em&gt; format.
OpenStreetMap does not support exporting to this shapefile format directly, but exports to a more open XML file (.osm) instead.&lt;/p&gt;
&lt;p&gt;Therefor, near the end of this post, we will briefly cover these shapefiles as well and see how we could import them into our PostgreSQL database.
But for the majority of our work today, I will focus on the OpenStreetMap approach.&lt;/p&gt;
&lt;h3&gt;The preparation&lt;/h3&gt;
&lt;p&gt;Let us commence with this adventure by first getting all the GIS data related to the whole of Okinawa.
We will only be interested in the data related to Kin town, but I need you to pull in a data set that is large enough (but still tiny in PostgreSQL terms) for us to experiment with indexing.&lt;/p&gt;
&lt;p&gt;Hop online and download the file being served at the following URL: &lt;a href="http://overpass-api.de/api/map?bbox=126.079,25.596,130.852,28.898"&gt;openstreetmap.org Okinawa island&lt;/a&gt;
It is a file of roughly 180 Mb and covers most of the Okinawan main island. Save the presented "map" file.&lt;/p&gt;
&lt;p&gt;Next we will need to install a third party tool which is specifically designed to import this OSM file into PostGIS.
This tool is called &lt;em&gt;osm2pgsql&lt;/em&gt; and is available in many Linux distributions.&lt;/p&gt;
&lt;p&gt;On a Debian system:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;apt-get install osm2pgsql
&lt;/pre&gt;


&lt;h3&gt;Loading foreign data&lt;/h3&gt;
&lt;p&gt;Now we are ready to load in this data. But first, let us clean our "gis" database we used before.&lt;/p&gt;
&lt;p&gt;Since all these import tools will create their own PostGIS enabled tables, we can delete our "shapes" table. Connect to your "gis" database and drop this table:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;DROP&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Using this new tool, repopulate the "gis" database with the data you just downloaded:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;osm2pgsql -s -U postgres -d gis map
&lt;/pre&gt;


&lt;p&gt;If everything went okay, you will get a small report containing the information about all the tables &lt;em&gt;and&lt;/em&gt; indexes that where created.&lt;/p&gt;
&lt;p&gt;Let us see what we just did. &lt;/p&gt;
&lt;p&gt;First we ran &lt;em&gt;osm2pgsql&lt;/em&gt; with the &lt;em&gt;-s&lt;/em&gt; flag. This flag enabled &lt;em&gt;slim&lt;/em&gt; mode, which means it will use a database on disk, rather then processing all the GIS data in RAM.
The latter does not only potentially slow down your machine for larger data sets, but it enables less features to be available.&lt;/p&gt;
&lt;p&gt;Next we tell the tool to connect as the user "postgres" and load the data into the "gis" database. The final argument is the "map" file you just downloaded.&lt;/p&gt;
&lt;h3&gt;What do we have now?&lt;/h3&gt;
&lt;p&gt;Open up a database console and let us describe our database to see what this tool just did:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you can see, it inserted 7 new tables:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;Schema &lt;span class="p"&gt;|&lt;/span&gt;        Name        &lt;span class="p"&gt;|&lt;/span&gt; Type  &lt;span class="p"&gt;|&lt;/span&gt;  Owner   
--------+--------------------+-------+----------
public &lt;span class="p"&gt;|&lt;/span&gt; geography_columns  &lt;span class="p"&gt;|&lt;/span&gt; view  &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; geometry_columns   &lt;span class="p"&gt;|&lt;/span&gt; view  &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; planet_osm_line    &lt;span class="p"&gt;|&lt;/span&gt; table &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; planet_osm_nodes   &lt;span class="p"&gt;|&lt;/span&gt; table &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; planet_osm_point   &lt;span class="p"&gt;|&lt;/span&gt; table &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; planet_osm_polygon &lt;span class="p"&gt;|&lt;/span&gt; table &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; planet_osm_rels    &lt;span class="p"&gt;|&lt;/span&gt; table &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; planet_osm_roads   &lt;span class="p"&gt;|&lt;/span&gt; table &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; planet_osm_ways    &lt;span class="p"&gt;|&lt;/span&gt; table &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; raster_columns     &lt;span class="p"&gt;|&lt;/span&gt; view  &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; raster_overviews   &lt;span class="p"&gt;|&lt;/span&gt; view  &lt;span class="p"&gt;|&lt;/span&gt; postgres
public &lt;span class="p"&gt;|&lt;/span&gt; spatial_ref_sys    &lt;span class="p"&gt;|&lt;/span&gt; table &lt;span class="p"&gt;|&lt;/span&gt; postgres
&lt;/pre&gt;


&lt;p&gt;The other 5 views and tables are the good old PostGIS bookkeeping.&lt;/p&gt;
&lt;p&gt;It is also important, yet less relevant for our work here today, to know that these tables, or rather the way &lt;em&gt;osm2pgsql&lt;/em&gt; imports, is optimized to work with &lt;em&gt;Mapnik&lt;/em&gt;.
Mapnik is an open-source map rendering software package used for both web and offline usage.&lt;/p&gt;
&lt;p&gt;The tables that are imported contain many different types of information. Let me quickly go over them to give you a basic feeling of how the import happened:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;planet_osm_line: holds all non-closed pieces of geometry (called &lt;em&gt;ways&lt;/em&gt;) at a high resolution. They mostly represent actual roads and are used when looking at a small, zoomed-in detail of a map.&lt;/li&gt;
&lt;li&gt;planet_osm_nodes: an intermediate table that holds the raw point data (points in lat/long) with a corresponding "osm_id" to map them to other tables&lt;/li&gt;
&lt;li&gt;planet_osm_point: holds all points-of-interest together with their OSM tags - tags that describe what they represent&lt;/li&gt;
&lt;li&gt;planet_osm_polygon: holds all closed piece of geometry (also called &lt;em&gt;ways&lt;/em&gt;) like buildings, parks, lakes, areas, ...&lt;/li&gt;
&lt;li&gt;planet_osm_rels: an intermediate table that holds extra connecting information about polygons&lt;/li&gt;
&lt;li&gt;planet_osm_roads: holds lower resolution, non-closed piece of geometry in contrast with "planet_osm_line". This data is used when looking at a greater distance, covering much area and thus not much detail about smaller, local roads.&lt;/li&gt;
&lt;li&gt;planet_osm_ways: an intermediate table which holds non-closed geometry in raw format&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;We will now continue working with a small subset of this data.&lt;/p&gt;
&lt;p&gt;Let us take a peek at the Polygons tables for example. First, let us see what we have available:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;That is quite a big list, but the major part of these columns are of mere TEXT type and contain human information about the geometry stored.
These columns corresponds with the way OpenStreetMap categorizes their data and with the way you could use the Mapnik software described above.&lt;/p&gt;
&lt;p&gt;Let us do a targeted query:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ST_AsText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'industrial'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Notice that I use the &lt;em&gt;output&lt;/em&gt; function &lt;em&gt;ST_AsText()&lt;/em&gt; to convert to a human readable WKT string.
Also, I am only interested in some of the industrial buildings, so I set the building type to &lt;em&gt;industrial&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;                    name                      &lt;span class="p"&gt;|&lt;/span&gt;  building  &lt;span class="p"&gt;|&lt;/span&gt;                                                                     st_astext                                                                   
----------------------------------------------+------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------
 沖ハム &lt;span class="o"&gt;(&lt;/span&gt;Okiham&lt;span class="o"&gt;)&lt;/span&gt;                               &lt;span class="p"&gt;|&lt;/span&gt; industrial &lt;span class="p"&gt;|&lt;/span&gt; POLYGON&lt;span class="o"&gt;((&lt;/span&gt;14221927.83 3049797.01,14222009.77 3049839.68,14222074.84 3049714.68,14222028.9 3049690.76,14221996.33 3049753.33,14221960.34 3049734.58,14221927.83 3049797.01&lt;span class="o"&gt;))&lt;/span&gt;
Kin Thermal Power Plant Coal storage building &lt;span class="p"&gt;|&lt;/span&gt; industrial &lt;span class="p"&gt;|&lt;/span&gt; POLYGON&lt;span class="o"&gt;((&lt;/span&gt;14239931.42 3054117.72,14239990.49 3054224.25,14240230.15 3054091.38,14240171.08 3053984.84,14239931.42 3054117.72&lt;span class="o"&gt;))&lt;/span&gt;
Kin Thermal Power Plant Exhaust tower         &lt;span class="p"&gt;|&lt;/span&gt; industrial &lt;span class="p"&gt;|&lt;/span&gt; POLYGON&lt;span class="o"&gt;((&lt;/span&gt;14240167.1 3054497.14,14240172.26 3054507.93,14240176.04 3054515.82,14240195.76 3054506.39,14240186.84 3054487.7,14240167.1 3054497.14&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We get back three records containing one industrial building each, described with a closed polygon. Cool.&lt;/p&gt;
&lt;p&gt;Now, I can assure you that Okinawa has more then three industrial buildings, but do remember that we are looking at a rather rural island.
OpenStreetMap relies greatly on user generated content and there simply are not many users who have felt the need to index the industrial buildings here in this neck of the woods.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;planet_osm_polygon&lt;/em&gt; table does contain little over 6000 buildings of various types, which is still a small number, but for our purpose today I am only interested in the latter two, which both lie here in Kin town.&lt;/p&gt;
&lt;p&gt;Also, if you would, for example, take a chunk of Tokyo, where there are hundreds of active OpenStreetMap contributors, you will find that many buildings are present and are sometimes even more accurately represented then some other online proprietary mapping solutions offered by some famous search engines. Ahum.&lt;/p&gt;
&lt;p&gt;Before continuing, though, I would like to delete two GiST indexes that "osm2pgsql" made for us, purely to be able to demonstrate the importance of an index.&lt;/p&gt;
&lt;p&gt;For now, just take my word and delete the indexes on all the geometry columns of the tables we will use today:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;DROP&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;DROP&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Then perform a VACUUM:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;VACUUM&lt;/span&gt; &lt;span class="k"&gt;ANALYZE&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;VACUUM&lt;/span&gt; &lt;span class="k"&gt;ANALYZE&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;&lt;em&gt;VACUUM&lt;/em&gt; together with &lt;em&gt;ANALYZE&lt;/em&gt; will force PostgreSQL to recheck the whole table for any changed conditions, as is the case since we removed the index.&lt;/p&gt;
&lt;p&gt;The first thing I would like to find out is how large these building actually are.
We cannot measure how tall they are, for we are working with two dimensional data here, but we can measure their footprint on the map.&lt;/p&gt;
&lt;p&gt;Since PostGIS makes all of our work easy, we could simply employ a function to tell us this information:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Area&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'industrial'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;    st_area      
------------------
10155.3935499731
33381.1043500491
452.9464999972
&lt;/pre&gt;


&lt;p&gt;As we know from the previous chapter, to be able to know what these numbers mean, we have to find out in which SRID this data was saved.
You could either describe the table again and look at the geometry column description, or use an &lt;em&gt;accessor&lt;/em&gt; function &lt;em&gt;ST_SRID()&lt;/em&gt;, to find it:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_SRID&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'industrial'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt; &lt;span class="n"&gt;st_srid&lt;/span&gt; 
&lt;span class="c1"&gt;---------&lt;/span&gt;
&lt;span class="mi"&gt;900913&lt;/span&gt;
&lt;span class="mi"&gt;900913&lt;/span&gt;
&lt;span class="mi"&gt;900913&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You could also query the PostGIS bookkeeping directly and look in the &lt;em&gt;geometry_columns&lt;/em&gt; view:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;f_tablename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f_geometry_column&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;coord_dimension&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;srid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;geometry_columns&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This view holds information about all the geometry columns in our PostGIS enabled database.
Our above query will return a list containing all the GIS describing information we saw in the previous chapter.&lt;/p&gt;
&lt;p&gt;Nice. Both our buildings are stored in a geometry column and have an SRID of &lt;em&gt;900913&lt;/em&gt;. We can now use our &lt;em&gt;spatial_ref_sys&lt;/em&gt; table to look up this ID:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;srid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;auth_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;auth_srid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;srtext&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;proj4text&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;spatial_ref_sys&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;srid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;900913&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you can see, this is basically a Mercator projection used by OpenStreetMap.
In the "proj4text" column we can see that its units are meters.&lt;/p&gt;
&lt;p&gt;This thus means that the information we get back is in &lt;em&gt;square Meters&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In this map (only looking at the latter two Kin buildings) we thus have a building with a total area of 33 &lt;em&gt;square Kilometers&lt;/em&gt; and a more modest building of around 452 &lt;em&gt;square Meters&lt;/em&gt;.
The former is a coal storage facility belonging to the &lt;em&gt;Kin Thermal Power Plant&lt;/em&gt; and is indeed &lt;em&gt;huge&lt;/em&gt;.
The second building represents the exhaust tower of that same plant.&lt;/p&gt;
&lt;p&gt;You have just measured the area these buildings occupy, very neat right?&lt;/p&gt;
&lt;p&gt;Now, let us find out which road runs next to this power plant, just in case we wish to drive to there.
It is important to note that OSM (and many other mapping solutions) divide roads into different types.&lt;/p&gt;
&lt;p&gt;You have trunk roads, highways, secondary roads, tertiary roads, etc.
I am now interested to find the nearest &lt;em&gt;secondary&lt;/em&gt; road.&lt;/p&gt;
&lt;p&gt;To get a list of all the secondary roads in Okinawa, simply query the &lt;em&gt;planet_osm_roads&lt;/em&gt; table:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="k"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ST_AsText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We now get back all the linestring objects together with their reference inside of OSM.
The reference refers to the actual route number each road has.&lt;/p&gt;
&lt;p&gt;The total count should be around &lt;em&gt;3215&lt;/em&gt; pieces of geometry, which is already a nice list to work with.&lt;/p&gt;
&lt;p&gt;Let us now see which of these roads is closest to our coal storage building.&lt;/p&gt;
&lt;p&gt;To find out how far something is (nearest neighbor search) we could use our &lt;em&gt;ST_Distance()&lt;/em&gt; function we used in the previous chapter and perform the following lookup:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;highway&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Kin Thermal Power Plant Coal storage building'&lt;/span&gt;
    &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will bring us:&lt;/p&gt;
&lt;pre class="code literal-block"&gt; highway  &lt;span class="p"&gt;|&lt;/span&gt; ref &lt;span class="p"&gt;|&lt;/span&gt;     distance     
-----------+-----+------------------
secondary &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;329&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; 417.374986575458
secondary &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;104&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; 2258.90394593648
secondary &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;104&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; 2709.00178089638
secondary &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;104&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; 2745.76782385198
secondary &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;234&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; 5897.78205314507
...
&lt;/pre&gt;


&lt;p&gt;Cool, secondary route 329 is the closest to our coal storage building with a distance of &lt;em&gt;417 meters.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;While this will return quite accurate results, there is one problem with this query. Indexes are not being used.
And every time an index is potentially left alone, you should start to worry, especially with larger data sets.&lt;/p&gt;
&lt;p&gt;How do I know they are ignored? Simple, we did not make any indexes (and we deleted the ones made by "osm2pgsql")...which makes me pretty sure we cannot use them.&lt;/p&gt;
&lt;p&gt;I refer you to &lt;a href="http://shisaa.be/postset/postgresql-full-text-search-part-3.html"&gt;chapter three&lt;/a&gt; of my PostgreSQL Full Text series where I talk a bit more about GiST and B-Tree index types.
And, as I also say in that chapter, I highly recommend reading Markus Winand's &lt;a href="http://use-the-index-luke.com/" title="Use The Index, Luke series written by Markus Winand."&gt;Use The Index, Luke&lt;/a&gt; series, which explains in great detail how database indexes work.&lt;/p&gt;
&lt;p&gt;The first thing to realize is that an index will only be used if the data set on which it is build is of sufficient size.
PostgreSQL has an AI build in, called the &lt;em&gt;query planner&lt;/em&gt;, which will make a decision on whether or not to use an index.&lt;/p&gt;
&lt;p&gt;If your data set is small enough a more traditional &lt;em&gt;Sequential Scan&lt;/em&gt; will be faster or equal.&lt;/p&gt;
&lt;p&gt;To know what is going on &lt;em&gt;exactly&lt;/em&gt; and to know &lt;em&gt;how fast&lt;/em&gt; our query runs, we have the &lt;em&gt;EXPLAIN&lt;/em&gt; command at our disposal.&lt;/p&gt;
&lt;h3&gt;Speeding things up&lt;/h3&gt;
&lt;p&gt;Let us &lt;em&gt;EXPLAIN&lt;/em&gt; the query we have just run:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;EXPLAIN&lt;/span&gt; &lt;span class="k"&gt;ANALYZE&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;highway&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Kin Thermal Power Plant Coal storage building'&lt;/span&gt;
    &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We simply put the keyword &lt;em&gt;EXPLAIN&lt;/em&gt; (and &lt;em&gt;ANALYZE&lt;/em&gt; to give us total runtime) right in front of our normal query.&lt;/p&gt;
&lt;p&gt;The result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;Sort  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;5047.50..5055.32 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3129&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;391&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;41.481..41.815 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3215&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
    Sort Key: &lt;span class="o"&gt;(&lt;/span&gt;st_distance&lt;span class="o"&gt;(&lt;/span&gt;road.way, building.way&lt;span class="o"&gt;))&lt;/span&gt;
    Sort Method: quicksort  Memory: 348kB
    -&amp;gt;  Nested Loop  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.00..4309.34 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3129&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;391&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1.188..38.617 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3215&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
        -&amp;gt;  Seq Scan on planet_osm_polygon building  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.00..279.01 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;207&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.981..1.409 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
            Filter: &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Kin Thermal Power Plant Coal storage building'&lt;/span&gt;::text&lt;span class="o"&gt;)&lt;/span&gt;
            Rows Removed by Filter: 6320
        -&amp;gt;  Seq Scan on planet_osm_line road  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.00..3216.79 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3129&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;184&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.166..26.524 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3215&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
            Filter: &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt;::text&lt;span class="o"&gt;)&lt;/span&gt;
            Rows Removed by Filter: 73488
Total runtime: 42.153 ms
&lt;/pre&gt;


&lt;p&gt;That is a lot of output, but it shows you how the internal planner executes our query and which decisions it makes along the way.&lt;/p&gt;
&lt;p&gt;To fully interpret a query plan (this is still a simple one), a lot more knowledge is needed and this would easily deserve its own &lt;em&gt;series&lt;/em&gt;.
I am by far not an expert in the query planner (though it is an interesting study topic), but I will do my best to extract the important bits we need for our direct performance tuning.&lt;/p&gt;
&lt;p&gt;A query plan is always made up out of nested nodes, the parent node containing all the accumulated information (costs, rows, ...) of its child nodes.&lt;/p&gt;
&lt;p&gt;Inside the nested loop parent node we see above, we can find that the planner decided to use two filters, which correspond to the &lt;em&gt;WHERE&lt;/em&gt; clause conditions of our query (building.name and road.highway).
You can see that both child nodes are of &lt;em&gt;Seq Scan&lt;/em&gt; type, which means &lt;em&gt;Sequential Scan&lt;/em&gt;. These types of nodes scan the whole table, simply from top to bottom, directly from disk.&lt;/p&gt;
&lt;p&gt;Another important thing to note is the total time this query costs, which is &lt;em&gt;42.153 ms&lt;/em&gt;.
The time reported here is the time on my local machine, depending on how decent your computer is, this time could vary.&lt;/p&gt;
&lt;p&gt;A detail not to forget when looking at this timing, is the fact that it is slightly skewed if compared to real-world application use:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;We neglect network/client traffic. This query now runs internally and does not need to communicate with a client driver (which almost always brings extra overhead)&lt;/li&gt;
&lt;li&gt;The time measurement itself also introduces overhead.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;The total runtime from our above plan does not sound as a big number, but we are working with a rather small data set - the area of Okinawa is large, but the geometry is rather sparse.&lt;/p&gt;
&lt;p&gt;So our first reaction should be: this can be better.&lt;/p&gt;
&lt;p&gt;First, let us try to get rid of these sequential scans, for they are a clear indication that the planner does not use an index.&lt;/p&gt;
&lt;h4&gt;Creating indexes&lt;/h4&gt;
&lt;p&gt;In our case we want to make two types of indexes:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Indexes on our "meta" data, the names and other attributes describing out geometrical data&lt;/li&gt;
&lt;li&gt;Indexes that actually index our geometrical data itself&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Let us start with our attributes columns.&lt;/p&gt;
&lt;p&gt;These are all simple VARCHAR, TEXT or INT columns, so the good old Balanced Tree or &lt;em&gt;B-Tree&lt;/em&gt; can be used here.
In our query above we use "road.highway" and "building.name" in our lookup, so let us make a couple of indexes that adhere to this query.
Remember, an index only makes sense if it is built the same way your queries question your data.&lt;/p&gt;
&lt;p&gt;First, the "highway" column of the "planet_osm_line" table:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line_highway_index&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;highway&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The syntax is trivial. You simply tell PostgreSQL to create an index, give it a name, and tell it on which column(s) of which table you want it to be built.
PostgreSQL will always default to the &lt;em&gt;B-Tree&lt;/em&gt; index type.&lt;/p&gt;
&lt;p&gt;Next, the name column:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon_name_index&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now perform another &lt;em&gt;VACUUM ANALYZE&lt;/em&gt; on both tables:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;VACUUM&lt;/span&gt; &lt;span class="k"&gt;ANALYZE&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;VACUUM&lt;/span&gt; &lt;span class="k"&gt;ANALYZE&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Let us run explain again on the exact same query:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;Sort&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4058&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;73&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;4066&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;56&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3129&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;394&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;817&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;149&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3215&lt;/span&gt; &lt;span class="n"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;Sort&lt;/span&gt; &lt;span class="k"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st_distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;Sort&lt;/span&gt; &lt;span class="k"&gt;Method&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;quicksort&lt;/span&gt;  &lt;span class="n"&gt;Memory&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;348&lt;/span&gt;&lt;span class="n"&gt;kB&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;  &lt;span class="n"&gt;Nested&lt;/span&gt; &lt;span class="n"&gt;Loop&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;72&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;95&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;3310&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;07&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3129&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;394&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;356&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;743&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3215&lt;/span&gt; &lt;span class="n"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;  &lt;span class="k"&gt;Index&lt;/span&gt; &lt;span class="n"&gt;Scan&lt;/span&gt; &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon_name_index&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;28&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;207&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;054&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;056&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;Index&lt;/span&gt; &lt;span class="n"&gt;Cond&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Kin Thermal Power Plant Coal storage building'&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;  &lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="n"&gt;Heap&lt;/span&gt; &lt;span class="n"&gt;Scan&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;72&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;67&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;2488&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3129&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;187&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;258&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;661&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3215&lt;/span&gt; &lt;span class="n"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;Recheck&lt;/span&gt; &lt;span class="n"&gt;Cond&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;  &lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="k"&gt;Index&lt;/span&gt; &lt;span class="n"&gt;Scan&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line_highway_index&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;71&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;89&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3129&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;864&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;864&lt;/span&gt; &lt;span class="k"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3215&lt;/span&gt; &lt;span class="n"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="k"&gt;Index&lt;/span&gt; &lt;span class="n"&gt;Cond&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Total&lt;/span&gt; &lt;span class="n"&gt;runtime&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;527&lt;/span&gt; &lt;span class="n"&gt;ms&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You can see that we now traded our &lt;em&gt;Seq Scan&lt;/em&gt; for &lt;em&gt;Index Scan&lt;/em&gt; and &lt;em&gt;Bitmap Heap Scan&lt;/em&gt;, which indicates that our attribute indexes are being used, yay!&lt;/p&gt;
&lt;p&gt;The so-called &lt;em&gt;Bitmap Heap Scan&lt;/em&gt;, instead of a &lt;em&gt;Sequential Scan&lt;/em&gt;, is performed when the planner decides it can use the index to gather all the rows it thinks it needs, sort them in logical order and then fetch the data from the table on disk in the most optimized way possible (trying to open each disk page only once).&lt;/p&gt;
&lt;p&gt;The order by which the &lt;em&gt;Bitmap Heap Scan&lt;/em&gt; arranges the data is directed by the child node aka the &lt;em&gt;Bitmap Index Scan&lt;/em&gt;. This latter type of node is the one doing the actual searching &lt;em&gt;inside&lt;/em&gt; the index. Because in our &lt;em&gt;WHERE&lt;/em&gt; clause we have a condition which tells PostgreSQL to limit the rows to the ones of "highway" type "secondary", the &lt;em&gt;Bitmap Index Scan&lt;/em&gt; fetches the needed rows from our &lt;em&gt;B-Tree&lt;/em&gt; index we just made and passes them to its parent, the &lt;em&gt;Bitmap Heap Scan&lt;/em&gt;, which then goes on to order the geometry rows to be fetched.&lt;/p&gt;
&lt;p&gt;This already helped much, for our query runtime dropped to half. Now, let us make the indexes for our actual geometry, and see the effect:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line_way&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt; &lt;span class="k"&gt;USING&lt;/span&gt; &lt;span class="n"&gt;gist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon_way&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt; &lt;span class="k"&gt;USING&lt;/span&gt; &lt;span class="n"&gt;gist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Creating a &lt;em&gt;GiST&lt;/em&gt; index is quite similar to a normal &lt;em&gt;B-Tree&lt;/em&gt; index. The only difference here is that you specify the index to be build with &lt;em&gt;GiST&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Vacuum:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;VACUUM&lt;/span&gt; &lt;span class="k"&gt;ANALYZE&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;VACUUM&lt;/span&gt; &lt;span class="k"&gt;ANALYZE&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now poke it again with the same query and see our new plan:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;Sort  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;4038.82..4046.54 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3089&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;395&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;21.137..21.479 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3215&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
    Sort Key: &lt;span class="o"&gt;(&lt;/span&gt;st_distance&lt;span class="o"&gt;(&lt;/span&gt;road.way, building.way&lt;span class="o"&gt;))&lt;/span&gt;
    Sort Method: quicksort  Memory: 348kB
    -&amp;gt;  Nested Loop  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;72.64..3299.76 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3089&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;395&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1.382..17.858 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3215&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
        -&amp;gt;  Index Scan using planet_osm_polygon_name_index on planet_osm_polygon building  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.28..8.30 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;207&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.041..0.044 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
            Index Cond: &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Kin Thermal Power Plant Coal storage building'&lt;/span&gt;::text&lt;span class="o"&gt;)&lt;/span&gt;
        -&amp;gt;  Bitmap Heap Scan on planet_osm_line road  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;72.36..2488.32 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3089&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;188&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1.297..4.726 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3215&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
            Recheck Cond: &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt;::text&lt;span class="o"&gt;)&lt;/span&gt;
            -&amp;gt;  Bitmap Index Scan on planet_osm_line_highway_index  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.00..71.59 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3089&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.866..0.866 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3215&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
                  Index Cond: &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt;::text&lt;span class="o"&gt;)&lt;/span&gt;
Total runtime: 21.873 ms
&lt;/pre&gt;


&lt;p&gt;Hmm, the plan did not change at all, and our runtime is roughly identical. Why is our performance still the same?&lt;/p&gt;
&lt;p&gt;The culprit here is &lt;em&gt;ST_Distance()&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As it turns out, this function is unable to use the &lt;em&gt;GiST&lt;/em&gt; index and is therefor not a good candidate to set loose on your whole result set. The same goes for the &lt;em&gt;ST_Area()&lt;/em&gt; function, by the way.&lt;/p&gt;
&lt;p&gt;So we need a way to limit the amount of records we do this expensive calculation on.&lt;/p&gt;
&lt;h4&gt;ST_DWithin()&lt;/h4&gt;
&lt;p&gt;We introduce a new function: &lt;em&gt;ST_DWithin()&lt;/em&gt;. This function could be our savior in this case, for it does use the &lt;em&gt;GiST&lt;/em&gt; index.&lt;/p&gt;
&lt;p&gt;Whether or not a function (or operator) can use the &lt;em&gt;GiST&lt;/em&gt; index, depends on if it uses &lt;em&gt;bounding boxes&lt;/em&gt; when performing calculations.
The reason why is because &lt;em&gt;GiST&lt;/em&gt; indexes mainly store bounding box information and not the exact geometry itself.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ST_DWithin()&lt;/em&gt; checks if given geometry is within a radius of another piece of geometry and simply returns &lt;em&gt;TRUE&lt;/em&gt; or &lt;em&gt;FALSE&lt;/em&gt;.
We can thus use it in our &lt;em&gt;WHERE&lt;/em&gt; clause to filter out geometry for which it returns &lt;em&gt;FALSE&lt;/em&gt; (and thus not falls within the radius).
It performs this check using bounding boxes, and thus is able to retrieve this information from our &lt;em&gt;GiST&lt;/em&gt; index.&lt;/p&gt;
&lt;p&gt;Let me present you with a query that limits the result set based on what &lt;em&gt;ST_DWithin()&lt;/em&gt; finds:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;EXPLAIN&lt;/span&gt; &lt;span class="k"&gt;ANALYZE&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;highway&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_polygon&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt;
        &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Kin Thermal Power Plant Coal storage building'&lt;/span&gt;
        &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;ST_DWithin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;building&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you can see we simply added one more &lt;em&gt;WHERE&lt;/em&gt; clause to limit the returned geometry by radius.
This will result in the following plan:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;Sort  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;45.66..45.67 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;395&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;6.048..6.052 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;27&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
    Sort Key: &lt;span class="o"&gt;(&lt;/span&gt;st_distance&lt;span class="o"&gt;(&lt;/span&gt;road.way, building.way&lt;span class="o"&gt;))&lt;/span&gt;
    Sort Method: quicksort  Memory: 27kB
    -&amp;gt;  Nested Loop  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;4.63..45.65 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;395&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;3.157..6.005 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;27&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
        -&amp;gt;  Index Scan using planet_osm_polygon_name_index on planet_osm_polygon building  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.28..8.30 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;207&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.051..0.054 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
            Index Cond: &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Kin Thermal Power Plant Coal storage building'&lt;/span&gt;::text&lt;span class="o"&gt;)&lt;/span&gt;
        -&amp;gt;  Bitmap Heap Scan on planet_osm_line road  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;4.34..37.09 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;188&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;3.090..5.771 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;27&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
            Recheck Cond: &lt;span class="o"&gt;(&lt;/span&gt;way &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; st_expand&lt;span class="o"&gt;(&lt;/span&gt;building.way, 10000::double precision&lt;span class="o"&gt;))&lt;/span&gt;
            Filter: &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt;::text&lt;span class="o"&gt;)&lt;/span&gt; AND &lt;span class="o"&gt;(&lt;/span&gt;building.way &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; st_expand&lt;span class="o"&gt;(&lt;/span&gt;way, 10000::double precision&lt;span class="o"&gt;))&lt;/span&gt; AND _st_dwithin&lt;span class="o"&gt;(&lt;/span&gt;way, building.way, 10000::double precision&lt;span class="o"&gt;))&lt;/span&gt;
            Rows Removed by Filter: 4838
                -&amp;gt;  Bitmap Index Scan on planet_osm_line_way  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.00..4.34 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1.978..1.978 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4865&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
                    Index Cond: &lt;span class="o"&gt;(&lt;/span&gt;way &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; st_expand&lt;span class="o"&gt;(&lt;/span&gt;building.way, 10000::double precision&lt;span class="o"&gt;))&lt;/span&gt;
Total runtime: 6.181 ms
&lt;/pre&gt;


&lt;p&gt;Good. We have just gone down to only &lt;em&gt;6.181 ms&lt;/em&gt;, That seems to be much more efficient.&lt;/p&gt;
&lt;p&gt;As you can see, our query plan got a few new rows. The main thing to notice is the fact that our &lt;em&gt;Bitmap Heap Scan&lt;/em&gt; got another &lt;em&gt;Recheck Cond&lt;/em&gt;, our expanded &lt;em&gt;ST_DWithin()&lt;/em&gt; condition.
More to the bottom, you can see that the condition is being pulled from the &lt;em&gt;GiST&lt;/em&gt; index:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;Index Cond: &lt;span class="o"&gt;(&lt;/span&gt;way &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; st_expand&lt;span class="o"&gt;(&lt;/span&gt;building.way, 10000::double precision&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This seems to be a much more desirable and scalable query.&lt;/p&gt;
&lt;p&gt;But there is a drawback, though &lt;em&gt;ST_DWithin()&lt;/em&gt; will make for speedy results, it works only by giving it a fixed radius.&lt;/p&gt;
&lt;p&gt;As you can see from our usage, we call the function as follows: ST_DWithin(road.way, building.way, 10000).
The last argument, "10000", tells us how big the search radius is. In this case our geometry is in meters, so this means we search in a radius of 10 Km.&lt;/p&gt;
&lt;p&gt;This static radius number is quite arbitrary and might not always be desirable. What other options do we have without compromising performance too much?&lt;/p&gt;
&lt;h4&gt;Operators&lt;/h4&gt;
&lt;p&gt;Another addition of PostGIS we have not talked about much up until now are the spatial &lt;em&gt;operators&lt;/em&gt; we have available.
You have a total of 16 operators you can use to perform matches on your GIS data.&lt;/p&gt;
&lt;p&gt;You have straightforward operators like &lt;em&gt;&amp;amp;&amp;amp;&lt;/em&gt;, which returns &lt;em&gt;TRUE&lt;/em&gt; if one piece of geometry intersects with another (bounding box calculation) or the &lt;em&gt;&amp;lt;&amp;lt;&lt;/em&gt; which returns &lt;em&gt;TRUE&lt;/em&gt; if one object is fully to the left of another object.&lt;/p&gt;
&lt;p&gt;But there are more interesting ones like the &lt;em&gt;&amp;lt;-&amp;gt;&lt;/em&gt; and the &lt;em&gt;&amp;lt;#&amp;gt;&lt;/em&gt; operators.&lt;/p&gt;
&lt;p&gt;The first operator, &lt;em&gt;&amp;lt;-&amp;gt;&lt;/em&gt;, returns the distance between two points. If you feed it other types of geometry (like a linestring of polygon) it will first draw a bounding box around that geometry and perform a point calculation by using the bounding box &lt;em&gt;centroids&lt;/em&gt;. A centroid is the calculated center of a piece of geometry (the drawn bounding box in our case).&lt;/p&gt;
&lt;p&gt;The second, &lt;em&gt;&amp;lt;#&amp;gt;&lt;/em&gt;, acts completely the same, but works directly on bounding boxes of given geometry. In our case, since we are not working with points, it would make more sense to use this operator.&lt;/p&gt;
&lt;p&gt;The big advantage of this distance calculation operator is, once more, the fact that it too calculates using a bounding box and is thus able to use a &lt;em&gt;GiST&lt;/em&gt; index.
However, the &lt;em&gt;ST_Distance()&lt;/em&gt; function calculates distances by finding two points on the given geometry most close to each other, which serves the most &lt;em&gt;accurate&lt;/em&gt; result.
The &lt;em&gt;&amp;lt;#&amp;gt;&lt;/em&gt; operator, as said before, stretches a &lt;em&gt;bounding box&lt;/em&gt; around each piece of geometry and therefor deforms our objects, making for less accurate distance measuring.&lt;/p&gt;
&lt;p&gt;It is therefor not wise to use &lt;em&gt;&amp;lt;#&amp;gt;&lt;/em&gt; to calculate accurate distances, but it is a life saver to &lt;em&gt;sort away&lt;/em&gt; geometry that is too far away for our interest.&lt;/p&gt;
&lt;p&gt;So a proper usage would be to first &lt;em&gt;roughly&lt;/em&gt; limit the result set using the &lt;em&gt;&amp;lt;#&amp;gt;&lt;/em&gt; operator and then more accurately measure the distance of, say, the first 50 matches with our famous &lt;em&gt;ST_Distance()&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Before we can continue, it is important to point out that both the &lt;em&gt;&amp;lt;-&amp;gt;&lt;/em&gt; and &lt;em&gt;&amp;lt;#&amp;gt;&lt;/em&gt; operator can only use the &lt;em&gt;GiST&lt;/em&gt; index when either the left or right hand side of the operator is a &lt;em&gt;constant&lt;/em&gt; or &lt;em&gt;fixed&lt;/em&gt; piece of geometry. This means we have to provide actual geometry using a constructor function.&lt;/p&gt;
&lt;p&gt;There are other ways around this limitation by, for example as Alexandre Neto points out on the PostGIS mailing list, providing your own function which converts our "dynamic" geometry into a constant.&lt;/p&gt;
&lt;p&gt;But this would make this post run way past its initial focus.
Let us simply try by providing a fixed piece of geometry.
The fixed piece is, of course, still our "Kin Thermal Power Plant Coal storage building", but converted into WKT:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;EXPLAIN&lt;/span&gt; &lt;span class="k"&gt;ANALYZE&lt;/span&gt; &lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;way&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;route&lt;/span&gt;
        &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt;
        &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt;
        &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;ST_GeomFromText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POLYGON((14239931.42 3054117.72,14239990.49 3054224.25,14240230.15 3054091.38,14240171.08 3053984.84,14239931.42 3054117.72))'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;900913&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;#&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;way&lt;/span&gt;
        &lt;span class="k"&gt;LIMIT&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ST_GeomFromText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POLYGON((14239931.42 3054117.72,14239990.49 3054224.25,14240230.15 3054091.38,14240171.08 3053984.84,14239931.42 3054117.72))'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;900913&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;road&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;true_distance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;route&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;
    &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;true_distance&lt;/span&gt;
    &lt;span class="k"&gt;LIMIT&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This query uses a &lt;em&gt;Common Table Expression&lt;/em&gt; or &lt;em&gt;CTE&lt;/em&gt; (you could also use a simpler subquery) to first get a rough result set of about 50 rows based on what &lt;em&gt;&amp;lt;#&amp;gt;&lt;/em&gt; finds.
Then &lt;em&gt;only&lt;/em&gt; on those 50 rows do we perform our more expensive, index-agnostic distance calculation.&lt;/p&gt;
&lt;p&gt;This results in the following plan and runtime:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;Limit  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;274.57..274.57 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;11.236..11.237 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
    CTE distance
        -&amp;gt;  Limit  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.28..260.82 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;50&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;173&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.389..10.764 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;50&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
            -&amp;gt;  Index Scan using planet_osm_line_way on planet_osm_line  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.28..16362.19 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3140&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;173&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.389..10.745 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;50&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
                Order By: &lt;span class="o"&gt;(&lt;/span&gt;way &amp;lt;&lt;span class="c"&gt;#&amp;gt; '010300002031BF0D000100000005000000D7A3706D17296B41C3F528DC124D47417B14AECF1E296B4100000020484D4741CDCCCCC43C296B410AD7A3B0054D4741295C8F6235296B41B81E856BD04C4741D7A3706D17296B41C3F528DC124D4741'::geometry)&lt;/span&gt;
                Filter: &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'secondary'&lt;/span&gt;::text&lt;span class="o"&gt;)&lt;/span&gt;
                Rows Removed by Filter: 4562
            -&amp;gt;  Sort  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;13.75..13.88 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;50&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;11.234..11.234 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
                Sort Key: &lt;span class="o"&gt;(&lt;/span&gt;st_distance&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'010300002031BF0D000100000005000000D7A3706D17296B41C3F528DC124D47417B14AECF1E296B4100000020484D4741CDCCCCC43C296B410AD7A3B0054D4741295C8F6235296B41B81E856BD04C4741D7A3706D17296B41C3F528DC124D4741'&lt;/span&gt;::geometry, distance.road&lt;span class="o"&gt;))&lt;/span&gt;
                Sort Method: top-N heapsort  Memory: 25kB
    -&amp;gt;  CTE Scan on distance  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cost&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.00..13.50 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;50&lt;/span&gt; &lt;span class="nv"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;64&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;actual &lt;span class="nb"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0.412..11.188 &lt;span class="nv"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;50&lt;/span&gt; &lt;span class="nv"&gt;loops&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;
Total runtime: 11.268 ms
&lt;/pre&gt;


&lt;p&gt;As you can see, we are now using the &lt;em&gt;GiST&lt;/em&gt; index "planet_osm_line_way", which was what we were after.&lt;/p&gt;
&lt;p&gt;This yields roughly the same runtime as with our &lt;em&gt;ST_DWithin()&lt;/em&gt;, but without the arbitrary distance setting.
We indeed have a somewhat arbitrary limiter of 50, but this is much less severe then a distance limiter.&lt;/p&gt;
&lt;p&gt;Even if the closest secondary road is 100 Km from our building, the above query would still find it whereas our previous query would return nothing.&lt;/p&gt;
&lt;h3&gt;One more for the road home&lt;/h3&gt;
&lt;p&gt;Let us do a few more fun calculations on our Okinawa data, before I let you off the island.&lt;/p&gt;
&lt;p&gt;Next I would like to find the longest &lt;em&gt;trunk&lt;/em&gt; road that runs through this prefecture:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="k"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;highway&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ST_Length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="k"&gt;length&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;highway&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'trunk'&lt;/span&gt;
    &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="k"&gt;length&lt;/span&gt; &lt;span class="k"&gt;DESC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We have a new function &lt;em&gt;ST_Length()&lt;/em&gt; which simply returns the length, given that the geometry is a linestring or multilinestring.
The only index that will be used is our "planet_osm_line_highway_index" &lt;em&gt;B-Tree&lt;/em&gt; index to perform our &lt;em&gt;Bitmap Index Scan&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ST_Length()&lt;/em&gt; does obviously not work with bounding boxes and therefor cannot use the geometrical &lt;em&gt;GiST&lt;/em&gt; index. This is yet another function you should use carefully.&lt;/p&gt;
&lt;p&gt;When looking at the result set that was returned to us, you will see that some routes show up multiple times.
Take route &lt;em&gt;58&lt;/em&gt;, which is the longest and most famous route in Okinawa. It shows up around &lt;em&gt;769&lt;/em&gt; times. Why?&lt;/p&gt;
&lt;p&gt;This is because, especially for a database prepared for mapping, these pieces of geometry are divided over different tiles.&lt;/p&gt;
&lt;p&gt;We thus need to accumulate the length of all the linestrings we find that represent pieces of route 58.
First, we could try to accomplish this with plain SQL:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;road_pieces&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="k"&gt;length&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'58'&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="k"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;total_length&lt;/span&gt;
&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;road_pieces&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will return:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;536468.804010367
&lt;/pre&gt;


&lt;p&gt;Meaning a total length of &lt;em&gt;536.486 Kilometers&lt;/em&gt;. This query will run in about &lt;em&gt;19.375 ms&lt;/em&gt;.
Let us add an index to our "ref" column:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line_ref_index&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Perform vacuum:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;VACUUM&lt;/span&gt; &lt;span class="k"&gt;ANALYZE&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This index creation will speed up to query and make it run in little over &lt;em&gt;3.524 ms&lt;/em&gt;. Nice runtime.&lt;/p&gt;
&lt;p&gt;You could also perform almost the exact same query, but instead of using an SQL sum() function, you could use &lt;em&gt;ST_Collect()&lt;/em&gt;, which creates collections of geometry out of all the separate pieces you feed it.
In our case we feed it separate linestrings, which will make this function output a single &lt;em&gt;multilinestring&lt;/em&gt;. We would then only have to perform one length calculation.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;road_pieces&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Collect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;geom&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'58'&lt;/span&gt;    
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;geom&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="k"&gt;length&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;road_pieces&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This query will run even around &lt;em&gt;1 ms&lt;/em&gt; faster then former and it returns &lt;em&gt;the exact&lt;/em&gt; same distance of &lt;em&gt;536.486 Kilometers&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Now that we have this one multilinestring which represents route 58, we could check how close this route comes to our famous Kin building (which we will statically feed):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;road_pieces&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Collect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;way&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;geom&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;planet_osm_line&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="k"&gt;ref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'58'&lt;/span&gt;    
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;geom&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ST_GeomFromText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POLYGON((14239931.42 3054117.72,14239990.49 3054224.25,14240230.15 3054091.38,14240171.08 3053984.84,14239931.42 3054117.72))'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;900913&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;road_pieces&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Which would give us:&lt;/p&gt;
&lt;pre class="code literal-block"&gt; 7900.58662432767
&lt;/pre&gt;


&lt;p&gt;In other words: Route 58 is, at it closest point, &lt;em&gt;7.9 Kilometers&lt;/em&gt; from our coal storage building.
This query now took about &lt;em&gt;5 ms&lt;/em&gt; to complete. A rather nice throughput.&lt;/p&gt;
&lt;p&gt;Okay, enough exploring for today.&lt;/p&gt;
&lt;p&gt;We took a brief look at indexing our spatial data, and what benefits we could gain from it.
And, as you can imagine, a lack of indexes and improper use of the GIS functions, could lead to dramatic slow-downs, certainly on larger data sets.&lt;/p&gt;
&lt;h3&gt;Shapefiles&lt;/h3&gt;
&lt;p&gt;Before I will let you go I want to take a brief look at another mechanism of carrying around GIS data: the &lt;em&gt;shapefile&lt;/em&gt;.
Probably more used then the OSM XML format, but less open. It is almost the GIS standard way of exchanging data between GIS systems.&lt;/p&gt;
&lt;p&gt;We can import shapefiles by using a tool called "shp2pgsql" which comes shipped with PostGIS.
This tool will attempt to upload &lt;em&gt;ESRI&lt;/em&gt; shape data into your PostGIS enables database.&lt;/p&gt;
&lt;h4&gt;ESRI?&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;ESRI&lt;/em&gt; stands for &lt;em&gt;Environmental Systems Research Institute&lt;/em&gt; and is yet another organization that taps into the world of digital cartography.&lt;/p&gt;
&lt;p&gt;They have defined a (somewhat open) file format standard that allows the GIS world to save their data in a so called &lt;em&gt;shapefile&lt;/em&gt;.
These files hold GIS primitives (polygons, linestrings, points, ...) together with a bunch of descriptive information that tells us what each primitive represents.&lt;/p&gt;
&lt;p&gt;It was once developed for ESRI's own, proprietary software package (ArcGIS), but was quickly picked up by the rest of the GIS community.
Today, almost all serious GIS packages have the ability to read and/or write to such shapefiles.&lt;/p&gt;
&lt;h4&gt;Shapefile build-up&lt;/h4&gt;
&lt;p&gt;Let us take a peek at the guts of such a shapefile.&lt;/p&gt;
&lt;p&gt;First, contrary to what the name suggest, a shapefile is not a single file. At a minimal level, it is a bundle containing a minimum of three files to be spec compliant:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;.shp&lt;/em&gt;: the first mandatory file has the extension &lt;em&gt;.shp&lt;/em&gt; and holds the GIS primitives themselves.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;.shx&lt;/em&gt;: the second important file is an index of the geometry &lt;/li&gt;
&lt;li&gt;&lt;em&gt;.dbf&lt;/em&gt;: the last needed file is a database file with geometry attributes&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Getting shapefile data&lt;/h3&gt;
&lt;p&gt;There are many organizations who offer shapefiles of all areas of the globe, either free or for a small fee.
But since we already have data in our database we are familiar with, we could create our own shapefiles.&lt;/p&gt;
&lt;h4&gt;Exporting with pgsql2shp&lt;/h4&gt;
&lt;p&gt;Besides "shp2pgsql", which is used to import or &lt;em&gt;load&lt;/em&gt; shapefiles, we also got shipped a reverse tool called "pgsql2shp", which can export to or &lt;em&gt;dump&lt;/em&gt; shapefiles based on geometry in your database.&lt;/p&gt;
&lt;p&gt;So let us, per experiment, create a shapefile containing all secondary roads of Okinawa.&lt;/p&gt;
&lt;p&gt;First we need to prepare an empty directory where this tool can dump our data. Since it will create multiple files, it is best to put them in their own spot.
Open up a terminal window and go to your favorite directory-making place and create a directory called "okinawa-roads":&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;mkdir okinawa-roads
&lt;/pre&gt;


&lt;p&gt;Next enter that directory.&lt;/p&gt;
&lt;p&gt;The "pgsql2shp" tool needs a few parameters to be able to successfully complete. We will be using the following flags:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-f, tells the tool which file name to adhere&lt;/li&gt;
&lt;li&gt;-u, the database user to connect with&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;After these flags we need to input the database we wish to take a chunk out of and the query which will determine the actual data to be dumped.&lt;/p&gt;
&lt;p&gt;The above will result in the following command:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;$ &lt;/span&gt; pgsql2shp -f secundairy_roads -u postgres gis &lt;span class="s2"&gt;"select way, ref from planet_osm_line where highway = 'secondary';"&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you can see we construct a query which only gets the road reference and the geometry "way" column from the secondary road types.&lt;/p&gt;
&lt;p&gt;After some processing it will have created 4 files, the 3 mandatory ones mentioned above, and a new one called a &lt;em&gt;projection&lt;/em&gt; file.
This file contains the coordinate system and other projection information in WKT format.&lt;/p&gt;
&lt;p&gt;This bundle of 4 files is now our shapefile format which you could easily exchange between GIS aware software packages.&lt;/p&gt;
&lt;h4&gt;Importing with shp2pgsql&lt;/h4&gt;
&lt;p&gt;Let us now import these shapefiles back into PostgreSQL and see what happens.&lt;/p&gt;
&lt;p&gt;For this we will ignore out "gis" database, and simply create a new database to keep things separated.
Connect to a PostgreSQL terminal, create the database and make it PostGIS aware:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;DATABASE&lt;/span&gt; &lt;span class="n"&gt;gisshape&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt; &lt;span class="n"&gt;gisshape&lt;/span&gt;
&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;EXTENSION&lt;/span&gt; &lt;span class="n"&gt;postgis&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now go back to your terminal window to do some importing.&lt;/p&gt;
&lt;p&gt;The import tool works by dumping the SQL statements to &lt;em&gt;stdin&lt;/em&gt; or to a SQL dump file if preferred.
If you do not wish to work with such a dump file, you have to pipe the output to the &lt;em&gt;psql&lt;/em&gt; command to be able to load in the data.&lt;/p&gt;
&lt;p&gt;From the directory where you saved the shapefile dump, run the "shp2pgsql" tool:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;shp2pgsql -S -s &lt;span class="m"&gt;900913&lt;/span&gt; -I secundairy_roads &lt;span class="p"&gt;|&lt;/span&gt; psql -U postgres gisshape
&lt;/pre&gt;


&lt;p&gt;Let me go over the flags we used:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-S: is used to keep the geometry &lt;em&gt;simple&lt;/em&gt;. The tool otherwise will convert all geometry to its &lt;em&gt;MULTI...&lt;/em&gt; counterpart&lt;/li&gt;
&lt;li&gt;-s: is needed to set the correct SRID&lt;/li&gt;
&lt;li&gt;-I: specifies that we wish the tool to create &lt;em&gt;GiST&lt;/em&gt; indexes on the geometry columns&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Note that the &lt;em&gt;-S&lt;/em&gt; flag will only work if all of your geometry is actual simple and does not contain true MULTI... types of geometry with multiple linestrings, points or polygons in them.&lt;/p&gt;
&lt;p&gt;An annoying fact is that you &lt;em&gt;have&lt;/em&gt; to tell the loader which SRID your geometry is in. There is a &lt;em&gt;.prj&lt;/em&gt; file in our shapefile bundle, but it only contains the WKT projection information, not the SRID.
One trick to find the SRID based on the information in the projection file is by using &lt;em&gt;OpenGEO&lt;/em&gt;'s &lt;a href="http://prj2epsg.org"&gt;Prj2EPSG"&lt;/a&gt; website, which does quite a good job at looking up the EPSG ID (which most of the time is the SRID). However, it fails to find the SRID of our OSM projection.&lt;/p&gt;
&lt;p&gt;Another way of finding our about the SRID is by using the PostGIS &lt;em&gt;spatial_ref_sys&lt;/em&gt; table itself:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;srid&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;spatial_ref_sys&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;srtext&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'PROJCS["Popular Visualisation CRS / Mercator (deprecated)",GEOGCS["Popular Visualisation CRS",DATUM["Popular_Visualisation_Datum",SPHEROID["Popular Visualisation Sphere",6378137,0,AUTHORITY["EPSG","7059"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY["EPSG","6055"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.01745329251994328,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4055"]],UNIT["metre",1,AUTHORITY["EPSG","9001"]],PROJECTION["Mercator_1SP"],PARAMETER["central_meridian",0],PARAMETER["scale_factor",1],PARAMETER["false_easting",0],PARAMETER["false_northing",0],AUTHORITY["EPSG","3785"],AXIS["X",EAST],AXIS["Y",NORTH]]'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will gives us:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;900913
&lt;/pre&gt;


&lt;p&gt;Perfect!&lt;/p&gt;
&lt;p&gt;If you now connect to your database and query its structure:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt; &lt;span class="n"&gt;gisshape&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You will see we have a new table called "secondary_roads". This table now holds only the information we dumped into the shapefile, being our road route numbers and their geometry. Neat!&lt;/p&gt;
&lt;h3&gt;The end&lt;/h3&gt;
&lt;p&gt;Good.&lt;/p&gt;
&lt;p&gt;We are done folks. I hope I have given you enough firepower to be able to commence with your own GIS work, using PostGIS.
As I have said in the beginning of this series, the past three chapters form merely an introduction into the capabilities of PostGIS, so as I expect you will do every time: go out and explore!&lt;/p&gt;
&lt;p&gt;Try to load in different areas of the world, either with OpenStreetMap or by using shapefiles. Experiment with all the different GIS functions and operators that PostGIS makes available.&lt;/p&gt;
&lt;p&gt;And above all, have fun!&lt;/p&gt;
&lt;p&gt;And as always...thanks for reading!&lt;/p&gt;
&lt;!--  LocalWords:  PostGIS PostgreSQL GIS OpenStreetMap
 --&gt;&lt;/div&gt;</description><guid>http://shisaa.be/ja/postset/postgis-postgresqls-spatial-partner-part-3.html</guid><pubDate>Wed, 25 Jun 2014 10:00:00 GMT</pubDate></item><item><title>Postgis, PostgreSQL's spatial partner - Part 2</title><link>http://shisaa.be/ja/postset/postgis-postgresqls-spatial-partner-part-2.html</link><dc:creator>Tim van der Linden</dc:creator><description>&lt;div&gt;&lt;p&gt;Welcome to the secoflynd part of our spatial story. If you have not done so, I advise you to go and read &lt;a href="http://shisaa.be/postset/postgis-postgresqls-spatial-partner-part-1.html" title="Part one of this series."&gt;part one&lt;/a&gt; first.&lt;/p&gt;
&lt;p&gt;The first part of this series gives you some basic knowledge about the GIS world (GIS Objects, WKT, Projections, ...).
This knowledge will come in handy in this chapter.&lt;/p&gt;
&lt;p&gt;Today we will finally take an actual peek at PostGIS and do some database work:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;We will see how we can create valid GIS objects and insert them into our database&lt;/li&gt;
&lt;li&gt;Next let PostGIS retrieve information about these inserted GIS objects&lt;/li&gt;
&lt;li&gt;Further down the line we will manipulate these object a bit more&lt;/li&gt;
&lt;li&gt;Then we will leap from geometry into geography&lt;/li&gt;
&lt;li&gt;Finally we will be doing some real world measurements&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Let us get started right away!&lt;/p&gt;
&lt;h3&gt;Creating the database&lt;/h3&gt;
&lt;p&gt;Before we can do anything else, we need to make sure that we have the PostGIS extension installed.
PostGIS is most of the time packaged as a PostgreSQL contribution package.
On a Debian system, it can be installed as follows:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;apt-get install postgresql-9.3-postgis-2.1
&lt;/pre&gt;


&lt;p&gt;This will install PostGIS version 2.1 for the PostgreSQL 9.3 database.&lt;/p&gt;
&lt;p&gt;Next, fire up your database console and let us first create a new user and database:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;user&lt;/span&gt; &lt;span class="n"&gt;gis&lt;/span&gt; &lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;PASSWORD&lt;/span&gt; &lt;span class="s1"&gt;'10gis10'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;DATABASE&lt;/span&gt; &lt;span class="n"&gt;gis&lt;/span&gt; &lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="k"&gt;OWNER&lt;/span&gt; &lt;span class="n"&gt;gis&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Not very original names, I know, but it states its purpose.
Next, connect to the &lt;em&gt;gis&lt;/em&gt; database and enable the PostGIS extension:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt; &lt;span class="n"&gt;gis&lt;/span&gt;
&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;EXTENSION&lt;/span&gt; &lt;span class="n"&gt;postgis&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now our database is PostGIS aware, and we are ready to get our hands dirty!&lt;/p&gt;
&lt;p&gt;Notice that if you now describe your database:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;PostGIS has created a new table and a few new views. This is PostGIS's own bookkeeping and it will store which tables contain geometry or geography columns.&lt;/p&gt;
&lt;h3&gt;Fun with Polygons&lt;/h3&gt;
&lt;p&gt;Let us begin this adventure with creating a polygon that has one interior ring, similar to the one we saw in the previous chapter.&lt;/p&gt;
&lt;p&gt;Before we can create them, though, we have to create a table that will hold their geometrical data:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="nb"&gt;VARCHAR&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now we have a table named "shapes" with only a column to store its name. But where do we store the geometry?&lt;/p&gt;
&lt;p&gt;Because of the new data types that PostGIS introduces (geometry and geography) and to keep its bookkeeping up to date, you can create this column with a PostGIS function named &lt;em&gt;AddGeometryColum()&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;AddGeometryColumn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'shapes'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'shape'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'POLYGON'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Let us do a breakdown.&lt;/p&gt;
&lt;p&gt;First, all the functions that PostGIS makes available to us are divided in groups that define their area of use. &lt;em&gt;AddGeometryColumn()&lt;/em&gt; falls in the "Management Functions" group.&lt;/p&gt;
&lt;p&gt;It is a function that will create a geometry column in a table of choice and adds a reference to this column to its bookkeeping. It accepts a number of arguments:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The table name to where you wish to add the column&lt;/li&gt;
&lt;li&gt;The actual column name you wish to have&lt;/li&gt;
&lt;li&gt;The SRID&lt;/li&gt;
&lt;li&gt;The WKT object you wish to represent&lt;/li&gt;
&lt;li&gt;The coordinate type you desire (2 means XY)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;In the above case we thus wish to add a geometry column to the "shapes" table. The column will be named "shape". The geometry inserted there will get an SRID of 0 and will be of object type POLYGON and have a normal, two dimensional coordinate layout.&lt;/p&gt;
&lt;h4&gt;SRID?&lt;/h4&gt;
&lt;p&gt;One thing that you might not yet know from the above function definition is the &lt;em&gt;SRID&lt;/em&gt; or &lt;em&gt;Spatial Reference ID&lt;/em&gt; and is a &lt;em&gt;very&lt;/em&gt; important number when working with spatial data.
Remember in the last chapter I kept on yapping about different projections we had and that each projection would yield different results?
Well, this is where all this information comes together: the SRID.&lt;/p&gt;
&lt;p&gt;Our famous OGC has create a lookup table containing a whopping &lt;em&gt;3911&lt;/em&gt; entries, each entry with a unique ID, the SRID.
This table is called &lt;em&gt;spatial_ref_sys&lt;/em&gt; and is, by default, installed into your PostgreSQL database when you enable PostGIS.&lt;/p&gt;
&lt;p&gt;But hold on, there is something I neglected to tell you in the previous chapter: the European Petroleum Survey Group or EPSG.
The following is something that confuses many people and makes them mix-and-match SRID and EPSG ID's. I will try my best not to add up to that confusion.&lt;/p&gt;
&lt;h4&gt;EPSG&lt;/h4&gt;
&lt;p&gt;The EPSG, now called the OGP, is a group of organizations that, among other things, concern themselves over cartography.
They are the world's number one authority that &lt;em&gt;defines&lt;/em&gt; how spatial coordinates (projected or real world) should be calculated.
All the definitions they make get and accompanying ID called the EPSG ID.&lt;/p&gt;
&lt;p&gt;The OGC maintains a list to be used inside databases (GIS systems). They give all their entries a unique SRID.
These entries refer to &lt;em&gt;defined&lt;/em&gt; and &lt;em&gt;official&lt;/em&gt; projections, primarily maintained by the &lt;em&gt;EPSG&lt;/em&gt; which have their own EPSG ID and unique name.
Other projections (not maintained by the EPSG) are also accepted into the OGC SRID list as are your own projections (if you would feel the need).&lt;/p&gt;
&lt;p&gt;Let us poke the spatial reference table and see if we can get a more clear picture.&lt;/p&gt;
&lt;p&gt;If we would query our table (sorry for the wildcard) and ask for a famous SRID (more on this one later):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;spatial_ref_sys&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;srid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4326&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We would get back one row containing:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;srid, which is the famous id&lt;/li&gt;
&lt;li&gt;auth_name, the name of authority organization, in most cases EPSG&lt;/li&gt;
&lt;li&gt;auth_srid, the EPSG ID the authority organization introduced&lt;/li&gt;
&lt;li&gt;srtext, tells us how the spatial reference is built using WKT&lt;/li&gt;
&lt;li&gt;proj4text, commands that drive the proj4 library which is used to make the actual projections&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;And as you can see, both the "srid" column and the "auth_srid" are identical. This will be the case with many entries.&lt;/p&gt;
&lt;p&gt;I should also tell you that this huge list of SRID entries mostly consists of dead or localized projections.
Many of the projections listed are not used anymore, but where popular some time in history (they are marked deprecated), or are very localized. 
In the previous chapter I mentioned that the general UTM system, for example, could be used as a framework for more localized UTM projections.
There are hundreds of these local projections that only make sense when used in the area they are intended for.&lt;/p&gt;
&lt;h4&gt;Simple Features Functions&lt;/h4&gt;
&lt;p&gt;As I have told you before, the functions that PostGIS makes available are divided into several, defined groups. The functions themselves are too defined, not by PostGIS but by the Simple Features standard maintained by the &lt;em&gt;OGC&lt;/em&gt; (as we saw in the previous chapter).&lt;/p&gt;
&lt;p&gt;There are a total of 8 major categories available:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Management functions: functions which can manipulate the internal bookkeeping of PostGIS&lt;/li&gt;
&lt;li&gt;Geometry constructors: functions that can create or construct geometry and geography objects&lt;/li&gt;
&lt;li&gt;Geometry accessors: functions that let us access and ask questions about the GIS objects&lt;/li&gt;
&lt;li&gt;Geometry editors: functions that let us manipulate GIS objects&lt;/li&gt;
&lt;li&gt;Geometry outputs: functions that give us various means by which to transform and "export" GIS objects&lt;/li&gt;
&lt;li&gt;Operators: various SQL operators to query our geography and geometry&lt;/li&gt;
&lt;li&gt;Spatial relationships and measurements: functions that let us do calculations between different GIS objects&lt;/li&gt;
&lt;li&gt;Geometry processing: functions to perform basic operations on GIS objects&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;I have left a few categories out for they are either not part of the Simple Features standard (such as three dimensional manipulations) or beyond the scope.
To see a list of all of the functions and their categories, I advise you to visit the PostGIS reference, &lt;a href="http://postgis.net/docs/reference.html"&gt;section 8&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let us now do some fun manipulations and use some of the functions from these categories, just to get a bit more familiar with how it all works together.&lt;/p&gt;
&lt;p&gt;If you inserted the last SQL command which makes the geometry column, you should have gotten back the following result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shapes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="n"&gt;SRID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;TYPE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;POLYGON&lt;/span&gt; &lt;span class="n"&gt;DIMS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This tells us we created the "shape" column in the "shapes" table and set the SRID to 0.
SRID 0 is a convention used to tell a GIS system that you currently do not care about the SRID and simply want to store geometry with an arbitrary X and Y value.&lt;/p&gt;
&lt;p&gt;Let us now insert the shape of our square. To insert a polygon into your column, you could use various functions. One of these functions is &lt;em&gt;ST_GeomFromText()&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s1"&gt;'Square with hole'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;ST_GeomFromText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POLYGON ((8 1, 8 8, 1 8, 1 1, 8 1), (6 3, 6 6, 3 6, 3 3, 6 3))'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This now inserts our polygon and gives it a name. The &lt;em&gt;ST_GeomFromText()&lt;/em&gt; function enables us to enter our polygon object using WKT.
This function also accepts a second, optional parameter which is the SRID by which we wish to work.
The category of this function is called &lt;em&gt;Geometry Constructors&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;You know this polygon has two rings, the exterior and the interior. Let us now ask PostGIS to return only the line that represents the exterior ring:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_ExteriorRing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Square with hole'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="mi"&gt;0102000020&lt;/span&gt;&lt;span class="n"&gt;E6100000050000000000000000002040000000000000F03F00000000000020400000000000002040000000000000F03F0000000000002040000000000000F03F000000000000F03F0000000000002040000000000000F03F&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Oh my...that is not what we expected. But yet it is correct. This is how PostgreSQL stores geometry/geography.
The result is correct, yet unreadable to us humans. &lt;/p&gt;
&lt;p&gt;If we wish to get back a readable WKT string, we have to convert it using one of the conversion functions:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_AsText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ST_ExteriorRing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Square with hole'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we get:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;LINESTRING&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Aha, that is more like it! This we can read!&lt;/p&gt;
&lt;p&gt;We used the &lt;em&gt;ST_ExteriorRing()&lt;/em&gt; which falls under the &lt;em&gt;Geometry Accessors&lt;/em&gt; category and the &lt;em&gt;ST_AsText()&lt;/em&gt; function which resides in the category &lt;em&gt;Geometry Outputs&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Okay, now we wish to know the interior ring:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_AsText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ST_InteriorRingN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Square with hole'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;LINESTRING&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Notice that the function &lt;em&gt;ST_InteriorRingN()&lt;/em&gt; requires you to give the integer of which ring you wish to get, starting from 1.
As we have seen before, polygon objects can have multiple interior rings, but only a single exterior one.&lt;/p&gt;
&lt;p&gt;Next let us ask all the information about what makes up the shape:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Summary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Square with hole'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;Polygon&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;rings&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;
  &lt;span class="n"&gt;ring&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="n"&gt;points&lt;/span&gt;  &lt;span class="o"&gt;+&lt;/span&gt;
  &lt;span class="n"&gt;ring&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="n"&gt;points&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Ohh, that is pretty cool. We get back a human readable string that explains to us how this particular piece of geometry is build.&lt;/p&gt;
&lt;p&gt;Let us now add another polygon:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s1"&gt;'The intersecting one'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;ST_GeomFromText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POLYGON ((14 1, 15 8, 7 8, 7 1, 14 1))'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This is a polygon that will &lt;em&gt;intersect&lt;/em&gt; with part of our previous polygon.
Let us ask PostGIS if these polygons really intersect each other:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Intersects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Square with hole'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'The intersecting one'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;If all is well, this will simply return &lt;em&gt;TRUE&lt;/em&gt; if they intersect and &lt;em&gt;FALSE&lt;/em&gt; if they do not. In this case, it will return &lt;em&gt;TRUE&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The counterpart of our intersect function is &lt;em&gt;ST_Disjoint()&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Disjoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Square with hole'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'The intersecting one'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Which will return &lt;em&gt;FALSE&lt;/em&gt; in our case.&lt;/p&gt;
&lt;p&gt;Let us now add a third polygon which does not intersect our previous two:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s1"&gt;'The solitary one'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;ST_GeomFromText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POLYGON ((20 20, 20 40, 1 40, 1 20 ,20 20))'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This polygon will reside well "above" the other two and does not share any space.
Let us now see how far this polygon resides from our first polygon, the one with the hole:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Square with hole'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'The solitary one'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This returns us the number "12", which means they are 12 units apart.
And remembering the definition of both shapes, the first shape is 8 units tall and the second shape starts at unit 20.
This indeed leaves a gap of 12.&lt;/p&gt;
&lt;p&gt;Nice! We have just measured the distance between two objects in a spatial database!&lt;/p&gt;
&lt;p&gt;Hmmm, this may mean we are getting closer to knowing the distance to Tokyo...but not yet, we need to play a bit more first.&lt;/p&gt;
&lt;p&gt;PostGIS also has the ability to manipulate geometry. Let us, for example, try to move our solitary polygon even further away using the &lt;em&gt;ST_Translate()&lt;/em&gt; function under the &lt;em&gt;Geometry Editors&lt;/em&gt; category:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Translate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'The solitary one'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The &lt;em&gt;ST_Translate()&lt;/em&gt; function will accept the to-be-altered geometry and accepts an X, Y and an optional third dimension.&lt;/p&gt;
&lt;p&gt;Running this query will give us a binary representation of a &lt;em&gt;new&lt;/em&gt; piece of geometry. The original geometry is not altered.
So how can we actually move the geometry that resided in the database?&lt;/p&gt;
&lt;p&gt;Simply by using SQL:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;UPDATE&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;
    &lt;span class="k"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ST_Translate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'The solitary one'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Let us now check the new distance:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Square with hole'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'The solitary one'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="mi"&gt;22&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Aha! Nice! It has now moved ten units upwards.&lt;/p&gt;
&lt;p&gt;Now let us alter the distance once again, but this time we will scale the polygon down:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;UPDATE&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;
    &lt;span class="k"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ST_Scale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'The solitary one'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;If we now check the distance, we will get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="mi"&gt;7&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Wow, we have gone from 22 to 7, how did that happen?&lt;/p&gt;
&lt;p&gt;Well, it is important to know that the &lt;em&gt;ST_Scale()&lt;/em&gt; function currently only supports scaling by multiplying each coordinate. This means that the polygon will not only become smaller or bigger, but will also translate as a result. To know exactly how our new, scaled version of our polygon looks, we can use the &lt;em&gt;ST_Boundary()&lt;/em&gt; function which shows us the outer most linestring:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_AsText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ST_Boundary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'The solitary one'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we will get:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;LINESTRING&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;If we compare that to the same result before scaling (which I handily made ready for you):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;LINESTRING&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You can see that each value in each coordinate simply was divided by 2.
This also clarifies why our polygons are now only 7 units apart (first square stops at 8, the scaled square start at 15).&lt;/p&gt;
&lt;p&gt;Okay, okay, I guess we have played enough now.
We have seen a small glimpse of the operations you can do on GIS data within PostGIS and seen that PostGIS makes all of this work fairly easy.&lt;/p&gt;
&lt;p&gt;I guess we can now take it one step further and start to actually look at some geography!&lt;/p&gt;
&lt;h3&gt;Fun with the earth&lt;/h3&gt;
&lt;p&gt;Up until now we have been working with an SRID of &lt;em&gt;0&lt;/em&gt;, which means &lt;em&gt;undefined&lt;/em&gt;, inside a &lt;em&gt;geometry&lt;/em&gt; column, meaning the data was of type "geometry".
Now we want to go out and explore the actual earth, which means we wish to continue in a &lt;em&gt;geographical coordinate system&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This brings us at a crossroad of choices. First, you will need to ask yourself the same question we pondered in chapter one: you wish to work with geometry or geography?&lt;/p&gt;
&lt;p&gt;On the one hand we know that geographical measurements are expensive calculations, but most accurate for they are unprojected.
On the other hand GIS convention tells us that in any case, we should continue in a geometrical or Cartesian system, simply because...well...it is a convention.&lt;/p&gt;
&lt;p&gt;So what do we do?&lt;/p&gt;
&lt;p&gt;It all depends on your specific use case.&lt;/p&gt;
&lt;p&gt;When working on a "small" scale, say, part of North America, it would make sense to not use geography.
Instead, you could (and should) work in a geometrical system using a very accurate projection with SRID 4267 (datum &lt;em&gt;NAD27&lt;/em&gt;) or SRID 4269 (datum &lt;em&gt;NAD83&lt;/em&gt;) which are both local UTM variants for North America. &lt;/p&gt;
&lt;p&gt;Depending on which region you work in, chances are high you have several local projections with their own datum and coordinate system, ready to use.
They are very accurate and less expensive to use then direct geography.&lt;/p&gt;
&lt;p&gt;For us, however, we will be working on a large scale, for we want to measure a distance that covers much of the globe. You cannot use a local projection or local datum for that.&lt;/p&gt;
&lt;p&gt;In such a case you, again, are presented with two options.
You could either neglect the convention and simply use geographical data and functions or be nice and adhere to what is agreed upon and work in a Cartesian system.&lt;/p&gt;
&lt;p&gt;We will be doing both and we will use the common SRID &lt;em&gt;4326&lt;/em&gt;.
This &lt;em&gt;very&lt;/em&gt; popular SRID is by heart geographical, for it uses the geographical coordinate system, but can also be used with geometrical data. Confused?&lt;/p&gt;
&lt;p&gt;Join the club.&lt;/p&gt;
&lt;p&gt;Let me try to clarify.&lt;/p&gt;
&lt;p&gt;First, the authority of this SRID is the EPSG and the EPSG ID is identical to the SRID.
It uses a popular &lt;em&gt;datum&lt;/em&gt; (remember chapter one) called &lt;em&gt;WGS 84&lt;/em&gt; and is referred to as &lt;em&gt;unprojected&lt;/em&gt; for it is a geographical representation.
This datum is one that is used in GPS systems and is often referred to as a &lt;em&gt;word wide datum&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;When you store objects with an SRID of 4326, you are storing them using geographical coordinates aka latitude and longitude.
This in contrast to, for example, the former SRID's, like 4267 or 4269, which store their coordinates in UTM values.
When you do measurements between two objects carrying this SRID you have two options. You can either do a geographical or a geometrical measurement.&lt;/p&gt;
&lt;p&gt;With a geographical measurement there will be no projection and the system will use the WSG 84 datum (the spheroid) to calculate the distance, in three dimensional space.
As we have seen before, such a calculation is more expensive and unconventional.&lt;/p&gt;
&lt;p&gt;With a geometrical measurement, your geographical coordinates have to be &lt;em&gt;projected&lt;/em&gt; on to a flat Cartesian or &lt;em&gt;geometrical&lt;/em&gt; plane.
This is done automatically when you ask PostGIS to measure distance using one of the more common geometrical functions.
When projecting, all GIS systems will use the &lt;em&gt;Plate Carrée&lt;/em&gt; projection which means they will use the stored latitude and longitude coordinates directly as an X and Y value.&lt;/p&gt;
&lt;p&gt;Let us see this story in action. First we can take a look at the more native geography data. Let us clean our shape table first:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;DropGeometryColumn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'shapes'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'shape'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Here we use the &lt;em&gt;DropGeometryColumn()&lt;/em&gt; to remove this column from out "shapes" table. Now clear the table:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;TRUNCATE&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Next add a new geography column:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="k"&gt;COLUMN&lt;/span&gt; &lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="n"&gt;geography&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POINT'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We create a new &lt;em&gt;geography&lt;/em&gt; column with the name &lt;em&gt;location&lt;/em&gt; in our "shapes" table. We will only be storing Point types.&lt;/p&gt;
&lt;p&gt;Notice that the syntax is different and that here we use plain SQL as opposed to the &lt;em&gt;AddGeometryColumn()&lt;/em&gt; function from before.
Since PostGIS 2 it is possible to create and drop both geometry and geography columns with standard SQL syntax.&lt;/p&gt;
&lt;p&gt;If you wish to rewrite our "shape" column addition from the beginning of this chapter, you could write it like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="k"&gt;COLUMN&lt;/span&gt; &lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POLYGON'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Looks more native and simple, no? Sorry to tell you this so late in the adventure, but now you know the existence of both the functions and the more native SQL syntax. Both will also keep the PostGIS bookkeeping in sync.&lt;/p&gt;
&lt;p&gt;Also, for fun, you could do a describe on the table:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt; Column  &lt;span class="p"&gt;|&lt;/span&gt;         Type          &lt;span class="p"&gt;|&lt;/span&gt; Modifiers 
----------+-----------------------+-----------
name     &lt;span class="p"&gt;|&lt;/span&gt; character varying     &lt;span class="p"&gt;|&lt;/span&gt; 
location &lt;span class="p"&gt;|&lt;/span&gt; geography&lt;span class="o"&gt;(&lt;/span&gt;Point,4326&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you can see, the column is of type &lt;em&gt;geography&lt;/em&gt; and automatically gets the famous SRID 4326.&lt;/p&gt;
&lt;p&gt;Good, let us now try and find an answer to our famous question, How far is Tokyo from my current location. You will be surprised how trivial this will be.&lt;/p&gt;
&lt;p&gt;First, as you might suspect, since we are only interested in a point on the earth and not the shape of your location nor Tokyo, we will suffice with a Point object.
Next we will need to insert two points into our database, your location and the center of Tokyo, both in geographical coordinates.&lt;/p&gt;
&lt;h4&gt;Finding Your Location&lt;/h4&gt;
&lt;p&gt;This means you need to find out your exact latitude and longitude of the place you are at right now.&lt;/p&gt;
&lt;p&gt;This could, of course, be done in a myriad of ways: using your cell phone's GPS capabilities, using your dedicated GPS device or using an online map system.
I will choose the latter and will be using OpenStreetMap (what else?) to locate my current position.&lt;/p&gt;
&lt;p&gt;Open up your favorite web browser and surf to &lt;a href="http://openstreetmap.org"&gt;openstreetmap.org&lt;/a&gt;.
Once there, punch in your address or use the "Where Am I" function. This would give you a point on the map and in the search bar on the left your latitude and longitude coordinate.
Take this coordinate and save is as point data into your fresh column:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'My location'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ST_GeographyFromText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POINT(127.6791949 26.2124702)'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The point I am inserting reflects central Naha, the main city of the Okinawa prefecture. Not my current location, but it serves as an illustrative point.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt; that PostGIS expects a longitude as X and latitude as Y. This is many times reversed as what you get back from other sources.&lt;/p&gt;
&lt;p&gt;Now you can insert the location of Tokyo, which I conveniently looked up for you:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Tokyo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ST_GeographyFromText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POINT(139.7530053 35.6823815)'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Ah, nice! Okay, are you ready to finally, after all the rambling we went through, know the distance?
You already know the syntax, punch in the magic:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'My location'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Tokyo'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;In the case you would live in the exact cartographic center of Naha, you will get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;   &lt;span class="n"&gt;st_distance&lt;/span&gt;    
&lt;span class="c1"&gt;------------------&lt;/span&gt;
 &lt;span class="mi"&gt;1557506&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;28103692&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Yeah! This, my lovely folk, is how far you are from Tokyo, at this very moment.&lt;/p&gt;
&lt;p&gt;But what is this number you get back? &lt;/p&gt;
&lt;p&gt;The result you see here is the distance returned in &lt;em&gt;Meters&lt;/em&gt;, meaning, from the point I inserted as "My location", I am 1557506.28 Meters or &lt;em&gt;1557.50628 Kilometers&lt;/em&gt; from Tokyo.&lt;/p&gt;
&lt;p&gt;Very neat stuff, would you not say? PostgreSQL just told us how far we are from Tokyo, &lt;em&gt;awesome&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;But wait, we are not finished yet. We have now done the most accurate, real geographical distance measurement using expensive geographical calculations.&lt;/p&gt;
&lt;p&gt;There is an "in-between" solution before we jump to geometry. PostGIS gives us the ability to replace our spheroid datum with the more classical sphere.
The latter has much simpler calculations, but can still return more accurate results them some of the projections.&lt;/p&gt;
&lt;p&gt;To redo our calculation from above with a sphere, simply set the spheroid Boolean, a third and optional parameter to the &lt;em&gt;ST_Distance()&lt;/em&gt; function, to &lt;em&gt;False&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'My location'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Tokyo'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;   &lt;span class="n"&gt;st_distance&lt;/span&gt;    
&lt;span class="c1"&gt;------------------&lt;/span&gt;
&lt;span class="mi"&gt;1557886&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;68227339&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Which is a total distance of &lt;em&gt;1557.886 Kilometers&lt;/em&gt;, a difference of around 300 Meters.&lt;/p&gt;
&lt;p&gt;Let us now repeat this story, but use &lt;em&gt;geometry&lt;/em&gt; instead. Let us do it the GIS conventional way.&lt;/p&gt;
&lt;p&gt;We do not need to recreate our column as a geometry column and insert our data again. We could cheat a little.
PostGIS together with PostgreSQL has the unique capability of &lt;em&gt;casting&lt;/em&gt; data from one type to another.
So without recreating anything, we could simply cast our geography data into geometry &lt;em&gt;on the fly&lt;/em&gt; and see what happens.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt; that casting, while very convenient for quick checks, can render an index totally mute.
It is therefor important to think ahead and decide if you want to work with geometry or geography, then create the correct column type and use this &lt;em&gt;without&lt;/em&gt; casting.&lt;/p&gt;
&lt;p&gt;But for our quick and dirty queries, this is fine. Let us continue:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'My location'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Tokyo'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;In this query, we cast (&lt;em&gt;::&lt;/em&gt;) the geography data inside the "location" columns into geometry.
Now we get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;   &lt;span class="n"&gt;st_distance&lt;/span&gt;    
&lt;span class="c1"&gt;------------------&lt;/span&gt;
&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;3445794209231&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Hmm, that is a different result all together. It looks like a much smaller number then before. What is happening?&lt;/p&gt;
&lt;p&gt;We just casted our geography to geometry, this means PostGIS will now use a Cartesian system or &lt;em&gt;projection&lt;/em&gt; to calculate the distance in a linear way.
When using the distance measuring function &lt;em&gt;ST_Distance()&lt;/em&gt; on geometry, it will return not meters but the distance expressed in the units the original data was stored in.
Since our data is stored with SRID 4326, its units are latitude and longitude. The value you get back is thus &lt;em&gt;degrees&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In the case of the Naha location, this will be &lt;em&gt;15.344&lt;/em&gt; degrees from Tokyo.&lt;/p&gt;
&lt;p&gt;For our human brain this is difficult to imagine, a result in Meters is much more easy to comprehend. So, let us transform this degree value into a metric value.&lt;/p&gt;
&lt;p&gt;It is an estimation that one planar degree (in our Cartesian system) equals 111 KM. So the distance now becomes 15.344 degrees times 111: &lt;em&gt;1703 Kilometers&lt;/em&gt;.
That is a difference of about 145 Kilometers. &lt;/p&gt;
&lt;p&gt;The reason this difference exist is of the projection we are now using. As we have mentioned a few times before, when going from data containing SRID 4326, PostGIS will automatically use the infamous &lt;em&gt;Plate Carrée&lt;/em&gt; projection. This projection, as we have seen before, is the &lt;em&gt;least&lt;/em&gt; accurate for something like distance measuring.&lt;/p&gt;
&lt;p&gt;So let us poke this projection mechanism and try a different, more accurate one, the Lambert, which carries SRID &lt;em&gt;3587&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To change the projection PostGIS will use, we can use the &lt;em&gt;ST_Transform()&lt;/em&gt; function which casts objects to different SRIDs.
Note that &lt;em&gt;ST_Transform()&lt;/em&gt; only works for geometry objects, so we have to continue to cast our geography location to be able to use them in this function.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ST_Transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3587&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;ST_Transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3587&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'My location'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Tokyo'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will gives us:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;   &lt;span class="n"&gt;st_distance&lt;/span&gt;    
&lt;span class="c1"&gt;------------------&lt;/span&gt;
&lt;span class="mi"&gt;1602392&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;18109279&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Meaning &lt;em&gt;1602.392 Kilometers&lt;/em&gt;, a difference of about 45 Kilometers. That is indeed in between the Plate Carrée and our native geographical measurement.&lt;/p&gt;
&lt;p&gt;Another, even more accurate and popular projection is our famous UTM. It can, however, not be used on a world scale. You can only perform measurements within the same UTM zone.&lt;/p&gt;
&lt;p&gt;As mentioned in the previous chapter, there are roughly 60 World UTM zones on the earth, but each zone uses their own projection and their own coordinates.
This kind of projection is thus not fit for measuring distance on such a large scale.&lt;/p&gt;
&lt;p&gt;Let us therefor take this one step further before I leave you to rest. Let us do a measurement with such a UTM projection.
We will make a measurement inside of Japan's mainland UTM zone: &lt;em&gt;54N&lt;/em&gt; which has an SRID of &lt;em&gt;3095&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;First we will have to make another point in our database:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Aomori'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ST_GeographyFromText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'POINT(140.750616 40.788079)'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This point represents the city of Aomori in northern Japan, famous for its huge lantern parades.&lt;/p&gt;
&lt;p&gt;First let us measure with the native geographical calculations:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Aomori'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Tokyo'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This returns:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;st_distance&lt;/span&gt;    
&lt;span class="c1"&gt;------------------&lt;/span&gt;
&lt;span class="mi"&gt;573416&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;203868172&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Or &lt;em&gt;573.416 Kilometers&lt;/em&gt;, which is most accurate.&lt;/p&gt;
&lt;p&gt;Next, let us throw the good old &lt;em&gt;Plate Carrée&lt;/em&gt; projection at it:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Aomori'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Tokyo'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will yield&lt;/p&gt;
&lt;pre class="code literal-block"&gt;    &lt;span class="n"&gt;st_distance&lt;/span&gt;    
&lt;span class="c1"&gt;------------------&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;20224702126502&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Which is in degrees again, doing this times 111 Kilometers will yield a total distance of &lt;em&gt;577.444 Kilometers&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;Then let us measure using the correct UTM projection:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ST_Distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ST_Transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3095&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;ST_Transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3095&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; 
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Aomori'&lt;/span&gt; &lt;span class="k"&gt;AND&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Tokyo'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will give us:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;  &lt;span class="n"&gt;st_distance&lt;/span&gt;    
&lt;span class="c1"&gt;------------------&lt;/span&gt;
&lt;span class="mi"&gt;573228&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;002047378&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Or &lt;em&gt;573.228 Kilometers&lt;/em&gt; and thus only around 200  meters different, in contrast with the Plate Carrée, which was 4 Kilometers different.&lt;/p&gt;
&lt;p&gt;You can see that different projections will result in different measurements. It is therefor crucial to know which one to choose.
Some are better used on a local scale, like we just did for Japan, others are better on a global scale.&lt;/p&gt;
&lt;p&gt;Again, it all comes down to trade-offs and choices.&lt;/p&gt;
&lt;p&gt;Okay, yet another big chunk of PostGIS goodness is taken. I suggest a good rest of the mind.&lt;/p&gt;
&lt;p&gt;We have seen how we can insert various types of geometry and geography, we saw how to manipulate and question them and we looked at a few real world measurements.&lt;/p&gt;
&lt;p&gt;In the next and final chapter, we will be looking at loading some real GIS data from OpenStreetMap into our PostGIS database, take a quick look around my town here in Okinawa and take a deeper look at creating some important indexes.&lt;/p&gt;
&lt;p&gt;And as always...thanks for reading!&lt;/p&gt;
&lt;!--  LocalWords:  PostGIS PostgreSQL GIS
 --&gt;&lt;/div&gt;</description><guid>http://shisaa.be/ja/postset/postgis-postgresqls-spatial-partner-part-2.html</guid><pubDate>Wed, 18 Jun 2014 10:00:00 GMT</pubDate></item><item><title>Postgis, PostgreSQL's spatial partner - Part 1</title><link>http://shisaa.be/ja/postset/postgis-postgresqls-spatial-partner-part-1.html</link><dc:creator>Tim van der Linden</dc:creator><description>&lt;div&gt;&lt;h3&gt;Preface&lt;/h3&gt;
&lt;p&gt;In Dutch we have an expression that says "Van hier tot Tokio", which literally translated means "From here to Tokyo" and is used to indicate that something is &lt;em&gt;very&lt;/em&gt; far or &lt;em&gt;very&lt;/em&gt; difficult.
Unless you live in Japan, like me, then Tokyo is not &lt;em&gt;that&lt;/em&gt; far actually....but you get the point. Tokyo is far, period.&lt;/p&gt;
&lt;p&gt;But the question for today is...&lt;em&gt;how&lt;/em&gt; far is it &lt;em&gt;exactly&lt;/em&gt;? From where you are reading this right now...how far is Tokyo from you? How can you know?
You could of course just hop online and question your favorite search engine for help, or use something like Open Street Map to figure it out.&lt;/p&gt;
&lt;p&gt;But that would be too simply, no? This would mean my post has to stop here, and, as some of you might know, it is difficult for me to write short blog posts. Sorry.&lt;/p&gt;
&lt;p&gt;Also, you would miss out on all of the fun that is actually happening behind the screen when you question spatial search engines and that is against my belief: &lt;em&gt;know how the tools you depend on actually work&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;And, as the same some of you might know, I love PostgreSQL.&lt;/p&gt;
&lt;p&gt;So, knowing that I cannot write short posts &lt;em&gt;and&lt;/em&gt; I like PostgreSQL...what would you suspect would happen if you ask me how far Tokyo is from my current location?
You guessed it, simply use The Elephant to figure that out!&lt;/p&gt;
&lt;p&gt;As I have showed you &lt;a href="http://shisaa.be/postset/postgresql-full-text-search-part-1.html" title="PostgreSQL full text search, chapter one."&gt;before&lt;/a&gt;, PostgreSQL is capable of storing, matching and retrieving much more then boring VARCHAR or INT data types and it is designed to be extendable.
And extending is what the folks behind the &lt;em&gt;PostGIS&lt;/em&gt; project did. To summarize, the PostGIS project extends PostgreSQL to store, match, manipulate and retrieve &lt;em&gt;spatial&lt;/em&gt; data. It makes PostgreSQL a full-blown GIS.&lt;/p&gt;
&lt;p&gt;The purpose of this series is to get your feet wet with PostGIS and to learn a thing or two about GIS itself.
In the first chapter, the one you are reading now, I would like to show you some fundamental GIS concepts: GIS Objects, standardization of GIS, geography and projections. 
We will not be doing any database action today I am afraid.&lt;/p&gt;
&lt;p&gt;Then, starting from the second chapter, we will open up PostgreSQL, initiate a database to be PostGIS aware and start playing around.
We will look at a bunch of different database functions we have available and how the knowledge from this chapter maps to the actual database.
And we will of course be solving the question posed above: how far is Tokyo from your current location. &lt;/p&gt;
&lt;p&gt;Are you ready for a new PostgreSQL adventure?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; I will take you over all the following information in lighting speed. 
My intent is not to make you a GIS expert, but I do feel it is necessary to touch on a few important topics so you know why PostGIS is doing stuff the way it does.
This will hopefully make the actual database work from the next chapter more clear and spark some curiosity towards learning more about this topic.&lt;/p&gt;
&lt;h3&gt;The data&lt;/h3&gt;
&lt;p&gt;Before we can do anything GIS related, we need to take a look at what kind of data we will be working with: the GIS objects.&lt;/p&gt;
&lt;h4&gt;GIS Objects?&lt;/h4&gt;
&lt;p&gt;Geographic information system, or GIS in short, is merely the name of any system which can store, retrieve, generate, manipulate and visualize spatial data - the kind of data that represents objects in two or three dimensional space.&lt;/p&gt;
&lt;p&gt;The GIS world is a world of standards, as with most computer sciences. These standards define what spatial data is and how we can work with it and is defined and maintained by the Open Geospatial Consortium or &lt;em&gt;OGC&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Every system that wishes to work with GIS data, including PostGIS, should adhere to these standards.&lt;/p&gt;
&lt;h4&gt;Simple Features&lt;/h4&gt;
&lt;p&gt;The OGC's standard for working with GIS data in SQL is defined in a OGC and &lt;em&gt;ISO&lt;/em&gt; specification called &lt;em&gt;Simple Features&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Simple Features defines how we can represent spatial objects, as you will see soon, but also defines how we can access and manipulate them.
You typically have available:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Functions to &lt;em&gt;create&lt;/em&gt; two dimensional spatial objects&lt;/li&gt;
&lt;li&gt;Functions to &lt;em&gt;alter&lt;/em&gt; these objects&lt;/li&gt;
&lt;li&gt;Functions to &lt;em&gt;retrieve&lt;/em&gt; and &lt;em&gt;describe&lt;/em&gt; single or multiple objects&lt;/li&gt;
&lt;li&gt;Functions to &lt;em&gt;compare&lt;/em&gt; and &lt;em&gt;measure&lt;/em&gt; single or multiple objects&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PostGIS has been certified by the OGC for its wide support of the Simple Features set.&lt;/p&gt;
&lt;h4&gt;Well-known Text&lt;/h4&gt;
&lt;p&gt;The first and most important part that is defined in the Simple Features spec are the means by which we can represent spatial data.
I mean, we know how we can represent numbers or strings of text inside our database, but how do we represent something more abstract as a line, or a square?&lt;/p&gt;
&lt;p&gt;Folks familiar with 2D drawing or 3D modeling software might already have a gut feeling of how to represent such data, and this gut feeling is right: you store coordinates.
If you wish to represent a line, you will only need to know the two end points of this line to be able to store, manipulate or visualize it.
The same goes for a square, though there you will need four coordinates.&lt;/p&gt;
&lt;p&gt;And, as is always the case with standards, the OGC has devised two famous ways of representing these objects and their coordinates: Well-known Text or &lt;em&gt;WKT&lt;/em&gt; and Well-know Binary or &lt;em&gt;WKB&lt;/em&gt;.
These two are almost identical, only differing in the area of use.&lt;/p&gt;
&lt;p&gt;WKT is a markup language which you can use to simply write down your objects and use it in queries. It is human readable.
However, if you wish to store it in a database or wish to perform matches on the data, it has to be stored in a defined binary format, the WKB format that is.&lt;/p&gt;
&lt;p&gt;WKT can represent a wide range of objects from simple points to complex multi-polygons. The notation, however, stays roughly the same.
If you wish to represent a square, for example, you could use the &lt;em&gt;POLYGON&lt;/em&gt; object:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;POLYGON&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;For people unfamiliar with the term "polygon", a polygon is a &lt;em&gt;closed&lt;/em&gt;, &lt;em&gt;two dimensional&lt;/em&gt; object with only &lt;em&gt;straight&lt;/em&gt; lines. It has to have a minimum of three coordinates (points) thus giving it a minimum of three straight edges (making it, in that case, a triangle).&lt;/p&gt;
&lt;p&gt;Let us take a deeper look at what is happening here. First, you will see we define a polygon object which you will need if you wish to represent closed, shape objects.
Next we define the four coordinates, the four corners of our square, laid out on a fictional grid of 4 by 4 units. There are two important notes to take about this coordinate listing:&lt;/p&gt;
&lt;p&gt;First, the coordinates are all two dimensional and represent and X and a Y coordinate respectively.&lt;/p&gt;
&lt;p&gt;Also, you do not see four but &lt;em&gt;five&lt;/em&gt; coordinates. This is another rule from the spec that tells us that all polygon shapes &lt;em&gt;must&lt;/em&gt; be closed.
To get a better visualization of this you could imagine a pen moving to each coordinate. To finish the loop you draw, the pen has to move back to the original coordinate.&lt;/p&gt;
&lt;p&gt;The last thing to note is that the drawing direction of these coordinates is &lt;em&gt;counterclockwise&lt;/em&gt;, as is with most computer defined drawing systems.
This means we put our pen on our grid at coordinate (4 1) and then draw &lt;em&gt;up&lt;/em&gt; in a straight line to (4 4). Next we go &lt;em&gt;left&lt;/em&gt; in a straight line to (1 4) and &lt;em&gt;down&lt;/em&gt; in a straight line to (1 1).
Finally, we close the loop by drawing a straight line &lt;em&gt;right&lt;/em&gt;, to the starting coordinate (4 1).&lt;/p&gt;
&lt;p&gt;It is also perfectly possible to define more then one coordinate set when defining a polygon object.
A definition like this is perfectly legal:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;POLYGON ((8 1, 8 8, 1 8, 1 1, 8 1), (6 3, 6 6, 3 6, 3 3, 6 3))
&lt;/pre&gt;


&lt;p&gt;This will create a square polygon with a size of 8 by 8, called the &lt;em&gt;exterior ring&lt;/em&gt; and another square inside it with a size of 4 by 4.
Because this small square resides &lt;em&gt;inside&lt;/em&gt; the area of the big square we call it the &lt;em&gt;interior ring&lt;/em&gt; and, as a result, this small square will be interpreted by the standard as a hole in the bigger square.&lt;/p&gt;
&lt;p&gt;To bring this even further, you can define as many holes in your exterior ring as you like, you simply have to make sure that the interior rings never touch each other and never go outside of the exterior ring.
The exterior ring is always derived from the first set of coordinates in your object definition.&lt;/p&gt;
&lt;p&gt;The POLYGON object in the WKT standard also has a &lt;em&gt;MULTIPOLYGON&lt;/em&gt; counterpart for when you wish to define a multiple, &lt;em&gt;non intersecting&lt;/em&gt; set of polygon objects which, in turn, can have as many interior rings as you like.&lt;/p&gt;
&lt;p&gt;Other objects we have available in the WKT standard are:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;POINT(0 0) to represent a point on a grid&lt;/li&gt;
&lt;li&gt;LINESTRING(0 0, 0 1) to represent a line. Note that a line can consist out of more then two coordinates.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;All of these also have a &lt;em&gt;MULTIPOINT&lt;/em&gt; and a &lt;em&gt;MULTILINESTRING&lt;/em&gt; variant respectively.&lt;/p&gt;
&lt;p&gt;As we have seen before, all of these objects are two dimensional, but PostGIS also partly supports a three and a four dimensional version of some of these objects.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt; that these extra dimensions are currently &lt;em&gt;not&lt;/em&gt; in de specification and is a PostGIS specific extension on top of the features defined by the OGC.
Furthermore, if the OGC decides to standardize three of four dimensional objects, PostGIS will have to adapt its syntax to stay compliant.
We thus refer to this extended format not as WKT or WKB but as &lt;em&gt;Extended&lt;/em&gt; WKT and &lt;em&gt;Extended&lt;/em&gt; WKB or simply &lt;em&gt;EWKT&lt;/em&gt; and &lt;em&gt;EWKB&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To make our polygon object three dimensional, we could write it down like so:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;POLYGON&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You can see that we now have three numbers per coordinate, the third one adds a &lt;em&gt;Z&lt;/em&gt; or &lt;em&gt;depth&lt;/em&gt; value.&lt;/p&gt;
&lt;p&gt;A point gets even more fancier. If we wish to place a point in three dimensional space, we could write it down the same as we did with our polygon:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;POINT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The third parameter here being, again, a place on the &lt;em&gt;Z&lt;/em&gt; axis.&lt;/p&gt;
&lt;p&gt;But points can also have a &lt;em&gt;fourth&lt;/em&gt; dimension which sounds fancy, but is nothing more then an extra reference we can ship with our coordinates.
This reference, also called a &lt;em&gt;linear reference&lt;/em&gt;, is a number we can put in place that tell us where, along a linear path, the point we define resides.&lt;/p&gt;
&lt;p&gt;It can be written down like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;POINT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Here we have four numbers, the last one being the linear reference or &lt;em&gt;M&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;With EWKT you also have the possibility to define a two dimensional object with a linear reference:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;POINT&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Here we have again three numbers, but to distinguish between the last number being &lt;em&gt;Z&lt;/em&gt; or &lt;em&gt;M&lt;/em&gt;, we have to reference &lt;em&gt;M&lt;/em&gt; together with our point declaration.
There are more extensions defined in the EWKT and EWKB, but that is slightly off-topic, because, as I mentioned before, these are not standardized.
In most use cases you can simply use the standard WKT and WKB forms.&lt;/p&gt;
&lt;h4&gt;What to use these objects for?&lt;/h4&gt;
&lt;p&gt;You now know what kind of objects we can represent using text and what we can, later along the road, insert into our PostGIS enabled PostgreSQL database.
But how do these points, lines and polygons help us measure distance or help us locate stuff?&lt;/p&gt;
&lt;p&gt;First it is important to understand that all of the objects we have available will act as &lt;em&gt;proxies&lt;/em&gt; to real world objects.
Take, for example, the point. A point can be used on a map to indicate a place, a spot so to speak, without defining shape or size.
When you wish to know where Tokyo is, a point will suffice on a global scale, you do not need nor want to know the exact shape of the metropolis.&lt;/p&gt;
&lt;p&gt;However, if you would zoom in on our fictional map and you wish to see a part of the city the size of a few city blocks, you might be interested in the shapes of buildings, lakes, parks, etc.
These items that take up two &lt;em&gt;dimensional space&lt;/em&gt; will be drawn with polygons that resemble the shape of the real world objects as close as possible.&lt;/p&gt;
&lt;p&gt;Lines (or linestrings), finally, will almost always be used to represent roads, railroads, metro systems, etc. They many times represent actual &lt;em&gt;paths&lt;/em&gt; one could travel along.&lt;/p&gt;
&lt;h3&gt;Geometry and Geography&lt;/h3&gt;
&lt;p&gt;So you know that you can represent a place in the world with a simple point.
And as you also know, a point is defined like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;POINT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This would create a point that sits at coordinate (10 20). But, what does that mean?
How do these numbers relate to the &lt;em&gt;real world&lt;/em&gt;? What &lt;em&gt;is&lt;/em&gt; 10 or 20 anyway?&lt;/p&gt;
&lt;p&gt;Well, first you will have to ask yourself the following question: Do I wish to be Cartesian or Geographical?&lt;/p&gt;
&lt;h4&gt;Cartesian or Geographical&lt;/h4&gt;
&lt;p&gt;As you may or may not remember from your boring math lessons, a Cartesian system is a two dimensional flat grid with a X and a Y axis.
These axis go both positive and negative with the origin sitting exactly in the middle of the flat plane.&lt;/p&gt;
&lt;p&gt;When working with GIS objects, we refer to this flat, Cartesian grid system as &lt;em&gt;Geometry&lt;/em&gt;.
When, however we are working with measurements or objects related to the &lt;em&gt;real&lt;/em&gt; earth we, in PostGIS, refer to these measurements as &lt;em&gt;Geography&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Why? what is the difference? Well, to understand this, we have to take a step back, a step back into time that is.&lt;/p&gt;
&lt;p&gt;When the first maps of the world where crafted, people truly believed the earth was flat (which it is not...for your information).
This meant that all charts that where drawn assumed we could simply place a grid comprised out of an X (length) and Y (height) axis across the drawing and from their measure distances between points. If you wish to know the distance between Paris and London, simply place two points on your map, take your &lt;em&gt;straight&lt;/em&gt; ruler and measure the distance indicated.
Then factor in the chart's scale and you have your distance. You use &lt;em&gt;Geometry&lt;/em&gt; or &lt;em&gt;Geometric measurements&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;However, after Copernicus nearly got his head chopped off telling people the earth was &lt;em&gt;not&lt;/em&gt; flat, the chart drawing people gasped for air.
This meant their measuring technique was not correct. If the earth really was a sphere, then one could not simply wrap a grid around it and act as if everything was linear.
A sphere meant that there was a certain amount of distortion happening with their overlaying grid, and the measurements should encompass for those differences.&lt;/p&gt;
&lt;p&gt;Even later in time, the chart drawing folk, who barely recovered from their first shock, where zapped again when people started to realize the earth was not a sphere either.
The globe turned out to be more of an egg shape, which, again, meant that measurement techniques had to be adjusted.&lt;/p&gt;
&lt;p&gt;This was the birth of the &lt;em&gt;geographical&lt;/em&gt; measurement system where cartographers devices a model called the &lt;em&gt;spheroid&lt;/em&gt;.
A spheroid is a three dimensional object on which we can most accurately place points and measure real earth distances.
Each point on such a spheroid is define by a &lt;em&gt;latitude&lt;/em&gt; and a &lt;em&gt;longitude&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Latitude is measured from the center of the earth (the hot place) in an angle up or down towards the surface&lt;/li&gt;
&lt;li&gt;Longitude is measured from the same hot center in an angle left or right towards the surface&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Because both latitude and longitude represent an angle we express them as a &lt;em&gt;degrees&lt;/em&gt; and we simply call the &lt;em&gt;geographical coordinates&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Now, it is not quite convenient to have to carry around a three dimensional spheroid to find out where you are or to measure distance.
A classical old paper map is still more easy to bring along and more easy to work with.
But how do we go from a spheroid, which has the correct distortion, back to our old, flat, two dimensional geometrical map?&lt;/p&gt;
&lt;p&gt;With &lt;em&gt;projection&lt;/em&gt; or &lt;em&gt;map projection&lt;/em&gt; to be more precise. We need to &lt;em&gt;project&lt;/em&gt; the three dimensional spheroid system onto our two dimensional map.
This projecting is roughly done in three steps.&lt;/p&gt;
&lt;p&gt;First we have to decide whether to take our spheroid as the base or a simpler sphere. A simpler sphere will yield less accurate results because it does not quite represent the correct curvature of the earth, but it does keep the maths behind the calculations simpler and thus can make for faster calculations. When choosing which shape we want, we also will have to define which &lt;em&gt;datum&lt;/em&gt; we would like.&lt;/p&gt;
&lt;p&gt;After choosing the base object and the datum that represents it, we have to transform the geographic system coordinates (latitude and longitude) to more standard X and Y coordinates to be used on a simple, flat, Cartesian plane. &lt;/p&gt;
&lt;p&gt;The last part is to find out to what ratio the final two dimensional surface is scaled compared to the original, base object (which represents the earth).&lt;/p&gt;
&lt;h4&gt;Datum?&lt;/h4&gt;
&lt;p&gt;Before continuing, a word about datums.&lt;/p&gt;
&lt;p&gt;As we said before, people agreed that the earth has a spheroid shape and that this model represents the earth most accurately.
We say "model" because the spheroid is something that is actually &lt;em&gt;defined&lt;/em&gt; with math.&lt;/p&gt;
&lt;p&gt;The math behind the spheroid model is what we call the &lt;em&gt;datum&lt;/em&gt;. It is nothing more then a mathematical formula describing the shape.&lt;/p&gt;
&lt;p&gt;Something we did not see is the fact that there actually are &lt;em&gt;many types&lt;/em&gt; of spheroids out there. Each serving their own purpose and each with their own math aka datum.
Some spheroids are better to do measurements on a global scale, others are better for a more local "zoomed-in" level (continent, country, ...).&lt;/p&gt;
&lt;p&gt;The reason we have to tell which datum (thus shape) our spheroid has, is because while latitude and longitude always represent degrees, they can have different meaning depending on the chosen datum.
If you use a datum that draws the spheroid a little bit "elongated" so to speak, then 1 degree longitude will cover slightly more distance then if the datum draws a more compact spheroid.&lt;/p&gt;
&lt;p&gt;We will see more about datums in the next chapter, but it is an important part of GIS.&lt;/p&gt;
&lt;h3&gt;Types of Projections&lt;/h3&gt;
&lt;p&gt;Something that might not be as obvious right now is the fact that going from our three-dee globe to a flat surface is a process of choices.
In an ideal world you wish to keep every aspect of your spheroid intact, meaning the proportions of the objects on the map are accurate everywhere, the shape of these objects is correct, the area covered by the objects is true and the distance between these objects is retained.
However, as it turns out, this is impossible on a two dimensional surface. You have to give up some of these properties to preserve others.&lt;/p&gt;
&lt;p&gt;Throughout history there have been many attempts at creating projections that would keep as much of these aspects intact.&lt;/p&gt;
&lt;h4&gt;Mercator projection&lt;/h4&gt;
&lt;p&gt;As a Belgian I should be most proud about this type of projection, since it was created by a fellow Flemish-man, around 450 years ago and it is a projection that is still being used today.
When a map is created with this type of projection we will get a comfortable and familiar view of the earth. 
A big advantage of this projection type is the fact that the shape of all objects are accurate.&lt;/p&gt;
&lt;p&gt;The Mercator projection is most accurate around the equator, but the further you travel up or down, the more the map goes out of proportion.
Mercator used a cylindrical projection to unwrap the earth into a flat plane. Because of the nature of such a cylindrical projection, the areas more close to the poles become blown up to fit in a two dimensional world.&lt;/p&gt;
&lt;p&gt;This distortion has caused quite some frowned foreheads in the last few decades and as a result people tend to abandon this projection, specially to project regions far from the equator.&lt;/p&gt;
&lt;h4&gt;Mercator variants&lt;/h4&gt;
&lt;p&gt;To make up for the heavy distortions found in the original Mercator system, people have made two new Mercator projections.
The first that came about was called the &lt;em&gt;Transverse Mercator&lt;/em&gt; which fixes the distortions around the poles, but introduces the problem that it will make for incorrect distance measuring.&lt;/p&gt;
&lt;p&gt;To make up for this new problem, folks made yet another Mercator derivative: the &lt;em&gt;Universal Transverse Mercator&lt;/em&gt;. This type of projection takes a whole new approach and uses its own coordinate system.
It introduces the concept of UTM zones. The earth is divided into roughly 60 zones and are each about 800 Km wide. The map that is rendered in each single zone uses the previous, Transverse Mercator projection to draw the actual map. A big advantage of this approach is the fact that we get a very constant distance measurement all across the globe.&lt;/p&gt;
&lt;p&gt;Such a UTM coordinate looks quite different from our classic latitude/longitude or our X/Y version. I will give you a random UTM coordinate:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="mi"&gt;54&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="mi"&gt;384524&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;3948304&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The first number identifies one of the 60 UTM zones. The letter N show us in which hemisphere we should search this zone. These letters range from C to X (omitting I and O).
The first float tell us the &lt;em&gt;easting&lt;/em&gt;, or X value, the last float tells us the &lt;em&gt;northing&lt;/em&gt; or the Y value. Both these floats represent actual meters. &lt;/p&gt;
&lt;p&gt;Another important note to take about UTM is that it also acts as a framework for more localized UTM versions.
This means that each country or region could make its own maps, using smaller UTM zones to accurately represent their land, city, forest, etc.&lt;/p&gt;
&lt;h4&gt;Lambert Azimuthal&lt;/h4&gt;
&lt;p&gt;This projection (also called the Lambert Equal-Area) is yet another approach as it uses a &lt;em&gt;disc&lt;/em&gt; to map our spheroid to a flat surface.&lt;/p&gt;
&lt;p&gt;The big advantage of this type of projection is the fact that it represent the area of objects very accurately and is true regarding distance calculation.
However, it fails when it comes to accurate shape representation for shapes get more and more distorted once you start moving away from the center of the disc.&lt;/p&gt;
&lt;p&gt;The Lambert projection is one of the more accepted projections, right after the UTM.&lt;/p&gt;
&lt;h4&gt;Plate Carrée&lt;/h4&gt;
&lt;p&gt;And then you have Plate Carrée.&lt;/p&gt;
&lt;p&gt;This is one of the oldest projections out there and was invented around 1800 years ago.
In our little history story above, this projection came about when people thought the earth was rather flat.&lt;/p&gt;
&lt;p&gt;It combines almost all disadvantages of previous projections:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;It does a terrible job in representing correct area&lt;/li&gt;
&lt;li&gt;It does not care about the shape of objects&lt;/li&gt;
&lt;li&gt;Distance measuring is way off&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Despite the fact that this projection turns out to be so terrible, it is still quite commonly used today.
Well, not for navigation or distance calculation, obviously, but for illustrative purposes.&lt;/p&gt;
&lt;p&gt;Many organizations across the globe use this simple projection to demonstrate statistical data, overlaid on this map.
Demographics, political info, zombie outbreak danger zones, ... .&lt;/p&gt;
&lt;p&gt;As we also saw in our history lesson, the first charts used the Cartesian system quite literally and without much conversion, because the earth was flat anyway.
So in GIS systems, this means that this projection maps latitude and longitude &lt;em&gt;directly&lt;/em&gt; to a X and Y coordinate without much conversion.&lt;/p&gt;
&lt;p&gt;Because the conversion math is simple and calculations are few, this projection is among the fastest, but as you know now, at great cost.&lt;/p&gt;
&lt;h4&gt;Other variants&lt;/h4&gt;
&lt;p&gt;There are numerous other variants out there that all have their advantages or disadvantages. To name a few more:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The Robinson projection displays the earth not in a flat image, but in a cylindrical flat sphere. It show the world more accurately, but it fails when it comes to representing area and shape, especially near the poles.&lt;/li&gt;
&lt;li&gt;The Winkel Tripel projection is another popular projection type which has many parallels with the Robison one, but has less distortion.&lt;/li&gt;
&lt;li&gt;The Peirce quincuncial projection uses a technique to unwrap the earth spheroid into a square, much like you would peel an orange. These maps are not used much, for they are very heavy in calculations, but the technique is now widely used to present a spherical image, unwrapped into a square.&lt;/li&gt;
&lt;li&gt;The Goode homolosine projection is a projection developed as a teaching instrument in a frustrating answer to the heavily distorted Mercator projection. It is famous for its quite unique shape where the spheroid is unwrapped into a beast with four "legs".&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;What do projections mean to us?&lt;/h3&gt;
&lt;p&gt;There are many more types of projections, but that would bore you to tears.&lt;/p&gt;
&lt;p&gt;The fact that I keep going on about projections, geometry and geography is because later on, when working with PostGIS, you will need to make a decision about how you wish to combine all of these.&lt;/p&gt;
&lt;p&gt;First it is very important to understand that geometry and geography are &lt;em&gt;two different data types&lt;/em&gt; which PostGIS can store into PostgreSQL.&lt;/p&gt;
&lt;p&gt;PostGIS is quite unique in the fact that it gives you the ability to work &lt;em&gt;directly&lt;/em&gt; with our three dimensional spheroid (geography) and ignore the projections and their Cartesian Flat Land (geometry).
You will have the power to work with latitude and longitude and perform real world calculations, right out of the box.
This way of working, however, comes with a few trade-offs.&lt;/p&gt;
&lt;p&gt;The first, and most obvious one: real, three dimensional spheroid geographical calculations will cost more computing time then the simpler, two dimensional geometry counterparts.
Another disadvantage of geography over geometry is the fact that PostGIS simply has &lt;em&gt;much&lt;/em&gt; less native functions ready for you to use.&lt;/p&gt;
&lt;p&gt;So depending on your use case, it might be a good idea to convert all your geographical data into geometrical ones.
This, however, requires knowledge about the projections we just saw for different projections will yield different results.&lt;/p&gt;
&lt;p&gt;If you have two points with a latitude and longitude coordinate (thus being geographical data) and wish to know the distance between them using geometrical functions, you have to project these points on a flat surface thus converting them into a Cartesian system (the whole projection story we saw so far). &lt;/p&gt;
&lt;p&gt;As we will see in the next chapter, if you simply convert geography into geometry, PostGIS will project the geometry coordinates using the Plate Carrée, which may not be very desirable when you which to calculate distances as we will be doing later on. We have the ability to tell PostGIS to use a different projection when converting, but all come with merits and demerits.&lt;/p&gt;
&lt;p&gt;You simply cannot do serious GIS work if you do not have at least a basic understanding of what is going on when projecting geography.
By reading through this chapter, I hope I have given you enough food-for-thought to go out and explore a bit more about these different projections.&lt;/p&gt;
&lt;h3&gt;What is next?&lt;/h3&gt;
&lt;p&gt;Okay, I think we have covered enough for today. I do apologize for the rather theoretical nature of this first chapter, but believe me, you will need the knowledge.&lt;/p&gt;
&lt;p&gt;Next time we will finally be looking at some actually PostGIS work and put some of this theory into practice:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;We will see how to GIS enable your PostgreSQL database&lt;/li&gt;
&lt;li&gt;We will look at how we can store geometry and geography&lt;/li&gt;
&lt;li&gt;We will actually put some points on the earth, draw some lines between them and perform some fun calculations&lt;/li&gt;
&lt;li&gt;We will take a look at how different projections will yield different results&lt;/li&gt;
&lt;li&gt;And finally, we will answer the question that started it all: How far is Tokyo from your current location?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;And as always...thanks for reading!&lt;/p&gt;
&lt;!--  LocalWords:  PostGIS GIS PostgreSQL
 --&gt;&lt;/div&gt;</description><guid>http://shisaa.be/ja/postset/postgis-postgresqls-spatial-partner-part-1.html</guid><pubDate>Thu, 12 Jun 2014 10:00:00 GMT</pubDate></item></channel></rss>