<!DOCTYPE html>
<html><body><div class="postbox">
 Postgis, PostgreSQL's spatial partner - Part 2
 <p class="post-date">18/06/2014 <span>-</span> </p>
 <div class="post">
  <div>
<p>Welcome to the secoflynd part of our spatial story. If you have not done so, I advise you to go and read <a href="http://shisaa.jp/postset/postgis-postgresqls-spatial-partner-part-1.html" title="Part one of this series.">part one</a> first.</p>
<p>The first part of this series gives you some basic knowledge about the GIS world (GIS Objects, WKT, Projections, ...).
This knowledge will come in handy in this chapter.</p>
<p>Today we will finally take an actual peek at PostGIS and do some database work:</p>
<ul>
<li>We will see how we can create valid GIS objects and insert them into our database</li>
<li>Next let PostGIS retrieve information about these inserted GIS objects</li>
<li>Further down the line we will manipulate these object a bit more</li>
<li>Then we will leap from geometry into geography</li>
<li>Finally we will be doing some real world measurements</li>
</ul>
<p>Let us get started right away!</p>
<h3>Creating the database</h3>
<p>Before we can do anything else, we need to make sure that we have the PostGIS extension installed.
PostGIS is most of the time packaged as a PostgreSQL contribution package.
On a Debian system, it can be installed as follows:</p>
<pre class="code literal-block"><span></span>apt-get install postgresql-9.3-postgis-2.1
</pre>


<p>This will install PostGIS version 2.1 for the PostgreSQL 9.3 database.</p>
<p>Next, fire up your database console and let us first create a new user and database:</p>
<pre class="code literal-block"><span></span><span class="k">CREATE</span> <span class="k">user</span> <span class="n">gis</span> <span class="k">WITH</span> <span class="n">PASSWORD</span> <span class="s1">'10gis10'</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="n">gis</span> <span class="k">WITH</span> <span class="k">OWNER</span> <span class="n">gis</span><span class="p">;</span>
</pre>


<p>Not very original names, I know, but it states its purpose.
Next, connect to the <em>gis</em> database and enable the PostGIS extension:</p>
<pre class="code literal-block"><span></span><span class="err">\</span><span class="k">c</span> <span class="n">gis</span>
<span class="k">CREATE</span> <span class="n">EXTENSION</span> <span class="n">postgis</span><span class="p">;</span>
</pre>


<p>Now our database is PostGIS aware, and we are ready to get our hands dirty!</p>
<p>Notice that if you now describe your database:</p>
<pre class="code literal-block"><span></span><span class="err">\</span><span class="n">d</span>
</pre>


<p>PostGIS has created a new table and a few new views. This is PostGIS's own bookkeeping and it will store which tables contain geometry or geography columns.</p>
<h3>Fun with Polygons</h3>
<p>Let us begin this adventure with creating a polygon that has one interior ring, similar to the one we saw in the previous chapter.</p>
<p>Before we can create them, though, we have to create a table that will hold their geometrical data:</p>
<pre class="code literal-block"><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">shapes</span> <span class="p">(</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span>
<span class="p">);</span>
</pre>


<p>Now we have a table named "shapes" with only a column to store its name. But where do we store the geometry?</p>
<p>Because of the new data types that PostGIS introduces (geometry and geography) and to keep its bookkeeping up to date, you can create this column with a PostGIS function named <em>AddGeometryColum()</em>:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">AddGeometryColumn</span><span class="p">(</span><span class="s1">'shapes'</span><span class="p">,</span> <span class="s1">'shape'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">'POLYGON'</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre>


<p>Let us do a breakdown.</p>
<p>First, all the functions that PostGIS makes available to us are divided in groups that define their area of use. <em>AddGeometryColumn()</em> falls in the "Management Functions" group.</p>
<p>It is a function that will create a geometry column in a table of choice and adds a reference to this column to its bookkeeping. It accepts a number of arguments:</p>
<ul>
<li>The table name to where you wish to add the column</li>
<li>The actual column name you wish to have</li>
<li>The SRID</li>
<li>The WKT object you wish to represent</li>
<li>The coordinate type you desire (2 means XY)</li>
</ul>
<p>In the above case we thus wish to add a geometry column to the "shapes" table. The column will be named "shape". The geometry inserted there will get an SRID of 0 and will be of object type POLYGON and have a normal, two dimensional coordinate layout.</p>
<h4>SRID?</h4>
<p>One thing that you might not yet know from the above function definition is the <em>SRID</em> or <em>Spatial Reference ID</em> and is a <em>very</em> important number when working with spatial data.
Remember in the last chapter I kept on yapping about different projections we had and that each projection would yield different results?
Well, this is where all this information comes together: the SRID.</p>
<p>Our famous OGC has create a lookup table containing a whopping <em>3911</em> entries, each entry with a unique ID, the SRID.
This table is called <em>spatial_ref_sys</em> and is, by default, installed into your PostgreSQL database when you enable PostGIS.</p>
<p>But hold on, there is something I neglected to tell you in the previous chapter: the European Petroleum Survey Group or EPSG.
The following is something that confuses many people and makes them mix-and-match SRID and EPSG ID's. I will try my best not to add up to that confusion.</p>
<h4>EPSG</h4>
<p>The EPSG, now called the OGP, is a group of organizations that, among other things, concern themselves over cartography.
They are the world's number one authority that <em>defines</em> how spatial coordinates (projected or real world) should be calculated.
All the definitions they make get and accompanying ID called the EPSG ID.</p>
<p>The OGC maintains a list to be used inside databases (GIS systems). They give all their entries a unique SRID.
These entries refer to <em>defined</em> and <em>official</em> projections, primarily maintained by the <em>EPSG</em> which have their own EPSG ID and unique name.
Other projections (not maintained by the EPSG) are also accepted into the OGC SRID list as are your own projections (if you would feel the need).</p>
<p>Let us poke the spatial reference table and see if we can get a more clear picture.</p>
<p>If we would query our table (sorry for the wildcard) and ask for a famous SRID (more on this one later):</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">spatial_ref_sys</span> <span class="k">WHERE</span> <span class="n">srid</span> <span class="o">=</span> <span class="mi">4326</span><span class="p">;</span>
</pre>


<p>We would get back one row containing:</p>
<ul>
<li>srid, which is the famous id</li>
<li>auth_name, the name of authority organization, in most cases EPSG</li>
<li>auth_srid, the EPSG ID the authority organization introduced</li>
<li>srtext, tells us how the spatial reference is built using WKT</li>
<li>proj4text, commands that drive the proj4 library which is used to make the actual projections</li>
</ul>
<p>And as you can see, both the "srid" column and the "auth_srid" are identical. This will be the case with many entries.</p>
<p>I should also tell you that this huge list of SRID entries mostly consists of dead or localized projections.
Many of the projections listed are not used anymore, but where popular some time in history (they are marked deprecated), or are very localized. 
In the previous chapter I mentioned that the general UTM system, for example, could be used as a framework for more localized UTM projections.
There are hundreds of these local projections that only make sense when used in the area they are intended for.</p>
<h4>Simple Features Functions</h4>
<p>As I have told you before, the functions that PostGIS makes available are divided into several, defined groups. The functions themselves are too defined, not by PostGIS but by the Simple Features standard maintained by the <em>OGC</em> (as we saw in the previous chapter).</p>
<p>There are a total of 8 major categories available:</p>
<ul>
<li>Management functions: functions which can manipulate the internal bookkeeping of PostGIS</li>
<li>Geometry constructors: functions that can create or construct geometry and geography objects</li>
<li>Geometry accessors: functions that let us access and ask questions about the GIS objects</li>
<li>Geometry editors: functions that let us manipulate GIS objects</li>
<li>Geometry outputs: functions that give us various means by which to transform and "export" GIS objects</li>
<li>Operators: various SQL operators to query our geography and geometry</li>
<li>Spatial relationships and measurements: functions that let us do calculations between different GIS objects</li>
<li>Geometry processing: functions to perform basic operations on GIS objects</li>
</ul>
<p>I have left a few categories out for they are either not part of the Simple Features standard (such as three dimensional manipulations) or beyond the scope.
To see a list of all of the functions and their categories, I advise you to visit the PostGIS reference, <a href="http://postgis.net/docs/reference.html">section 8</a>.</p>
<p>Let us now do some fun manipulations and use some of the functions from these categories, just to get a bit more familiar with how it all works together.</p>
<p>If you inserted the last SQL command which makes the geometry column, you should have gotten back the following result:</p>
<pre class="code literal-block"><span></span><span class="k">public</span><span class="p">.</span><span class="n">shapes</span><span class="p">.</span><span class="n">shape</span> <span class="n">SRID</span><span class="p">:</span><span class="mi">0</span> <span class="k">TYPE</span><span class="p">:</span><span class="n">POLYGON</span> <span class="n">DIMS</span><span class="p">:</span><span class="mi">2</span>
</pre>


<p>This tells us we created the "shape" column in the "shapes" table and set the SRID to 0.
SRID 0 is a convention used to tell a GIS system that you currently do not care about the SRID and simply want to store geometry with an arbitrary X and Y value.</p>
<p>Let us now insert the shape of our square. To insert a polygon into your column, you could use various functions. One of these functions is <em>ST_GeomFromText()</em>:</p>
<pre class="code literal-block"><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">shapes</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span>
    <span class="s1">'Square with hole'</span><span class="p">,</span>
    <span class="n">ST_GeomFromText</span><span class="p">(</span><span class="s1">'POLYGON ((8 1, 8 8, 1 8, 1 1, 8 1), (6 3, 6 6, 3 6, 3 3, 6 3))'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">);</span>
</pre>


<p>This now inserts our polygon and gives it a name. The <em>ST_GeomFromText()</em> function enables us to enter our polygon object using WKT.
This function also accepts a second, optional parameter which is the SRID by which we wish to work.
The category of this function is called <em>Geometry Constructors</em>.</p>
<p>You know this polygon has two rings, the exterior and the interior. Let us now ask PostGIS to return only the line that represents the exterior ring:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_ExteriorRing</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span>
    <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'Square with hole'</span><span class="p">;</span>
</pre>


<p>And we get back:</p>
<pre class="code literal-block"><span></span><span class="mi">0102000020</span><span class="n">E6100000050000000000000000002040000000000000F03F00000000000020400000000000002040000000000000F03F0000000000002040000000000000F03F000000000000F03F0000000000002040000000000000F03F</span>
</pre>


<p>Oh my...that is not what we expected. But yet it is correct. This is how PostgreSQL stores geometry/geography.
The result is correct, yet unreadable to us humans. </p>
<p>If we wish to get back a readable WKT string, we have to convert it using one of the conversion functions:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_AsText</span><span class="p">(</span><span class="n">ST_ExteriorRing</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">FROM</span> <span class="n">shapes</span>
    <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'Square with hole'</span><span class="p">;</span>
</pre>


<p>And we get:</p>
<pre class="code literal-block"><span></span><span class="n">LINESTRING</span><span class="p">(</span><span class="mi">8</span> <span class="mi">1</span><span class="p">,</span><span class="mi">8</span> <span class="mi">8</span><span class="p">,</span><span class="mi">1</span> <span class="mi">8</span><span class="p">,</span><span class="mi">1</span> <span class="mi">1</span><span class="p">,</span><span class="mi">8</span> <span class="mi">1</span><span class="p">)</span>
</pre>


<p>Aha, that is more like it! This we can read!</p>
<p>We used the <em>ST_ExteriorRing()</em> which falls under the <em>Geometry Accessors</em> category and the <em>ST_AsText()</em> function which resides in the category <em>Geometry Outputs</em>.</p>
<p>Okay, now we wish to know the interior ring:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_AsText</span><span class="p">(</span><span class="n">ST_InteriorRingN</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">FROM</span> <span class="n">shapes</span>
    <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'Square with hole'</span><span class="p">;</span>
</pre>


<p>The result:</p>
<pre class="code literal-block"><span></span><span class="n">LINESTRING</span><span class="p">(</span><span class="mi">6</span> <span class="mi">3</span><span class="p">,</span><span class="mi">6</span> <span class="mi">6</span><span class="p">,</span><span class="mi">3</span> <span class="mi">6</span><span class="p">,</span><span class="mi">3</span> <span class="mi">3</span><span class="p">,</span><span class="mi">6</span> <span class="mi">3</span><span class="p">)</span>
</pre>


<p>Notice that the function <em>ST_InteriorRingN()</em> requires you to give the integer of which ring you wish to get, starting from 1.
As we have seen before, polygon objects can have multiple interior rings, but only a single exterior one.</p>
<p>Next let us ask all the information about what makes up the shape:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Summary</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span>
    <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'Square with hole'</span><span class="p">;</span>
</pre>


<p>And get back:</p>
<pre class="code literal-block"><span></span><span class="n">Polygon</span><span class="p">[</span><span class="n">B</span><span class="p">]</span> <span class="k">with</span> <span class="mi">2</span> <span class="n">rings</span><span class="o">+</span>
  <span class="n">ring</span> <span class="mi">0</span> <span class="n">has</span> <span class="mi">5</span> <span class="n">points</span>  <span class="o">+</span>
  <span class="n">ring</span> <span class="mi">1</span> <span class="n">has</span> <span class="mi">5</span> <span class="n">points</span>
</pre>


<p>Ohh, that is pretty cool. We get back a human readable string that explains to us how this particular piece of geometry is build.</p>
<p>Let us now add another polygon:</p>
<pre class="code literal-block"><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">shapes</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span>
    <span class="s1">'The intersecting one'</span><span class="p">,</span>
    <span class="n">ST_GeomFromText</span><span class="p">(</span><span class="s1">'POLYGON ((14 1, 15 8, 7 8, 7 1, 14 1))'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">);</span>
</pre>


<p>This is a polygon that will <em>intersect</em> with part of our previous polygon.
Let us ask PostGIS if these polygons really intersect each other:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Intersects</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span> <span class="n">a</span><span class="p">,</span> <span class="n">shapes</span> <span class="n">b</span> 
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Square with hole'</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'The intersecting one'</span><span class="p">;</span>
</pre>


<p>If all is well, this will simply return <em>TRUE</em> if they intersect and <em>FALSE</em> if they do not. In this case, it will return <em>TRUE</em>.</p>
<p>The counterpart of our intersect function is <em>ST_Disjoint()</em>:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Disjoint</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span> <span class="n">a</span><span class="p">,</span> <span class="n">shapes</span> <span class="n">b</span> 
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Square with hole'</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'The intersecting one'</span><span class="p">;</span>
</pre>


<p>Which will return <em>FALSE</em> in our case.</p>
<p>Let us now add a third polygon which does not intersect our previous two:</p>
<pre class="code literal-block"><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">shapes</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span>
    <span class="s1">'The solitary one'</span><span class="p">,</span>
    <span class="n">ST_GeomFromText</span><span class="p">(</span><span class="s1">'POLYGON ((20 20, 20 40, 1 40, 1 20 ,20 20))'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">);</span>
</pre>


<p>This polygon will reside well "above" the other two and does not share any space.
Let us now see how far this polygon resides from our first polygon, the one with the hole:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Distance</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span> <span class="n">a</span><span class="p">,</span> <span class="n">shapes</span> <span class="n">b</span> 
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Square with hole'</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'The solitary one'</span><span class="p">;</span>
</pre>


<p>This returns us the number "12", which means they are 12 units apart.
And remembering the definition of both shapes, the first shape is 8 units tall and the second shape starts at unit 20.
This indeed leaves a gap of 12.</p>
<p>Nice! We have just measured the distance between two objects in a spatial database!</p>
<p>Hmmm, this may mean we are getting closer to knowing the distance to Tokyo...but not yet, we need to play a bit more first.</p>
<p>PostGIS also has the ability to manipulate geometry. Let us, for example, try to move our solitary polygon even further away using the <em>ST_Translate()</em> function under the <em>Geometry Editors</em> category:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Translate</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span>
    <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'The solitary one'</span><span class="p">;</span>
</pre>


<p>The <em>ST_Translate()</em> function will accept the to-be-altered geometry and accepts an X, Y and an optional third dimension.</p>
<p>Running this query will give us a binary representation of a <em>new</em> piece of geometry. The original geometry is not altered.
So how can we actually move the geometry that resided in the database?</p>
<p>Simply by using SQL:</p>
<pre class="code literal-block"><span></span><span class="k">UPDATE</span> <span class="n">shapes</span>
    <span class="k">SET</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">ST_Translate</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'The solitary one'</span><span class="p">;</span>
</pre>


<p>Let us now check the new distance:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Distance</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span> <span class="n">a</span><span class="p">,</span> <span class="n">shapes</span> <span class="n">b</span> 
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Square with hole'</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'The solitary one'</span><span class="p">;</span>
</pre>


<p>And get back:</p>
<pre class="code literal-block"><span></span><span class="mi">22</span>
</pre>


<p>Aha! Nice! It has now moved ten units upwards.</p>
<p>Now let us alter the distance once again, but this time we will scale the polygon down:</p>
<pre class="code literal-block"><span></span><span class="k">UPDATE</span> <span class="n">shapes</span>
    <span class="k">SET</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">ST_Scale</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'The solitary one'</span><span class="p">;</span>
</pre>


<p>If we now check the distance, we will get back:</p>
<pre class="code literal-block"><span></span><span class="mi">7</span>
</pre>


<p>Wow, we have gone from 22 to 7, how did that happen?</p>
<p>Well, it is important to know that the <em>ST_Scale()</em> function currently only supports scaling by multiplying each coordinate. This means that the polygon will not only become smaller or bigger, but will also translate as a result. To know exactly how our new, scaled version of our polygon looks, we can use the <em>ST_Boundary()</em> function which shows us the outer most linestring:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_AsText</span><span class="p">(</span><span class="n">ST_Boundary</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">FROM</span> <span class="n">shapes</span>
    <span class="k">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">'The solitary one'</span><span class="p">;</span>
</pre>


<p>And we will get:</p>
<pre class="code literal-block"><span></span><span class="n">LINESTRING</span><span class="p">(</span><span class="mi">10</span> <span class="mi">15</span><span class="p">,</span><span class="mi">10</span> <span class="mi">25</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="mi">25</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="mi">15</span><span class="p">,</span><span class="mi">10</span> <span class="mi">15</span><span class="p">)</span>
</pre>


<p>If we compare that to the same result before scaling (which I handily made ready for you):</p>
<pre class="code literal-block"><span></span><span class="n">LINESTRING</span><span class="p">(</span><span class="mi">20</span> <span class="mi">30</span><span class="p">,</span><span class="mi">20</span> <span class="mi">50</span><span class="p">,</span><span class="mi">1</span> <span class="mi">50</span><span class="p">,</span><span class="mi">1</span> <span class="mi">30</span><span class="p">,</span><span class="mi">20</span> <span class="mi">30</span><span class="p">)</span>
</pre>


<p>You can see that each value in each coordinate simply was divided by 2.
This also clarifies why our polygons are now only 7 units apart (first square stops at 8, the scaled square start at 15).</p>
<p>Okay, okay, I guess we have played enough now.
We have seen a small glimpse of the operations you can do on GIS data within PostGIS and seen that PostGIS makes all of this work fairly easy.</p>
<p>I guess we can now take it one step further and start to actually look at some geography!</p>
<h3>Fun with the earth</h3>
<p>Up until now we have been working with an SRID of <em>0</em>, which means <em>undefined</em>, inside a <em>geometry</em> column, meaning the data was of type "geometry".
Now we want to go out and explore the actual earth, which means we wish to continue in a <em>geographical coordinate system</em>.</p>
<p>This brings us at a crossroad of choices. First, you will need to ask yourself the same question we pondered in chapter one: you wish to work with geometry or geography?</p>
<p>On the one hand we know that geographical measurements are expensive calculations, but most accurate for they are unprojected.
On the other hand GIS convention tells us that in any case, we should continue in a geometrical or Cartesian system, simply because...well...it is a convention.</p>
<p>So what do we do?</p>
<p>It all depends on your specific use case.</p>
<p>When working on a "small" scale, say, part of North America, it would make sense to not use geography.
Instead, you could (and should) work in a geometrical system using a very accurate projection with SRID 4267 (datum <em>NAD27</em>) or SRID 4269 (datum <em>NAD83</em>) which are both local UTM variants for North America. </p>
<p>Depending on which region you work in, chances are high you have several local projections with their own datum and coordinate system, ready to use.
They are very accurate and less expensive to use then direct geography.</p>
<p>For us, however, we will be working on a large scale, for we want to measure a distance that covers much of the globe. You cannot use a local projection or local datum for that.</p>
<p>In such a case you, again, are presented with two options.
You could either neglect the convention and simply use geographical data and functions or be nice and adhere to what is agreed upon and work in a Cartesian system.</p>
<p>We will be doing both and we will use the common SRID <em>4326</em>.
This <em>very</em> popular SRID is by heart geographical, for it uses the geographical coordinate system, but can also be used with geometrical data. Confused?</p>
<p>Join the club.</p>
<p>Let me try to clarify.</p>
<p>First, the authority of this SRID is the EPSG and the EPSG ID is identical to the SRID.
It uses a popular <em>datum</em> (remember chapter one) called <em>WGS 84</em> and is referred to as <em>unprojected</em> for it is a geographical representation.
This datum is one that is used in GPS systems and is often referred to as a <em>word wide datum</em>.</p>
<p>When you store objects with an SRID of 4326, you are storing them using geographical coordinates aka latitude and longitude.
This in contrast to, for example, the former SRID's, like 4267 or 4269, which store their coordinates in UTM values.
When you do measurements between two objects carrying this SRID you have two options. You can either do a geographical or a geometrical measurement.</p>
<p>With a geographical measurement there will be no projection and the system will use the WSG 84 datum (the spheroid) to calculate the distance, in three dimensional space.
As we have seen before, such a calculation is more expensive and unconventional.</p>
<p>With a geometrical measurement, your geographical coordinates have to be <em>projected</em> on to a flat Cartesian or <em>geometrical</em> plane.
This is done automatically when you ask PostGIS to measure distance using one of the more common geometrical functions.
When projecting, all GIS systems will use the <em>Plate Carrée</em> projection which means they will use the stored latitude and longitude coordinates directly as an X and Y value.</p>
<p>Let us see this story in action. First we can take a look at the more native geography data. Let us clean our shape table first:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">DropGeometryColumn</span><span class="p">(</span><span class="s1">'shapes'</span><span class="p">,</span> <span class="s1">'shape'</span><span class="p">);</span>
</pre>


<p>Here we use the <em>DropGeometryColumn()</em> to remove this column from out "shapes" table. Now clear the table:</p>
<pre class="code literal-block"><span></span><span class="k">TRUNCATE</span> <span class="n">shapes</span><span class="p">;</span>
</pre>


<p>Next add a new geography column:</p>
<pre class="code literal-block"><span></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">shapes</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="k">location</span> <span class="n">geography</span><span class="p">(</span><span class="s1">'POINT'</span><span class="p">);</span>
</pre>


<p>We create a new <em>geography</em> column with the name <em>location</em> in our "shapes" table. We will only be storing Point types.</p>
<p>Notice that the syntax is different and that here we use plain SQL as opposed to the <em>AddGeometryColumn()</em> function from before.
Since PostGIS 2 it is possible to create and drop both geometry and geography columns with standard SQL syntax.</p>
<p>If you wish to rewrite our "shape" column addition from the beginning of this chapter, you could write it like this:</p>
<pre class="code literal-block"><span></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">shapes</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">shape</span> <span class="n">geometry</span><span class="p">(</span><span class="s1">'POLYGON'</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</pre>


<p>Looks more native and simple, no? Sorry to tell you this so late in the adventure, but now you know the existence of both the functions and the more native SQL syntax. Both will also keep the PostGIS bookkeeping in sync.</p>
<p>Also, for fun, you could do a describe on the table:</p>
<pre class="code literal-block"><span></span><span class="err">\</span><span class="n">d</span> <span class="n">shapes</span>
</pre>


<p>And get back:</p>
<pre class="code literal-block"><span></span> Column  <span class="p">|</span>         Type          <span class="p">|</span> Modifiers 
----------+-----------------------+-----------
name     <span class="p">|</span> character varying     <span class="p">|</span> 
location <span class="p">|</span> geography<span class="o">(</span>Point,4326<span class="o">)</span> <span class="p">|</span>
</pre>


<p>As you can see, the column is of type <em>geography</em> and automatically gets the famous SRID 4326.</p>
<p>Good, let us now try and find an answer to our famous question, How far is Tokyo from my current location. You will be surprised how trivial this will be.</p>
<p>First, as you might suspect, since we are only interested in a point on the earth and not the shape of your location nor Tokyo, we will suffice with a Point object.
Next we will need to insert two points into our database, your location and the center of Tokyo, both in geographical coordinates.</p>
<h4>Finding Your Location</h4>
<p>This means you need to find out your exact latitude and longitude of the place you are at right now.</p>
<p>This could, of course, be done in a myriad of ways: using your cell phone's GPS capabilities, using your dedicated GPS device or using an online map system.
I will choose the latter and will be using OpenStreetMap (what else?) to locate my current position.</p>
<p>Open up your favorite web browser and surf to <a href="http://openstreetmap.org">openstreetmap.org</a>.
Once there, punch in your address or use the "Where Am I" function. This would give you a point on the map and in the search bar on the left your latitude and longitude coordinate.
Take this coordinate and save is as point data into your fresh column:</p>
<pre class="code literal-block"><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">shapes</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'My location'</span><span class="p">,</span> <span class="n">ST_GeographyFromText</span><span class="p">(</span><span class="s1">'POINT(127.6791949 26.2124702)'</span><span class="p">));</span>
</pre>


<p>The point I am inserting reflects central Naha, the main city of the Okinawa prefecture. Not my current location, but it serves as an illustrative point.</p>
<p><em>Note</em> that PostGIS expects a longitude as X and latitude as Y. This is many times reversed as what you get back from other sources.</p>
<p>Now you can insert the location of Tokyo, which I conveniently looked up for you:</p>
<pre class="code literal-block"><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">shapes</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Tokyo'</span><span class="p">,</span> <span class="n">ST_GeographyFromText</span><span class="p">(</span><span class="s1">'POINT(139.7530053 35.6823815)'</span><span class="p">));</span>
</pre>


<p>Ah, nice! Okay, are you ready to finally, after all the rambling we went through, know the distance?
You already know the syntax, punch in the magic:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Distance</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="k">location</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="k">location</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span> <span class="n">a</span><span class="p">,</span> <span class="n">shapes</span> <span class="n">b</span> 
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'My location'</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Tokyo'</span><span class="p">;</span>
</pre>


<p>In the case you would live in the exact cartographic center of Naha, you will get back:</p>
<pre class="code literal-block"><span></span>   <span class="n">st_distance</span>    
<span class="c1">------------------</span>
 <span class="mi">1557506</span><span class="p">.</span><span class="mi">28103692</span>
</pre>


<p>Yeah! This, my lovely folk, is how far you are from Tokyo, at this very moment.</p>
<p>But what is this number you get back? </p>
<p>The result you see here is the distance returned in <em>Meters</em>, meaning, from the point I inserted as "My location", I am 1557506.28 Meters or <em>1557.50628 Kilometers</em> from Tokyo.</p>
<p>Very neat stuff, would you not say? PostgreSQL just told us how far we are from Tokyo, <em>awesome</em>!</p>
<p>But wait, we are not finished yet. We have now done the most accurate, real geographical distance measurement using expensive geographical calculations.</p>
<p>There is an "in-between" solution before we jump to geometry. PostGIS gives us the ability to replace our spheroid datum with the more classical sphere.
The latter has much simpler calculations, but can still return more accurate results them some of the projections.</p>
<p>To redo our calculation from above with a sphere, simply set the spheroid Boolean, a third and optional parameter to the <em>ST_Distance()</em> function, to <em>False</em>:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Distance</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="k">location</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="k">location</span><span class="p">,</span> <span class="k">False</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span> <span class="n">a</span><span class="p">,</span> <span class="n">shapes</span> <span class="n">b</span> 
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'My location'</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Tokyo'</span><span class="p">;</span>
</pre>


<p>The result:</p>
<pre class="code literal-block"><span></span>   <span class="n">st_distance</span>    
<span class="c1">------------------</span>
<span class="mi">1557886</span><span class="p">.</span><span class="mi">68227339</span>
</pre>


<p>Which is a total distance of <em>1557.886 Kilometers</em>, a difference of around 300 Meters.</p>
<p>Let us now repeat this story, but use <em>geometry</em> instead. Let us do it the GIS conventional way.</p>
<p>We do not need to recreate our column as a geometry column and insert our data again. We could cheat a little.
PostGIS together with PostgreSQL has the unique capability of <em>casting</em> data from one type to another.
So without recreating anything, we could simply cast our geography data into geometry <em>on the fly</em> and see what happens.</p>
<p><em>Note</em> that casting, while very convenient for quick checks, can render an index totally mute.
It is therefor important to think ahead and decide if you want to work with geometry or geography, then create the correct column type and use this <em>without</em> casting.</p>
<p>But for our quick and dirty queries, this is fine. Let us continue:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Distance</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="k">location</span><span class="p">::</span><span class="n">geometry</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="k">location</span><span class="p">::</span><span class="n">geometry</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span> <span class="n">a</span><span class="p">,</span> <span class="n">shapes</span> <span class="n">b</span> 
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'My location'</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Tokyo'</span><span class="p">;</span>
</pre>


<p>In this query, we cast (<em>::</em>) the geography data inside the "location" columns into geometry.
Now we get back:</p>
<pre class="code literal-block"><span></span>   <span class="n">st_distance</span>    
<span class="c1">------------------</span>
<span class="mi">15</span><span class="p">.</span><span class="mi">3445794209231</span>
</pre>


<p>Hmm, that is a different result all together. It looks like a much smaller number then before. What is happening?</p>
<p>We just casted our geography to geometry, this means PostGIS will now use a Cartesian system or <em>projection</em> to calculate the distance in a linear way.
When using the distance measuring function <em>ST_Distance()</em> on geometry, it will return not meters but the distance expressed in the units the original data was stored in.
Since our data is stored with SRID 4326, its units are latitude and longitude. The value you get back is thus <em>degrees</em>.</p>
<p>In the case of the Naha location, this will be <em>15.344</em> degrees from Tokyo.</p>
<p>For our human brain this is difficult to imagine, a result in Meters is much more easy to comprehend. So, let us transform this degree value into a metric value.</p>
<p>It is an estimation that one planar degree (in our Cartesian system) equals 111 KM. So the distance now becomes 15.344 degrees times 111: <em>1703 Kilometers</em>.
That is a difference of about 145 Kilometers. </p>
<p>The reason this difference exist is of the projection we are now using. As we have mentioned a few times before, when going from data containing SRID 4326, PostGIS will automatically use the infamous <em>Plate Carrée</em> projection. This projection, as we have seen before, is the <em>least</em> accurate for something like distance measuring.</p>
<p>So let us poke this projection mechanism and try a different, more accurate one, the Lambert, which carries SRID <em>3587</em>.</p>
<p>To change the projection PostGIS will use, we can use the <em>ST_Transform()</em> function which casts objects to different SRIDs.
Note that <em>ST_Transform()</em> only works for geometry objects, so we have to continue to cast our geography location to be able to use them in this function.</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Distance</span><span class="p">(</span><span class="n">ST_Transform</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="k">location</span><span class="p">::</span><span class="n">geometry</span><span class="p">,</span> <span class="mi">3587</span><span class="p">),</span> <span class="n">ST_Transform</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="k">location</span><span class="p">::</span><span class="n">geometry</span><span class="p">,</span> <span class="mi">3587</span><span class="p">))</span>
    <span class="k">FROM</span> <span class="n">shapes</span> <span class="n">a</span><span class="p">,</span> <span class="n">shapes</span> <span class="n">b</span> 
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'My location'</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Tokyo'</span><span class="p">;</span>
</pre>


<p>This will gives us:</p>
<pre class="code literal-block"><span></span>   <span class="n">st_distance</span>    
<span class="c1">------------------</span>
<span class="mi">1602392</span><span class="p">.</span><span class="mi">18109279</span>
</pre>


<p>Meaning <em>1602.392 Kilometers</em>, a difference of about 45 Kilometers. That is indeed in between the Plate Carrée and our native geographical measurement.</p>
<p>Another, even more accurate and popular projection is our famous UTM. It can, however, not be used on a world scale. You can only perform measurements within the same UTM zone.</p>
<p>As mentioned in the previous chapter, there are roughly 60 World UTM zones on the earth, but each zone uses their own projection and their own coordinates.
This kind of projection is thus not fit for measuring distance on such a large scale.</p>
<p>Let us therefor take this one step further before I leave you to rest. Let us do a measurement with such a UTM projection.
We will make a measurement inside of Japan's mainland UTM zone: <em>54N</em> which has an SRID of <em>3095</em>.</p>
<p>First we will have to make another point in our database:</p>
<pre class="code literal-block"><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">shapes</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Aomori'</span><span class="p">,</span> <span class="n">ST_GeographyFromText</span><span class="p">(</span><span class="s1">'POINT(140.750616 40.788079)'</span><span class="p">));</span>
</pre>


<p>This point represents the city of Aomori in northern Japan, famous for its huge lantern parades.</p>
<p>First let us measure with the native geographical calculations:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Distance</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="k">location</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="k">location</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span> <span class="n">a</span><span class="p">,</span> <span class="n">shapes</span> <span class="n">b</span> 
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Aomori'</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Tokyo'</span><span class="p">;</span>
</pre>


<p>This returns:</p>
<pre class="code literal-block"><span></span><span class="n">st_distance</span>    
<span class="c1">------------------</span>
<span class="mi">573416</span><span class="p">.</span><span class="mi">203868172</span>
</pre>


<p>Or <em>573.416 Kilometers</em>, which is most accurate.</p>
<p>Next, let us throw the good old <em>Plate Carrée</em> projection at it:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Distance</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="k">location</span><span class="p">::</span><span class="n">geometry</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="k">location</span><span class="p">::</span><span class="n">geometry</span><span class="p">)</span>
    <span class="k">FROM</span> <span class="n">shapes</span> <span class="n">a</span><span class="p">,</span> <span class="n">shapes</span> <span class="n">b</span> 
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Aomori'</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Tokyo'</span><span class="p">;</span>
</pre>


<p>This will yield</p>
<pre class="code literal-block"><span></span>    <span class="n">st_distance</span>    
<span class="c1">------------------</span>
<span class="mi">5</span><span class="p">.</span><span class="mi">20224702126502</span>
</pre>


<p>Which is in degrees again, doing this times 111 Kilometers will yield a total distance of <em>577.444 Kilometers</em>. </p>
<p>Then let us measure using the correct UTM projection:</p>
<pre class="code literal-block"><span></span><span class="k">SELECT</span> <span class="n">ST_Distance</span><span class="p">(</span><span class="n">ST_Transform</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="k">location</span><span class="p">::</span><span class="n">geometry</span><span class="p">,</span> <span class="mi">3095</span><span class="p">),</span> <span class="n">ST_Transform</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="k">location</span><span class="p">::</span><span class="n">geometry</span><span class="p">,</span> <span class="mi">3095</span><span class="p">))</span>
    <span class="k">FROM</span> <span class="n">shapes</span> <span class="n">a</span><span class="p">,</span> <span class="n">shapes</span> <span class="n">b</span> 
    <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Aomori'</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Tokyo'</span><span class="p">;</span>
</pre>


<p>This will give us:</p>
<pre class="code literal-block"><span></span>  <span class="n">st_distance</span>    
<span class="c1">------------------</span>
<span class="mi">573228</span><span class="p">.</span><span class="mi">002047378</span>
</pre>


<p>Or <em>573.228 Kilometers</em> and thus only around 200  meters different, in contrast with the Plate Carrée, which was 4 Kilometers different.</p>
<p>You can see that different projections will result in different measurements. It is therefor crucial to know which one to choose.
Some are better used on a local scale, like we just did for Japan, others are better on a global scale.</p>
<p>Again, it all comes down to trade-offs and choices.</p>
<p>Okay, yet another big chunk of PostGIS goodness is taken. I suggest a good rest of the mind.</p>
<p>We have seen how we can insert various types of geometry and geography, we saw how to manipulate and question them and we looked at a few real world measurements.</p>
<p>In the next and final chapter, we will be looking at loading some real GIS data from OpenStreetMap into our PostGIS database, take a quick look around my town here in Okinawa and take a deeper look at creating some important indexes.</p>
<p>And as always...thanks for reading!</p>
<!--  LocalWords:  PostGIS PostgreSQL GIS
 -->
</div>
 </div>
</div></body></html>
