<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>shisaa.jp (Posts about full text search)</title><link>http://shisaa.jp/</link><description></description><atom:link href="http://shisaa.jp/categories/full-text-search.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><copyright>Contents Â© 2017 &lt;a href="mailto:tim@shisaa.jp"&gt;Tim van der Linden&lt;/a&gt; </copyright><lastBuildDate>Sat, 17 Jun 2017 07:08:38 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>PostgreSQL: A full text search engine - Part 3</title><link>http://shisaa.jp/postset/postgresql-full-text-search-part-3.html</link><dc:creator>Tim van der Linden</dc:creator><description>&lt;div&gt;&lt;p&gt;And so we arrive at the last part of the series.&lt;/p&gt;
&lt;p&gt;If you have not done so, please read &lt;a href="http://shisaa.jp/postset/postgresql-full-text-search-part-1.html" title="First chapter introducing the full text search capabilities of PostgreSQL."&gt;part one&lt;/a&gt; and &lt;a href="http://shisaa.jp/postset/postgresql-full-text-search-part-2.html" title="Second chapter introducing the full text search capabilities of PostgreSQL."&gt;part two&lt;/a&gt; before embarking.&lt;/p&gt;
&lt;p&gt;Today we will close up the introduction into PostgreSQL's full text capabilities by showing you a few aspects I have intentionally neglected in the previous parts. The most important ones being ranking and indexing.&lt;/p&gt;
&lt;p&gt;So let us take off right away!&lt;/p&gt;
&lt;h3&gt;Ranking&lt;/h3&gt;
&lt;p&gt;Up until now you have seen what full text is, how to use it and how to do a full custom setup. What you have not yet seen is how to &lt;em&gt;rank&lt;/em&gt; search results based on their relevance to the search query - a feature that most search engines offer and one that most users expect.&lt;/p&gt;
&lt;p&gt;However, there is a problem when it comes to ranking, it something that is somewhat &lt;em&gt;undefined&lt;/em&gt;. It is a gray area left wide open to interpretation. It is almost...personal.&lt;/p&gt;
&lt;p&gt;In its core, ranking within full text means giving a document a place based on how many times certain words occur in a document, or how close these words are relevant to each other. So let us start there.&lt;/p&gt;
&lt;h4&gt;Normal ranking&lt;/h4&gt;
&lt;p&gt;The first case, ranking based on how many times certain words occur, has a accompanying function ready to be used: &lt;em&gt;ts_rank()&lt;/em&gt;. It accepts a mandatory &lt;em&gt;tsvector&lt;/em&gt; and a &lt;em&gt;tsquery&lt;/em&gt; as its arguments and returns a float which represents how high the given document ranks. The function also accepts a &lt;em&gt;weights array&lt;/em&gt; and &lt;em&gt;normalization integer&lt;/em&gt;, but that is for later down the road.&lt;/p&gt;
&lt;p&gt;Let us test out the basic functionality:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Elephants and dolphins do not live in the same habitat.'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
               &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'elephants'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This is an regular old 'on the fly' query where we feed a string which we convert to a tsvector and a &lt;em&gt;token&lt;/em&gt; which is converted to a tsquery. The ranking result of this is:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.0607927
&lt;/pre&gt;


&lt;p&gt;This does not say much, does it? Okay, let us throw a few more tokens in the mix:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Elephants and dolphins do not live in the same habitat.'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
               &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'elephants &amp;amp; dolphins'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now we want to query the two tokens &lt;em&gt;elephants&lt;/em&gt; and &lt;em&gt;dolphins&lt;/em&gt;. We chain them together in an AND (&lt;em&gt;&amp;amp;&lt;/em&gt;) formation. The ranking:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.0985009
&lt;/pre&gt;


&lt;p&gt;Hmm, getting higher, good. More tokens please:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Elephants and dolphins do not live in the same habitat.'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
               &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'elephants &amp;amp; dolphins &amp;amp; habitat &amp;amp; living'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Results in:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.414037
&lt;/pre&gt;


&lt;p&gt;Oooh, that is quite nice. Notice the word &lt;em&gt;living&lt;/em&gt;, the &lt;em&gt;tsquery&lt;/em&gt; automatically stems it to match &lt;em&gt;live&lt;/em&gt;, but that is, of course, all basic knowledge by now.&lt;/p&gt;
&lt;p&gt;The idea here is simple, the more tokens match the string, the higher the ranking will be. You can use this float to later on sort your results.&lt;/p&gt;
&lt;h4&gt;Normal ranking with weights&lt;/h4&gt;
&lt;p&gt;Okay, let us spice things up a little bit, let us look at the &lt;em&gt;weights array&lt;/em&gt; that could be set as an optional parameter.&lt;/p&gt;
&lt;p&gt;Do you remember the weights we saw in chapter one? A quick rundown: You can optionally give weights to lexemes in a tsvector to group them together. This is, most of the time, used to reflect the original document structure within a tsvector. We also saw that, actually, all lexemes contain a standard weight of '&lt;em&gt;D&lt;/em&gt;' unless specified otherwise.&lt;/p&gt;
&lt;p&gt;Weights, when ranking, define importance of words. The &lt;em&gt;ts_rank()&lt;/em&gt; function will automatically take these weights into account and use a &lt;em&gt;weights array&lt;/em&gt; to influence the ranking float. Remember that there are only four possible weights: &lt;em&gt;A&lt;/em&gt;, &lt;em&gt;B&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;D&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;The weights array has a default value of:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.1, &lt;span class="m"&gt;0&lt;/span&gt;.2, &lt;span class="m"&gt;0&lt;/span&gt;.4, &lt;span class="m"&gt;1&lt;/span&gt;.0&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;These values correspond to the weight letters you can assign. Note that these are in reverse order, the array represents: {D,C,B,A}.&lt;/p&gt;
&lt;p&gt;Let us test that out. We take the same query as before, but now using the &lt;em&gt;setweight()&lt;/em&gt; function, we will apply a weight of &lt;em&gt;C&lt;/em&gt; to all lexemes:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;setweight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Elephants and dolphins do not live in the same habitat.'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="s1"&gt;'C'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
               &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'elephants &amp;amp; dolphins &amp;amp; habitat &amp;amp; live'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.674972
&lt;/pre&gt;


&lt;p&gt;Wow, that is a lot higher then our last ranking (which had an implicit, default weight of &lt;em&gt;D&lt;/em&gt;).
The reason for this is that the floats in the weights array &lt;em&gt;influence&lt;/em&gt; the ranking calculation.
Just for fun, you can override the default weights array, simply by passing it in as a first argument.
Let us put the weights all equal to the default of &lt;em&gt;D&lt;/em&gt; being &lt;em&gt;0.1&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
               &lt;span class="n"&gt;setweight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Elephants and dolphins do not live in the same habitat.'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="s1"&gt;'C'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
               &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'elephants &amp;amp; dolphins &amp;amp; habitat &amp;amp; live'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.414037
&lt;/pre&gt;


&lt;p&gt;You can see that this is now back to the value we had before we assigned weights, or in other words, when the implicit weight was &lt;em&gt;D&lt;/em&gt;. You can thus influence what kind of an effect a certain weight has in you ranking. You can even reverse the lot and make a D have a more positive influence then an A, just to mess with peoples heads.&lt;/p&gt;
&lt;h4&gt;Normal ranking, the fair way&lt;/h4&gt;
&lt;p&gt;Not that what we have seen up until now was unfair, but is does not take into account the length of the documents searched through&lt;/p&gt;
&lt;p&gt;Document length is also an important factor when judging the relevance. A short document which matches on four or five tokens has a different relevance than a three times as long document which matches on the same amount of tokens. The shorter one is probably more relevant then the longer one.&lt;/p&gt;
&lt;p&gt;The same ranking function &lt;em&gt;ts_rank()&lt;/em&gt; has an extra, final optional parameter that you can pass in called the &lt;em&gt;normalization integer&lt;/em&gt;. This integer can have a combination of seven different values, they can be a single integer or mixed with a pipe (|) to pass in multiple values.&lt;/p&gt;
&lt;p&gt;The default value is &lt;em&gt;0&lt;/em&gt; - meaning that it will ignore document length all together, giving us the more "unfair" behavior. The next values you can give are &lt;em&gt;1&lt;/em&gt;, &lt;em&gt;2&lt;/em&gt;, &lt;em&gt;4&lt;/em&gt;, &lt;em&gt;8&lt;/em&gt;, &lt;em&gt;16&lt;/em&gt; and &lt;em&gt;32&lt;/em&gt; which stand for the following manipulations of the ranking float:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1: It will divide the ranking float by the sum of 1 and the logarithmic number of the document length. The latter number is the ratio this document has compared to the other documents you wish to compare.&lt;/li&gt;
&lt;li&gt;2: Simply divides the ranking float by the length of the document.&lt;/li&gt;
&lt;li&gt;4: Divides the ranking float by the harmonic mean (the fair average) between matched tokens. This one is only uses by the other ranking function &lt;em&gt;ts_rank_cd&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;8: Divides the ranking float by the number of &lt;em&gt;unique&lt;/em&gt; words that are found in the document. &lt;/li&gt;
&lt;li&gt;16: Divides the ranking float by the sum of 1 and the logarithmic number of the number of &lt;em&gt;unique&lt;/em&gt; words found in the document.&lt;/li&gt;
&lt;li&gt;32: Simply divides the ranking float by &lt;em&gt;itself&lt;/em&gt; and adds one to that.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are a lot of values and some of them are quite confusing. But all of these have only one purpose: to make ranking more "fair", based on various use cases.&lt;/p&gt;
&lt;p&gt;Take, for example, &lt;em&gt;1&lt;/em&gt; and &lt;em&gt;2&lt;/em&gt;. These calculate document length by taking into account the amount of &lt;em&gt;words&lt;/em&gt; present in the document.
The &lt;em&gt;words&lt;/em&gt; here reference the amount of &lt;em&gt;pointers&lt;/em&gt; that are present in the tsvector.&lt;/p&gt;
&lt;p&gt;To illustrate, we will convert the sentence "These token are repeating on purpose. Bad tokens!" into a tsvector, resulting in:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'bad'&lt;/span&gt;:7 &lt;span class="s1"&gt;'purpos'&lt;/span&gt;:6 &lt;span class="s1"&gt;'repeat'&lt;/span&gt;:4 &lt;span class="s1"&gt;'token'&lt;/span&gt;:2,8
&lt;/pre&gt;


&lt;p&gt;The &lt;em&gt;length&lt;/em&gt; of this document is &lt;em&gt;5&lt;/em&gt;, because we have &lt;em&gt;five pointers&lt;/em&gt; in total.&lt;/p&gt;
&lt;p&gt;If you now look at the integers &lt;em&gt;8&lt;/em&gt; and &lt;em&gt;16&lt;/em&gt;, they take the &lt;em&gt;uniqueness&lt;/em&gt; to calculate document length.
What that means is they do not count the pointers, but the actual &lt;em&gt;lexemes&lt;/em&gt;.
In the above tsvector and thus would result in a length of &lt;em&gt;4&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;All of these manipulations are just different ways of counting document length.
The ones summed up in the above integer list are mere educated guesses at what most people desire when ranking with a full text engine.
As I said in the beginning, it is a gray area, left open for interpretation.&lt;/p&gt;
&lt;p&gt;Let us try to see the different effects that such an integer can have.&lt;/p&gt;
&lt;p&gt;First we need to create a few documents (tsvectors) inside our famous phraseTable (from the previous chapters) that we will use throughout this chapter.
Connect to your phrase database, add a "title" column, truncate whatever we have stored there and insert a few variable length documents based on Edgar Allan Poe's "The Raven".
I have prepared the whole syntax below, this time you may copy-and-paste:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="k"&gt;COLUMN&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt; &lt;span class="nb"&gt;VARCHAR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;TRUNCATE&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more."'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;'Tiny Allan'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more." Ah, distinctly I remember it was in the bleak December, And each separate dying ember wrought its ghost upon the floor. Eagerly I wished the morrow - vainly I had sought to borrow From my books surcease of sorrow - sorrow for the lost Lenore - For the rare and radiant maiden whom the angels name Lenore - Nameless here for evermore.'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;'Small Allan'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more." Ah, distinctly I remember it was in the bleak December, And each separate dying ember wrought its ghost upon the floor. Eagerly I wished the morrow - vainly I had sought to borrow From my books surcease of sorrow - sorrow for the lost Lenore - For the rare and radiant maiden whom the angels name Lenore - Nameless here for evermore. And the silken sad uncertain rustling of each purple curtain Thrilled me - filled me with fantastic terrors never felt before; So that now, to still the beating of my heart, I stood repeating, "Tis some visitor entreating entrance at my chamber door - Some late visitor entreating entrance at my chamber door - This it is, and nothing more."'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;'Medium Allan'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more." Ah, distinctly I remember it was in the bleak December, And each separate dying ember wrought its ghost upon the floor. Eagerly I wished the morrow - vainly I had sought to borrow From my books surcease of sorrow - sorrow for the lost Lenore - For the rare and radiant maiden whom the angels name Lenore - Nameless here for evermore. And the silken sad uncertain rustling of each purple curtain Thrilled me - filled me with fantastic terrors never felt before; So that now, to still the beating of my heart, I stood repeating, "Tis some visitor entreating entrance at my chamber door - Some late visitor entreating entrance at my chamber door - This it is, and nothing more."  Presently my soul grew stronger; hesitating then no longer, "Sir," said I, "or Madam, truly your forgiveness I implore; But the fact is I was napping, and so gently you came rapping, And so faintly you came tapping, tapping at my chamber door, That I scarce was sure I heard you"- here I opened wide the door; - Darkness there, and nothing more.'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;'Big Allan'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Nothing better then some good old Edgar to demonstrate a full text search ranking. Here we have four different lengths of the same verse making for four documents of different lengths stored in our tsvector column. Now we would like to search through these documents and find the keywords &lt;em&gt;'door'&lt;/em&gt; and &lt;em&gt;'gently'&lt;/em&gt;, ranking them as we go.&lt;/p&gt;
&lt;p&gt;For later reference, let us first count how many times our keywords occur in the sentence:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tiny Allan: "door" 2, "gently" 1&lt;/li&gt;
&lt;li&gt;Small Allan: "door" 2, "gently" 1&lt;/li&gt;
&lt;li&gt;Medium Allan: "door" 4, "gently" 1&lt;/li&gt;
&lt;li&gt;Big Allan: "door" 6, "gently" 2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;First, let us simply rank the result with the default normalization of &lt;em&gt;0&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Before we go over the results, a little bit about this query for people who are not so familiar with this SQL syntax.
We do a simple &lt;em&gt;SELECT&lt;/em&gt; from a data set using &lt;em&gt;FROM&lt;/em&gt; filtering it with a &lt;em&gt;WHERE&lt;/em&gt; clause.
Going over it line by line:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We &lt;em&gt;SELECT&lt;/em&gt; on the &lt;em&gt;title&lt;/em&gt; column we just made and on a "on-the-fly" column we create for the result set named &lt;em&gt;rank&lt;/em&gt; which contains the result of the &lt;em&gt;ts_rank()&lt;/em&gt; function.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;In the &lt;em&gt;FROM&lt;/em&gt; clause you can put a series of statements that will deliver the data for the query. In this case we take our normal database &lt;em&gt;table&lt;/em&gt; and the result of the &lt;em&gt;to_tsquery()&lt;/em&gt; function which we name &lt;em&gt;keywords&lt;/em&gt; so we can use it throughout the query itself.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Here we filter the result set using the &lt;em&gt;WHERE&lt;/em&gt; clause and the &lt;em&gt;matching&lt;/em&gt; operator (@@). The @@ is a Boolean operator, meaning it will simply return &lt;em&gt;true&lt;/em&gt; or &lt;em&gt;false&lt;/em&gt;.
So in this case, we check if the result of the &lt;em&gt;to_tsquery()&lt;/em&gt; function (named keywords and which will return lexemes) &lt;em&gt;match&lt;/em&gt; the results of the phrase &lt;em&gt;column&lt;/em&gt; from our table (which contains &lt;em&gt;tsvectors&lt;/em&gt; and thus lexemes). We want to rank only those phrases that actually contain our keywords.&lt;/p&gt;
&lt;p&gt;Now, back to our ranking. The result of this query will be:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;   title     &lt;span class="p"&gt;|&lt;/span&gt;   rank    
--------------+-----------
Tiny Allan   &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.0906565
Small Allan  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.0906565
Medium Allan &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.0906565
Big Allan    &lt;span class="p"&gt;|&lt;/span&gt;   &lt;span class="m"&gt;0&lt;/span&gt;.10109
&lt;/pre&gt;


&lt;p&gt;Let us order the results first, so the most relevant document is always on top:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt;
    &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt; &lt;span class="k"&gt;DESC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;   title     &lt;span class="p"&gt;|&lt;/span&gt;   rank    
--------------+-----------
Big Allan    &lt;span class="p"&gt;|&lt;/span&gt;   &lt;span class="m"&gt;0&lt;/span&gt;.10109
Tiny Allan   &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.0906565
Small Allan  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.0906565
Medium Allan &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.0906565
&lt;/pre&gt;


&lt;p&gt;"Big Allen" is on top, for it has more occurrences of the keywords "door" and "gently".
But to be fair, in ratio "Tiny Allan" has almost the same amount of occurrences of both keywords. Three times less, but it also is three times as small.&lt;/p&gt;
&lt;p&gt;So let us take document length (based on &lt;em&gt;word count&lt;/em&gt;) into account, setting our &lt;em&gt;normalization&lt;/em&gt; to &lt;em&gt;1&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt;
    &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt; &lt;span class="k"&gt;DESC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You will get:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;   title     &lt;span class="p"&gt;|&lt;/span&gt;   rank    
--------------+-----------
Tiny Allan   &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.0181313
Small Allan  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.0151094
Big Allan    &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.0145124
Medium Allan &lt;span class="p"&gt;|&lt;/span&gt;  &lt;span class="m"&gt;0&lt;/span&gt;.013831
&lt;/pre&gt;


&lt;p&gt;This could be seen as a more fair ranking, "Tiny Allan" is now on top because, considering its &lt;em&gt;ratio&lt;/em&gt;, it is the most relevant. "Medium Allan" falls all the way down because it is almost as big as "Big Allan", but contains lesser occurrences of the keywords. In total five keywords in contrast to "Big Allan" who has eight but is only slightly bigger.&lt;/p&gt;
&lt;p&gt;Let us do the same, but count the document length based on the &lt;em&gt;unique&lt;/em&gt; occurrences using integer &lt;em&gt;8&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt;
    &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt; &lt;span class="k"&gt;DESC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;Tiny Allan   &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.00335765
Small Allan  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.00161887
Medium Allan &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.00119285
Big Allan    &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.00105303
&lt;/pre&gt;


&lt;p&gt;That is a very different result, but quite what you should expect.&lt;/p&gt;
&lt;p&gt;We are searching for only &lt;em&gt;two&lt;/em&gt; tokens here, and considering the fact that uniqueness is now adhered, all the extra occurrences of these words are ignored.
This means that for the ranking algorithm, all the documents we searched through (which all have at least one occurrence of each token) get normalized to only &lt;em&gt;2&lt;/em&gt; matching tokens.
And in that case, the shortest document wins hands down, for it is seen as most relevant. As you can see in the result set, the documents are neatly ordered from tiny to big.&lt;/p&gt;
&lt;h4&gt;Ranking with density&lt;/h4&gt;
&lt;p&gt;Up until now we have seen the "normal" ranking function &lt;em&gt;ts_rank()&lt;/em&gt;, which is the one you will probably use the most.&lt;/p&gt;
&lt;p&gt;There is, however, one more function at our direct disposal called &lt;em&gt;ts_rank_cd()&lt;/em&gt;. The &lt;em&gt;cd&lt;/em&gt; stands for &lt;em&gt;Cover Density&lt;/em&gt; and is simply yet another way of considering relevance.
This function has exactly the same required and optional arguments, it simply counts relevancy differently.
Very important for this function to work properly is that you do not let it operate on a &lt;em&gt;stripped&lt;/em&gt; tsvector.&lt;/p&gt;
&lt;p&gt;A stripped tsvector is one that has been undone of its pointer information. If you know that you do not need this pointer information - you just need to match tsqueries against the lexemes in you tsvector - you can strip these pointers and thus make for smaller footprints in your database.&lt;/p&gt;
&lt;p&gt;In case of our cover density ranker, it needs this positional pointer information to see how &lt;em&gt;close&lt;/em&gt; the search tokens are to each other.
It makes sense that this ranking function only works on multiple tokens, on single tokens it is kind of pointless.&lt;/p&gt;
&lt;p&gt;In a way, this ranking function looks for &lt;em&gt;phrases&lt;/em&gt; rather then single tokens; the closer lexemes are together, the more positive influence they will have on the resulting ranking float.&lt;/p&gt;
&lt;p&gt;In our "Raven" examples this might be a little bit hard to see, so let me demonstrate this with a couple of new, on-the-fly queries.&lt;/p&gt;
&lt;p&gt;We wish to search for the tokens &lt;em&gt;'token'&lt;/em&gt; and &lt;em&gt;'count'&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;First, a sentence in which the searched for tokens are wide apart: "These tokens are very wide apart and therefor do not count as much.":&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'These tokens are very wide apart and do not count as much.'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'token &amp;amp; count'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt;
    &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt; &lt;span class="k"&gt;DESC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Will have this tsvector:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'apart'&lt;/span&gt;:6 &lt;span class="s1"&gt;'count'&lt;/span&gt;:10 &lt;span class="s1"&gt;'much'&lt;/span&gt;:12 &lt;span class="s1"&gt;'token'&lt;/span&gt;:2 &lt;span class="s1"&gt;'wide'&lt;/span&gt;:5
&lt;/pre&gt;


&lt;p&gt;And this result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;.008624
&lt;/pre&gt;


&lt;p&gt;Let us put these tokens closer together now: "These tokens count for much now that they are not so wide apart!":&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'These tokens count for much now that they are not so wide apart!'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'token &amp;amp; count'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt;
    &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt; &lt;span class="k"&gt;DESC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The vector:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'apart'&lt;/span&gt;:13 &lt;span class="s1"&gt;'count'&lt;/span&gt;:3 &lt;span class="s1"&gt;'much'&lt;/span&gt;:5 &lt;span class="s1"&gt;'token'&lt;/span&gt;:2 &lt;span class="s1"&gt;'wide'&lt;/span&gt;:12
&lt;/pre&gt;


&lt;p&gt;The result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.0198206
&lt;/pre&gt;


&lt;p&gt;You can see that both the vectors have &lt;em&gt;exactly&lt;/em&gt; the same lexemes, but different pointer information.
In the second vector, the tokens we searched for are next to each other, which results in a ranking float that is more then double of the first result.&lt;/p&gt;
&lt;p&gt;This demonstrates the working of this function. The same optional manipulations can be passed in (weights and normalization) and they will have roughly the same effect.&lt;/p&gt;
&lt;p&gt;Pick the ranking function that is best fit for your use case.&lt;/p&gt;
&lt;p&gt;It needs to be said that the two ranking functions we have seen so far are officially called &lt;em&gt;example functions&lt;/em&gt; by the PostgreSQL community.
They are functions devised to be fitting for most purposes, but also to demonstrate how you could write your own.&lt;/p&gt;
&lt;p&gt;If you have very specific use cases it is advised to write you own ranking functions to fit your exact needs.
But this is considered beyond the scope of this series (and maybe also beyond the scope of your needs).&lt;/p&gt;
&lt;h3&gt;Highlight your results!&lt;/h3&gt;
&lt;p&gt;The next interesting thing we can do with the results of our full text is to highlight the relevant words.&lt;/p&gt;
&lt;p&gt;As is the case with many search engines, users want to skim over an excerpt of each result to see if it is what they are searching for.
For this PostgreSQL delivers us yet another function: &lt;em&gt;ts_headline()&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To demonstrate its use, we first have to make our small database a little bit bigger by inserting the original text of the "Raven" next to our tsvectors.
So, again, copy and past this new set of queries (yes you may...):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;TRUNCATE&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;ADD&lt;/span&gt; &lt;span class="k"&gt;COLUMN&lt;/span&gt; &lt;span class="n"&gt;article&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more."'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;'Tiny Allan'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more."'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more." Ah, distinctly I remember it was in the bleak December, And each separate dying ember wrought its ghost upon the floor. Eagerly I wished the morrow - vainly I had sought to borrow From my books surcease of sorrow - sorrow for the lost Lenore - For the rare and radiant maiden whom the angels name Lenore - Nameless here for evermore.'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;'Small Allan'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more." Ah, distinctly I remember it was in the bleak December, And each separate dying ember wrought its ghost upon the floor. Eagerly I wished the morrow - vainly I had sought to borrow From my books surcease of sorrow - sorrow for the lost Lenore - For the rare and radiant maiden whom the angels name Lenore - Nameless here for evermore.'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more." Ah, distinctly I remember it was in the bleak December, And each separate dying ember wrought its ghost upon the floor. Eagerly I wished the morrow - vainly I had sought to borrow From my books surcease of sorrow - sorrow for the lost Lenore - For the rare and radiant maiden whom the angels name Lenore - Nameless here for evermore. And the silken sad uncertain rustling of each purple curtain Thrilled me - filled me with fantastic terrors never felt before; So that now, to still the beating of my heart, I stood repeating, "Tis some visitor entreating entrance at my chamber door - Some late visitor entreating entrance at my chamber door - This it is, and nothing more."'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;'Medium Allan'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more." Ah, distinctly I remember it was in the bleak December, And each separate dying ember wrought its ghost upon the floor. Eagerly I wished the morrow - vainly I had sought to borrow From my books surcease of sorrow - sorrow for the lost Lenore - For the rare and radiant maiden whom the angels name Lenore - Nameless here for evermore. And the silken sad uncertain rustling of each purple curtain Thrilled me - filled me with fantastic terrors never felt before; So that now, to still the beating of my heart, I stood repeating, "Tis some visitor entreating entrance at my chamber door - Some late visitor entreating entrance at my chamber door - This it is, and nothing more'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more." Ah, distinctly I remember it was in the bleak December, And each separate dying ember wrought its ghost upon the floor. Eagerly I wished the morrow - vainly I had sought to borrow From my books surcease of sorrow - sorrow for the lost Lenore - For the rare and radiant maiden whom the angels name Lenore - Nameless here for evermore. And the silken sad uncertain rustling of each purple curtain Thrilled me - filled me with fantastic terrors never felt before; So that now, to still the beating of my heart, I stood repeating, "Tis some visitor entreating entrance at my chamber door - Some late visitor entreating entrance at my chamber door - This it is, and nothing more."  Presently my soul grew stronger; hesitating then no longer, "Sir," said I, "or Madam, truly your forgiveness I implore; But the fact is I was napping, and so gently you came rapping, And so faintly you came tapping, tapping at my chamber door, That I scarce was sure I heard you"- here I opened wide the door; - Darkness there, and nothing more.'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;'Big Allan'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore, While I nodded, nearly napping, suddenly there came a tapping, As of some one gently rapping, rapping at my chamber door. "Tis some visitor," I muttered, "tapping at my chamber door - Only this, and nothing more." Ah, distinctly I remember it was in the bleak December, And each separate dying ember wrought its ghost upon the floor. Eagerly I wished the morrow - vainly I had sought to borrow From my books surcease of sorrow - sorrow for the lost Lenore - For the rare and radiant maiden whom the angels name Lenore - Nameless here for evermore. And the silken sad uncertain rustling of each purple curtain Thrilled me - filled me with fantastic terrors never felt before; So that now, to still the beating of my heart, I stood repeating, "Tis some visitor entreating entrance at my chamber door - Some late visitor entreating entrance at my chamber door - This it is, and nothing more."  Presently my soul grew stronger; hesitating then no longer, "Sir," said I, "or Madam, truly your forgiveness I implore; But the fact is I was napping, and so gently you came rapping, And so faintly you came tapping, tapping at my chamber door, That I scarce was sure I heard you"- here I opened wide the door; - Darkness there, and nothing more.'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Good, we now have the same data, but this time we stored the text of the original document alongside the "vectorized" version.&lt;/p&gt;
&lt;p&gt;The reason for this being that this &lt;em&gt;ts_headline()&lt;/em&gt; function searches in the original documents (being our &lt;em&gt;article&lt;/em&gt; column) rather that in your ts_vector column.
Two arguments are mandatory: the original article and the ts_query. The optional arguments are the full text configuration you wish to use and a string of additional, comma separated options.&lt;/p&gt;
&lt;p&gt;But first, let us take a look at its most basic usage:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_headline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="k"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Will give you:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;   title     |                                                      result                                                      
--------------+------------------------------------------------------------------------------------------------------------------
Tiny Allan   | &amp;lt;b&amp;gt;gently&amp;lt;/b&amp;gt; rapping, rapping at my chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt;. "Tis some visitor," I muttered, "tapping at my chamber
Small Allan  | &amp;lt;b&amp;gt;gently&amp;lt;/b&amp;gt; rapping, rapping at my chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt;. "Tis some visitor," I muttered, "tapping at my chamber
Medium Allan | &amp;lt;b&amp;gt;gently&amp;lt;/b&amp;gt; rapping, rapping at my chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt;. "Tis some visitor," I muttered, "tapping at my chamber
Big Allan    | &amp;lt;b&amp;gt;gently&amp;lt;/b&amp;gt; rapping, rapping at my chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt;. "Tis some visitor," I muttered, "tapping at my chamber
&lt;/pre&gt;


&lt;p&gt;As you can see, we get back a short excerpt of each verse with the tokens of interest surrounded with a HTML "&amp;lt;b&amp;gt;" tag.
That is actual all there is to this function, it return the results with the tokens highlighted.&lt;/p&gt;
&lt;p&gt;However, there are some nice options you can set to alter this basic behavior.&lt;/p&gt;
&lt;p&gt;The first one up is the HTML tag you wish to put around you highlighted words. For this you have two variables &lt;em&gt;StartSel&lt;/em&gt; and &lt;em&gt;StopSel&lt;/em&gt;.
If we wanted this to be a "&amp;lt;em&amp;gt;" tag instead, we could tell the function to change as follows:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_headline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'StartSel=&amp;lt;em&amp;gt;,StopSel=&amp;lt;/em&amp;gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="k"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And now we will get back an &amp;lt;em&amp;gt; instead of a &amp;lt;b&amp;gt; (including just one row this time):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;   title     |                                                        result                                                        
--------------+----------------------------------------------------------------------------------------------------------------------
Tiny Allan   | &amp;lt;em&amp;gt;gently&amp;lt;/em&amp;gt; rapping, rapping at my chamber &amp;lt;em&amp;gt;door&amp;lt;/em&amp;gt;. "Tis some visitor," I muttered, "tapping at my chamber
&lt;/pre&gt;


&lt;p&gt;In fact, it does not need to be HTML at all, you can put (almost) any string there:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_headline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'StartSel=foobar&amp;gt;&amp;gt;,StopSel=&amp;lt;&amp;lt;barfoo '&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="k"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;   title     |                                                               result                                                               
--------------+------------------------------------------------------------------------------------------------------------------------------------
Tiny Allan   | foobar&amp;gt;&amp;gt;gently&amp;lt;&amp;lt;barfoo rapping, rapping at my chamber foobar&amp;gt;&amp;gt;door&amp;lt;&amp;lt;barfoo. "Tis some visitor," I muttered, "tapping at my chamber
&lt;/pre&gt;


&lt;p&gt;Quite awesome!&lt;/p&gt;
&lt;p&gt;Another attribute you can tamper with is how many words should be included in the result set by using the &lt;em&gt;MaxWords&lt;/em&gt; and &lt;em&gt;MinWords&lt;/em&gt;: &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_headline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'MaxWords=4,MinWords=1'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="k"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Which gives you:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;   title     |             result             
--------------+--------------------------------
Tiny Allan   | &amp;lt;b&amp;gt;gently&amp;lt;/b&amp;gt; rapping, rapping
&lt;/pre&gt;


&lt;p&gt;To make the resulting headline a little bit more readable there is an attribute in this options string called &lt;em&gt;ShortWord&lt;/em&gt; which tells the function which is the shortest word that may appear at the start or end of the headline. &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_headline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'ShortWord=8'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="k"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Will give you:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;   title     |                                                                                   result                                                                                    
--------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Tiny Allan   | &amp;lt;b&amp;gt;gently&amp;lt;/b&amp;gt; rapping, rapping at my chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt;. "Tis some visitor," I muttered, "tapping at my chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt; - Only this, and nothing more."
Small Allan  | &amp;lt;b&amp;gt;gently&amp;lt;/b&amp;gt; rapping, rapping at my chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt;. "Tis some visitor," I muttered, "tapping at my chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt; - Only this, and nothing more." Ah, distinctly
&lt;/pre&gt;


&lt;p&gt;Now it will try and set word boundaries to words of minimal 8 letters. This time I included the second line of the result set. As you can see the engine could not find an 8 letter word at the remainder of the document, so it simply prints it until the end. The second row, "Small Allan" is a bit bigger and the word "distinctly" has more then 8 letters, so is set as the boundary,&lt;/p&gt;
&lt;p&gt;So far the headline function has given us almost full sentences and not really fragments of text. This is because the optional &lt;em&gt;MaxFragments&lt;/em&gt; defaults to 0. If we up this variable, it will start to include fragments and not sentences. Let us try it out:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_headline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'MaxFragments=2,MaxWords=8,MinWords=1'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="k"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Gives you&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;   title     |                                                     result                                                      
--------------+-----------------------------------------------------------------------------------------------------------------
Tiny Allan   | &amp;lt;b&amp;gt;gently&amp;lt;/b&amp;gt; rapping, rapping at my chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt;
...
Big Allan    | &amp;lt;b&amp;gt;gently&amp;lt;/b&amp;gt; rapping, rapping at my chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt; ... chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt; - This it is, and nothing more
&lt;/pre&gt;


&lt;p&gt;I include only the first and last line of this result set. As you can see on the last line, the result is now fragmented, and we get back different pieces of our result.
If, for instance, four or five tokens match in our document, setting the &lt;em&gt;MaxFragments&lt;/em&gt; to a higher value will show more of these matches glued together.&lt;/p&gt;
&lt;p&gt;Accompanying this &lt;em&gt;MaxFragments&lt;/em&gt; option is the &lt;em&gt;FragmentDelimiter&lt;/em&gt; variable which is used to define, well, the delimiter between the fragments. Short demo:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_headline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'MaxFragments=2,FragmentDelimiter=;,MaxWords=8,MinWords=1'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="k"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You will get:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;   title     |                                                   result                                                    
--------------+-------------------------------------------------------------------------------------------------------------
Big Allan    | &amp;lt;b&amp;gt;gently&amp;lt;/b&amp;gt; rapping, rapping at my chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt;;chamber &amp;lt;b&amp;gt;door&amp;lt;/b&amp;gt; - This it is, and nothing more
&lt;/pre&gt;


&lt;p&gt;Including only the last line, you will see we now have a semicolon (;) instead of a ellipses (...). Neat.&lt;/p&gt;
&lt;p&gt;A final, less common option for the &lt;em&gt;ts_headline()&lt;/em&gt; function is to ignore all the word boundaries we set before and simply return the &lt;em&gt;whole&lt;/em&gt; document and highlight all the words of relevance.
This variable is called &lt;em&gt;HighlightAll&lt;/em&gt; and is a Boolean set to &lt;em&gt;false&lt;/em&gt; by default:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_headline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'HighlightAll=true'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="k"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
    &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The result would be too large to print here, but try it out. It will give you the whole text, but with the important tokens decorated with the element (or text) of choice.&lt;/p&gt;
&lt;h4&gt;A big word of &lt;em&gt;caution&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;It is very fun to play with highlighting your results, I will admit that. The only problem is, as you might have concluded yourself, this is a potential performance grinder.&lt;/p&gt;
&lt;p&gt;The problem here is that this function cannot use any indexes and it can also not use your stored tsvector. It &lt;em&gt;needs&lt;/em&gt; the original document text and it needs to not only parse the whole document text to a tsvector for matching, it also needs to parse the original document text a second time to find the substrings and &lt;em&gt;decorate&lt;/em&gt; them with the characters you have set. And this whole process has to happen &lt;em&gt;for every single record&lt;/em&gt; in your result set.&lt;/p&gt;
&lt;p&gt;Highlighting, with this function, is a &lt;em&gt;very&lt;/em&gt; expensive to do. &lt;/p&gt;
&lt;p&gt;This does not mean that you have to avoid this function, if so I would have told you from the start and skipped this whole part. No, it is there to be used. But use it in a correct way.&lt;/p&gt;
&lt;p&gt;A correct way often seen is to use the highlighting only on the top results you are interested in - the top results the user has on their screen at the moment.
This could be achieved in SQL with a so called &lt;em&gt;subquery&lt;/em&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_headline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="k"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;
    &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_rank&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;
          &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'door &amp;amp; gently'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
          &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;keywords&lt;/span&gt;
          &lt;span class="k"&gt;ORDER&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;
          &lt;span class="k"&gt;LIMIT&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="k"&gt;alias&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;For those unfamiliar, a &lt;em&gt;subquery&lt;/em&gt; is nothing more than a query within a query (queue Inception drums...sorry).&lt;/p&gt;
&lt;p&gt;You evaluate the inner query and use the result set of that to perform the outer query. You can achieve the same with two queries, but that would prove not to be as elegant.
When PostgreSQL sees a subquery, it can plan and execute more efficiently then with separate queries, many times giving you a better performance.&lt;/p&gt;
&lt;p&gt;The query you see above might look a bit frightening to beginning SQL folk, but simply see it as two separate ones and the beast becomes a tiny mouse.
Unless you are afraid of mice, let it become a...euhm...soft butterfly gliding on the wind instead.&lt;/p&gt;
&lt;p&gt;In the inner query we perform the actual matching and ranking as we have seen before. This inner query then only returns &lt;em&gt;two&lt;/em&gt; matching records, because of the &lt;em&gt;LIMIT&lt;/em&gt; clause.
The outer query takes those results and performs the expensive operation of highlighting.&lt;/p&gt;
&lt;h3&gt;Indexing&lt;/h3&gt;
&lt;p&gt;Back to a more serious matter, the act of &lt;em&gt;indexing&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;If you do not know what an index is, you have to brush up real fast, for indexing is quite important for the performance of your queries.
In a very simplistic view, an index is like a chapter listing in a book. You can quickly skim over the chapters to find the page you are looking for, instead of having to flip over every single page.&lt;/p&gt;
&lt;p&gt;You typically put indexes on tables which are consulted often and you build the index in a way that is in parallel with how you query them.&lt;/p&gt;
&lt;p&gt;As indexing is a whole topic, or rather, a whole profession of its own, I will not go too deeply into the matter.
But I will try to give you some basic knowledge on the subject.&lt;/p&gt;
&lt;p&gt;Note that I will go over this matter in lighting speed and thus have to greatly skim down on the amount of details.
A &lt;em&gt;very&lt;/em&gt; good place to learn about indexes is Markus Winand's &lt;a href="http://use-the-index-luke.com/" title="Use The Index, Luke series written by Markus Winand."&gt;Use The Index, Luke&lt;/a&gt; series.
I seriously suggest you read that stuff, it is golden knowledge for every serious developer working with databases.&lt;/p&gt;
&lt;h4&gt;B-tree&lt;/h4&gt;
&lt;p&gt;Before we can go to the PostgreSQL full text index types we first have to look at the most common index type, the &lt;em&gt;Balanced tree&lt;/em&gt; or &lt;em&gt;B-tree&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;B-tree&lt;/em&gt; is a proven "computer science" concept that give us a way to search certain types of data, fast.&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;B-tree&lt;/em&gt; is a tree structure with a root, nodes and leafs (inverse from a natural tree).
The data that is within your table rows will be ordered and chopped up to fit within the tree.&lt;/p&gt;
&lt;p&gt;It is called &lt;em&gt;Balanced&lt;/em&gt;, meaning that each level of the tree has the same amount of nodes.&lt;/p&gt;
&lt;p&gt;Take this picture for example:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="p"&gt;|&lt;/span&gt;root&lt;span class="p"&gt;|&lt;/span&gt;
              &lt;span class="p"&gt;|&lt;/span&gt;
       ----------------
       &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt;
    &lt;span class="p"&gt;|&lt;/span&gt;node&lt;span class="p"&gt;|&lt;/span&gt;          &lt;span class="p"&gt;|&lt;/span&gt;node&lt;span class="p"&gt;|&lt;/span&gt;
       &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt;
  ----------       --------- 
  &lt;span class="p"&gt;|&lt;/span&gt;        &lt;span class="p"&gt;|&lt;/span&gt;       &lt;span class="p"&gt;|&lt;/span&gt;       &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;node&lt;span class="p"&gt;|&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt;node&lt;span class="p"&gt;|&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt;node&lt;span class="p"&gt;|&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt;node&lt;span class="p"&gt;|&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;In &lt;em&gt;B-tree&lt;/em&gt; terms, we summarize this tree by saying:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It has an &lt;em&gt;order&lt;/em&gt; of 2, meaning that each node will contain two leaves only&lt;/li&gt;
&lt;li&gt;It has a &lt;em&gt;depth&lt;/em&gt; of 3, meaning it is three levels deep (including the root node)&lt;/li&gt;
&lt;li&gt;It has 4 &lt;em&gt;leaves&lt;/em&gt;, meaning that the amount of nodes that do not contain children is 4 (bottom row)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you set the &lt;em&gt;order&lt;/em&gt; of your tree to a higher number, more nodes can fit onto a single row and you will end up with a lesser &lt;em&gt;depth&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Now the actual power of an index comes from an I/O perspective. As you know (or will know now) the thing that will slow down a program/computer the most is I/O.
This can be network I/O, disk I/O, etc. In case of our database we will speak of disk I/O. &lt;/p&gt;
&lt;p&gt;When a database has to go and &lt;em&gt;scan&lt;/em&gt; your table without an index is has to plow through all your rows to find a match.
Database rows are almost always &lt;em&gt;not&lt;/em&gt; I/O optimized, this means that they do not fit well in the blocks of your physical disks structure.
This, in short, means that there is a lot of overhead in reading through that physical data,&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;B-tree&lt;/em&gt; on the other hand, is &lt;em&gt;very&lt;/em&gt; optimized for I/O. Each level of a &lt;em&gt;B-tree&lt;/em&gt; will try and fit perfectly within one physical block on your disk.
If all levels fit within one block each, walking over the tree will be very efficient and have almost no overhead.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;B-trees&lt;/em&gt; work with the most common data types such as TEXT, INT, VARCHAR, ... .&lt;/p&gt;
&lt;p&gt;But because full text search in PostgreSQL is its own "thing" (using the @@ operator), all knowledge that you may have learned about regarding indexes does not apply (or not in full anyway) to full text search.&lt;/p&gt;
&lt;p&gt;Full text search needs its own kind of indexing  for a &lt;em&gt;tsquery&lt;/em&gt; to be able to use them. 
And as we will see in a moment, indexing on full text in PostgreSQL is a dance of trade-offs.
When it comes to this matter we have two types of indexes available: &lt;em&gt;GiST&lt;/em&gt; and &lt;em&gt;GiN&lt;/em&gt; which are both closely related to the &lt;em&gt;B-tree&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;GiST&lt;/h4&gt;
&lt;p&gt;GiST stands for &lt;em&gt;Generalized Search Tree&lt;/em&gt; and can both be set on &lt;em&gt;tsvector&lt;/em&gt; and &lt;em&gt;tsquery&lt;/em&gt; column types, though most of the time you will use it on the former.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;GiST&lt;/em&gt; itself is not something that is unique to PostgreSQL, it is a project on its own and its concept is laid out in a C library called &lt;em&gt;libGist&lt;/em&gt;.
You could go ahead and play around with &lt;em&gt;libGiist&lt;/em&gt; to get a better understanding of how it works, it even comes shipped with some demo applications.&lt;/p&gt;
&lt;p&gt;Over time there have come many new types of trees based on the &lt;em&gt;B-tree&lt;/em&gt; concept, but most of them are limit in how they can match.
A &lt;em&gt;B-tree&lt;/em&gt; and its direct descendants can only use basic match operators like "&amp;lt;", "&amp;gt;", "=", etc.
A &lt;em&gt;GiST&lt;/em&gt; index, however, has more advanced matching capabilities like "intersect" and in case of PostgreSQL's implementation: the &lt;em&gt;"@@"&lt;/em&gt; operator.&lt;/p&gt;
&lt;p&gt;Another big advantage of the &lt;em&gt;GiST&lt;/em&gt; is the fact that it can store arbitrary data types and therefor can be used in a wide area of conduct.
The trade off for the wide data type support is the fact that &lt;em&gt;GiST&lt;/em&gt; will always return a &lt;em&gt;no&lt;/em&gt; if there is no match or a &lt;em&gt;maybe&lt;/em&gt; if there is.
There is no true &lt;em&gt;hit&lt;/em&gt; with this kind of index.&lt;/p&gt;
&lt;p&gt;Because of this behavior there is extra overhead in the case of full text search because PostgreSQL has to manually go and check all the &lt;em&gt;maybe&lt;/em&gt;'s that return and see if they are an actual match.&lt;/p&gt;
&lt;p&gt;The big advantages of &lt;em&gt;GiST&lt;/em&gt; are the fact that the index builds faster and the update of such an index is less expensive then the next index type we will see.&lt;/p&gt;
&lt;h4&gt;GiN&lt;/h4&gt;
&lt;p&gt;The second index candidate we have at our disposal is the &lt;em&gt;Generalized Inverted Index&lt;/em&gt; or &lt;em&gt;GiN&lt;/em&gt; in short.&lt;/p&gt;
&lt;p&gt;Same as we saw with &lt;em&gt;GiST&lt;/em&gt;, &lt;em&gt;GiN&lt;/em&gt; also allows for arbitrary data types to be indexes and allows for more matching operators to be used.
But as opposed to &lt;em&gt;GiST&lt;/em&gt;, a &lt;em&gt;GiN&lt;/em&gt; index is &lt;em&gt;deterministic&lt;/em&gt; - it will always return a true match, cutting the checking overhead needed with &lt;em&gt;GiST&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Well, unless you wish to use &lt;em&gt;weights&lt;/em&gt; in your queries. A &lt;em&gt;GiN&lt;/em&gt; index does &lt;em&gt;not&lt;/em&gt; store lexeme weights. This means that, if weights need to be taken into account when querying, PostgreSQL still has to go and fetch the actual row(s) that return a true match, giving you somewhat of the same overhead as with a &lt;em&gt;GiST&lt;/em&gt; index.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;GiN&lt;/em&gt; tries to improve the &lt;em&gt;B-tree&lt;/em&gt; concept by minimizing the amount of redundancy within nodes and there leaves.
When you search for a number between 0 and 1000, it can be that your index has to go over 5 levels to find the desired entry.
This means that the four levels above the matching leaf could potentially contain an (implied) reference to the row id you wish to have fetched.
In a &lt;em&gt;GiN&lt;/em&gt; index, this is generalized by storing a single entry of the duplicates into so-called &lt;em&gt;posting trees&lt;/em&gt; and &lt;em&gt;posting lists&lt;/em&gt; and pointing to those lists instead of drilling down multiple levels.&lt;/p&gt;
&lt;p&gt;The downside of &lt;em&gt;GiN&lt;/em&gt; is the fact that this kind of index will slow down the bigger it gets.&lt;/p&gt;
&lt;p&gt;On a more positive note, &lt;em&gt;GiN&lt;/em&gt; indexes are most of the time smaller on disk (because of it trying to reduce duplicates). And, as of PostgreSQL 9.4, they will be &lt;em&gt;even&lt;/em&gt; smaller.
The soon-to-be version will introduce a so-called &lt;em&gt;varbyte&lt;/em&gt; version of &lt;em&gt;GiN&lt;/em&gt;. For now just take it from me that it will make these type of indexes &lt;em&gt;much&lt;/em&gt; smaller, and even more efficient.&lt;/p&gt;
&lt;p&gt;As you can see, there is no perfect index when it comes to full text. You will have to carefully look at what data you will save and how you wish to query the data.&lt;/p&gt;
&lt;p&gt;If you do not update your database much but you have a lot of querying going on, &lt;em&gt;GiN&lt;/em&gt; might be a better option for it is much faster with a lookup (if no weights are required).
If your data does not get read much, but is updated frequently, maybe a &lt;em&gt;GiST&lt;/em&gt; is a better choice for it allows for faster updating.&lt;/p&gt;
&lt;h4&gt;Making an index&lt;/h4&gt;
&lt;p&gt;We have (very roughly) seen what an index is and what we have available for full text, but how do you actually build such an index?&lt;/p&gt;
&lt;p&gt;Luckily for us, this too has been neatly abstracted and is very simple to do.&lt;/p&gt;
&lt;p&gt;If we wanted our phraseTable to contain an index, we simply could go about and create it with the following syntax:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;phrasetable_idx&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;USING&lt;/span&gt; &lt;span class="n"&gt;gin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will create a &lt;em&gt;GiN&lt;/em&gt; index called &lt;em&gt;phrasetable_ixd&lt;/em&gt; on the column &lt;em&gt;phrase&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Just like we did before, we will now re-populate our &lt;em&gt;phrase&lt;/em&gt; column, but this time we will fill it with the data we want to have indexed: article and title.
Let me show you what I mean.&lt;/p&gt;
&lt;p&gt;First, empty the four &lt;em&gt;phrase&lt;/em&gt; columns in our tiny database:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;DROP&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;UPDATE&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Notice that I removed the &lt;em&gt;NOT NULL&lt;/em&gt; constraint.
Next we can populate it containing a tsvector of both the &lt;em&gt;title&lt;/em&gt; and the &lt;em&gt;article&lt;/em&gt; columns:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;UPDATE&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'english'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;coalesce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="s1"&gt;' '&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;coalesce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The &lt;em&gt;coalesce&lt;/em&gt; function may be something that you are unfamiliar with.
This functions simply returns the first argument which is &lt;em&gt;not&lt;/em&gt; NULL.
In this case we use:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;coalesce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Which means that if title would be NULL it will return the empty string &lt;em&gt;''&lt;/em&gt; which never is NULL.
We use &lt;em&gt;coalesce&lt;/em&gt; here to substitute a value for NULL, being the empty string.&lt;/p&gt;
&lt;p&gt;If we would not substitute NULL then our &lt;em&gt;tsvector&lt;/em&gt; generation would fail if either the title or article column would be NULL.&lt;/p&gt;
&lt;p&gt;Next we can create an index on that newly filled column:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;phrasetable_idx&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;USING&lt;/span&gt; &lt;span class="n"&gt;gin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we have magic, there now is a &lt;em&gt;GiN&lt;/em&gt; index on that column which will be used during full text search.&lt;/p&gt;
&lt;p&gt;To create a &lt;em&gt;GiST&lt;/em&gt; index we could use exactly the same syntax:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;phrasetable_idx&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;USING&lt;/span&gt; &lt;span class="n"&gt;gist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now, the disk-space savvy readers will have noticed that our "phrase" column now contains some redundant information as we store the tsvector of the article and title column that was already in the database.
If you do not wish to have this extra column, you could created &lt;em&gt;expression&lt;/em&gt; indexes (our on-the-fly queries we seen before).&lt;/p&gt;
&lt;p&gt;The setup of such an expression index is trivial:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;INDEX&lt;/span&gt; &lt;span class="n"&gt;phrasetable_exp_idx&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;USING&lt;/span&gt; &lt;span class="n"&gt;gin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'english'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;coalesce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="s1"&gt;' '&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;coalesce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Instead of having this extra tsvector column around, we now have created an on-the-fly index using the same syntax as we employed when we populated the &lt;em&gt;phrase&lt;/em&gt; column a few lines back.&lt;/p&gt;
&lt;p&gt;One important thing to note when you use &lt;em&gt;expression&lt;/em&gt; indexes is the text search configuration you used. Here we specify that we wish the index to be created using the 'english' configuration set.
This results in an index which is configuration aware and will &lt;em&gt;only&lt;/em&gt; work with a query which has the &lt;em&gt;same&lt;/em&gt; configuration set fed to the tsquery function (well, the same name anyway).&lt;/p&gt;
&lt;p&gt;You could omit the configuration which would then default to the one set in the "default_text_search_config" variable we saw in the last chapter. The problem you will have then is that the index is created using a configuration that &lt;em&gt;could&lt;/em&gt; be altered &lt;em&gt;after&lt;/em&gt; the index was created. If we later would query the database with the altered default, the index would be useless and will return inaccurate results. &lt;/p&gt;
&lt;p&gt;Also note that we may save on disk space when we use the &lt;em&gt;expression&lt;/em&gt; index, but we do not save on CPU. Now, instead of indexing data already parsed and ready in a column, the index has to compute the &lt;em&gt;to_tsvector&lt;/em&gt; on every index match. Again, a world of trade-offs.&lt;/p&gt;
&lt;h3&gt;Triggers&lt;/h3&gt;
&lt;p&gt;A final, small topic I want to briefly touch on before I let you go free are &lt;em&gt;update triggers&lt;/em&gt;. The way we have been populating our database so far does not need a trigger actually. Up until now we have been inserting records (or updating them) using the &lt;em&gt;ts_tsvector()&lt;/em&gt; function. The negative aspect of going about it the way we did is that it is extremely &lt;em&gt;redundant&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;If we inserted a piece of Raven text into a record, we specified it &lt;em&gt;twice&lt;/em&gt;, one time for the &lt;em&gt;article&lt;/em&gt; column and one time for the &lt;em&gt;phrase&lt;/em&gt; column which holds the tsvector result.&lt;/p&gt;
&lt;p&gt;A better way to do this is to not let the insert query care about the tsvector &lt;em&gt;at all&lt;/em&gt;. We simply insert the text we like and let the database do the converting  behind the curtains.&lt;/p&gt;
&lt;p&gt;This is where a &lt;em&gt;trigger&lt;/em&gt; comes in handy. Actually, PostgreSQL has a whole set of &lt;em&gt;trigger&lt;/em&gt; functions available that will fire when certain conditions are met, but when it comes to full text we have two functions at our disposal.&lt;/p&gt;
&lt;h4&gt;tsvector_update_trigger()&lt;/h4&gt;
&lt;p&gt;The first, and most used one, is called &lt;em&gt;tsvector_update_trigger()&lt;/em&gt; and fires whenever a new row is inserted into your table (in our case &lt;em&gt;phraseTable&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;To setup such a trigger, we could use the following SQL:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TRIGGER&lt;/span&gt; &lt;span class="n"&gt;tsvectorupdate&lt;/span&gt; &lt;span class="k"&gt;BEFORE&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;OR&lt;/span&gt; &lt;span class="k"&gt;UPDATE&lt;/span&gt;
    &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="k"&gt;EACH&lt;/span&gt; &lt;span class="k"&gt;ROW&lt;/span&gt; &lt;span class="k"&gt;EXECUTE&lt;/span&gt; &lt;span class="k"&gt;PROCEDURE&lt;/span&gt;
    &lt;span class="n"&gt;tsvector_update_trigger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'pg_catalog.english'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;That is all you need to setup such a trigger. Let us see what we just did.&lt;/p&gt;
&lt;p&gt;First, we have new syntax staring us in the face: &lt;em&gt;CREATE TRIGGER&lt;/em&gt;. This will create a trigger on certain &lt;em&gt;events&lt;/em&gt;. The events here are &lt;em&gt;BEFORE INSERT&lt;/em&gt; and &lt;em&gt;BEFORE UPDATE&lt;/em&gt; which are contracted to &lt;em&gt;BEFORE INSERT OR UPDATE&lt;/em&gt;. Then we specify on which &lt;em&gt;table&lt;/em&gt; this trigger has to act and for each &lt;em&gt;ROW&lt;/em&gt;. Then we say we want to &lt;em&gt;EXECUTE PROCEDURE&lt;/em&gt;, which, in our case, is the function &lt;em&gt;tsvector_update_trigger()&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The function itself needs a bit of explaining as well. This version takes three required arguments: the tsvector column name, the full text configuration name and the original text column name.
The latter can be multiple columns to concatenate them together. This concatenation is done with &lt;em&gt;coalesce&lt;/em&gt; under the hood, as we have seen before.&lt;/p&gt;
&lt;p&gt;In our case, we create a trigger that takes the &lt;em&gt;phrase&lt;/em&gt; tsvector column, the &lt;em&gt;english&lt;/em&gt; full text configuration and concatenates the text from both &lt;em&gt;title&lt;/em&gt; and &lt;em&gt;article&lt;/em&gt; to be normalized into lexemes.&lt;/p&gt;
&lt;p&gt;Note that instead of &lt;em&gt;english&lt;/em&gt; we say &lt;em&gt;pg_catalog.english&lt;/em&gt; when providing this function with the full text configuration.
In case of this function (and the next) we have to provide the schema-qualified path to the configuration.&lt;/p&gt;
&lt;h4&gt;tsvector_update_trigger_column()&lt;/h4&gt;
&lt;p&gt;The other of the two full text trigger functions we have is called &lt;em&gt;tsvector_update_trigger_column()&lt;/em&gt; and has only one difference to the former: the full text configuration used.
Here, the full text configuration can be read from a &lt;em&gt;column&lt;/em&gt; instead of given directly as a string.&lt;/p&gt;
&lt;p&gt;A possibility we have not seen in this series is one where you can have yet another column in your phraseTable where you store the name of the full text configuration you wish to use.
This way you can store multiple "languages" within the same table, specifying which configuration to use with each row.&lt;/p&gt;
&lt;p&gt;This trigger functions can take into account these per-row differing configurations and is able to read them from the specified column.&lt;/p&gt;
&lt;p&gt;But we have a trade-off once more. These two trigger functions, which are officially called &lt;em&gt;example functions&lt;/em&gt; again (remember our ranking functions?), do &lt;em&gt;not&lt;/em&gt; take into account weights.
If you have the need to store different weights in your tsvectors, you will have to write you own trigger function.&lt;/p&gt;
&lt;h3&gt;The end&lt;/h3&gt;
&lt;p&gt;Okay, I guess this covers the &lt;em&gt;basics&lt;/em&gt; of full text within PostgreSQL.&lt;/p&gt;
&lt;p&gt;We have covered the most important parts and touched some segments deeply, others just with a soft lovers glove.
As I always say at the end of such lengthy chapters: go out and explore.&lt;/p&gt;
&lt;p&gt;I have tried to give you a solid, full text knowledge base to build further adventures on. I highly encourage you to pack your elephant, take your new ship for a maiden voyage, set high the sails and if certain blue wales try to swim next to your vessel, simply let the mammoth take a good relief down the ship's head, and let those turds float together with our squeaky finned friends!&lt;/p&gt;
&lt;p&gt;And as always...thanks for reading!&lt;/p&gt;
&lt;!--  LocalWords:  PostgreSQL lexeme
 --&gt;&lt;/div&gt;</description><category>full text search</category><category>postgresql</category><guid>http://shisaa.jp/postset/postgresql-full-text-search-part-3.html</guid><pubDate>Wed, 14 May 2014 09:00:00 GMT</pubDate></item><item><title>PostgreSQL: A full text search engine - Part 2</title><link>http://shisaa.jp/postset/postgresql-full-text-search-part-2.html</link><dc:creator>Tim van der Linden</dc:creator><description>&lt;div&gt;&lt;p&gt;Welcome to the second installment of our look into full text search within PostgreSQL.&lt;/p&gt;
&lt;p&gt;If this is the first time you heard about full text search I highly encourage you to go and read &lt;a href="http://shisaa.jp/postset/postgresql-full-text-search-part-1.html" title="First chapter introducing the full text search capabilities of PostgreSQL."&gt;the first chapter&lt;/a&gt; in this series before continuing. This chapter builds on what we have seen previously.&lt;/p&gt;
&lt;h3&gt;A look back&lt;/h3&gt;
&lt;p&gt;In short, the previous chapter introduced the general concept of full text search, regardless of the software being used. It looked at how the idea of full text search was brought to computer software by breaking it up into roughly three steps: &lt;em&gt;case removal&lt;/em&gt;, &lt;em&gt;stop word removal&lt;/em&gt;, normalizing with &lt;em&gt;synonyms&lt;/em&gt; and &lt;em&gt;stemming&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;Next we delved into PostgreSQL's implementation and introduced the &lt;em&gt;tsvector&lt;/em&gt; and the &lt;em&gt;tsquery&lt;/em&gt; as two new data types together with a handful of new functions such as &lt;em&gt;to_tsvector()&lt;/em&gt;, &lt;em&gt;to_tsquery()&lt;/em&gt; and &lt;em&gt;plainto_tsquery()&lt;/em&gt;, which all extend PostgreSQL to support full text search. &lt;/p&gt;
&lt;p&gt;We saw how we could feed PostgreSQL a string of text which would then get &lt;em&gt;parsed&lt;/em&gt; into &lt;em&gt;tokens&lt;/em&gt; and processed even further into &lt;em&gt;lexemes&lt;/em&gt; which in turn got &lt;em&gt;stored&lt;/em&gt; into a &lt;em&gt;tsvector&lt;/em&gt;. We then queried that &lt;em&gt;tsvector&lt;/em&gt; using the &lt;em&gt;tsquery&lt;/em&gt; data type and the &lt;em&gt;@@&lt;/em&gt; matching operator.&lt;/p&gt;
&lt;p&gt;In this chapter, I want to flesh out an important topic we touched on in previously: PostgreSQL's full text search &lt;em&gt;configurations&lt;/em&gt;. &lt;/p&gt;
&lt;h3&gt;Precaution&lt;/h3&gt;
&lt;p&gt;Let me be very clear, in &lt;em&gt;most&lt;/em&gt; cases the configurations shipped with PostgreSQL will suffice and you do not need to touch them at all, in which case this chapter could be considered a waste of time.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;However&lt;/em&gt;, I highly encourage you to read through this chapter and, as always, actually &lt;em&gt;run the queries&lt;/em&gt; with me. You need to know how the tools you use work under the hood.&lt;/p&gt;
&lt;p&gt;To be even more bold, someday you might even need to get your hands dirty and actually &lt;em&gt;build&lt;/em&gt; your own configuration. Why? Because a customer wanting full text search for their application might have specific requirements, or even deliver you specific dictionaries to use in the parsing stage. Such use cases may arise in very specific areas of conduct where much official, technical lingo is used which is not covered in a general dictionary.&lt;/p&gt;
&lt;p&gt;So, put on your favorite pants (or none if you like that better), turn down the lights, pull the computer close to you, open up a terminal window, put on some eery music and let us get started.&lt;/p&gt;
&lt;h3&gt;Configuring PostgreSQL full text search&lt;/h3&gt;
&lt;p&gt;In the last chapter we saw that PostgreSQL uses a couple of tools like a &lt;em&gt;stop word list&lt;/em&gt; and &lt;em&gt;dictionaries&lt;/em&gt; to perform its parsing. We also saw that we did not need to tell PostgreSQL about which of these tools to use. It turned out that full text search comes with a set of default configurations for several languages. We also found out that, if no configuration was given, the database assumes that the document or string to be parsed is English and uses a configuration called &lt;em&gt;'english'&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;Beware of localized packages of PostgreSQL though. As I noted in the previous chapter, there is a small possibility that the default configuration in your PostgreSQL installation is &lt;em&gt;not&lt;/em&gt; set to 'english'.
If this is the case with your setup, be sure to include the 'english' configuration if not stated otherwise or &lt;em&gt;change&lt;/em&gt; it to be 'english'. We will see how to do that in a minute.&lt;/p&gt;
&lt;p&gt;Taking the small database we created last time, the syntax to feed a configuration set to PostgreSQL during parsing was the following:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'english'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'elephants &amp;amp; blue'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The string '&lt;em&gt;english&lt;/em&gt;' represents the &lt;em&gt;name&lt;/em&gt; of the configuration which we would like to use. As you know by now, this string can be omitted which will make the database use the default configuration. PostgreSQL knows this default because it is set in the general &lt;em&gt;postgresql.conf&lt;/em&gt; configuration file. In that file you will find a variable called &lt;em&gt;default_text_search_config&lt;/em&gt; which, in most cases, is set to &lt;em&gt;pg_catalog.english&lt;/em&gt;. If you wish to have a own, custom configuration to be the default, that is the place to set it.&lt;/p&gt;
&lt;p&gt;Before hacking away at your own configuration, it may be of interest to see what PostgreSQL has to offer. To see which shipped configuration files are available to you, use the &lt;em&gt;describe&lt;/em&gt; command (\d) together with the full text flag (F):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;dF&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will &lt;em&gt;describe&lt;/em&gt; the objects in the database that represent full text configurations. You see that by default you have quite a lot of language support. To see a different configuration in action, let us do a quick, fun test. &lt;/p&gt;
&lt;p&gt;First, take the dutch string "Een blauwe olifant springt al dartelend over de kreupele dolfijn.", which is a rough translation of the "The blue elephant jumps over the crippled dolphin." example from the first chapter. If we would feed this to PostgreSQL, using the default (english) configuration:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'english'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Een blauwe olifant springt al dartelend over de kreupele dolfijn'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We would get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="s1"&gt;'al'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="s1"&gt;'blauw'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="s1"&gt;'dartelend'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="s1"&gt;'de'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="s1"&gt;'dolfijn'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="s1"&gt;'een'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="s1"&gt;'kreupel'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="s1"&gt;'olif'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="s1"&gt;'springt'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;It attempted to guess some words as you can see from the lexeme 'olif', but, to a dutch reader, this is &lt;em&gt;not&lt;/em&gt; stemmed correctly. Neither are the stop words removed: 'de' and 'een' are articles which, in dutch, are considered of no value in a text search context. So let us try this again with the built-in &lt;em&gt;dutch&lt;/em&gt; configuration:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'dutch'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Een blauwe olifant springt al dartelend over de kreupele dolfijn'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we get:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="s1"&gt;'blauw'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="s1"&gt;'dartel'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="s1"&gt;'dolfijn'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="s1"&gt;'kreupel'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="s1"&gt;'olifant'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="s1"&gt;'springt'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Aha! That is much shorter then the previous result, and it is also more correct. As you can see, the words 'de' and 'een' are now removed and the stemming is done correctly on 'dartel', 'olifant' and 'kreupel'.
The target of this series, however, is not to show you the dutch language (for it will make you weep...), but you see the effect a different configuration set can have. &lt;/p&gt;
&lt;p&gt;But what is such a configuration set made of? To answer that, we can simply use the same describe, but ask for more detailed information with the &lt;em&gt;+&lt;/em&gt; flag:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;dF&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will return a list of &lt;em&gt;all&lt;/em&gt; the configurations and their details, so let us filter that and look at only the english version:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;dF&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;english&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The following result will be returned:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt; asciihword      &lt;span class="p"&gt;|&lt;/span&gt; english_stem
 asciiword       &lt;span class="p"&gt;|&lt;/span&gt; english_stem
 email           &lt;span class="p"&gt;|&lt;/span&gt; simple
 file            &lt;span class="p"&gt;|&lt;/span&gt; simple
 float           &lt;span class="p"&gt;|&lt;/span&gt; simple
 host            &lt;span class="p"&gt;|&lt;/span&gt; simple
 hword           &lt;span class="p"&gt;|&lt;/span&gt; english_stem
 hword_asciipart &lt;span class="p"&gt;|&lt;/span&gt; english_stem
 hword_numpart   &lt;span class="p"&gt;|&lt;/span&gt; simple
 hword_part      &lt;span class="p"&gt;|&lt;/span&gt; english_stem
 int             &lt;span class="p"&gt;|&lt;/span&gt; simple
 numhword        &lt;span class="p"&gt;|&lt;/span&gt; simple
 numword         &lt;span class="p"&gt;|&lt;/span&gt; simple
 sfloat          &lt;span class="p"&gt;|&lt;/span&gt; simple
 uint            &lt;span class="p"&gt;|&lt;/span&gt; simple
 url             &lt;span class="p"&gt;|&lt;/span&gt; simple
 url_path        &lt;span class="p"&gt;|&lt;/span&gt; simple
 version         &lt;span class="p"&gt;|&lt;/span&gt; simple
 word            &lt;span class="p"&gt;|&lt;/span&gt; english_stem
&lt;/pre&gt;


&lt;p&gt;All of these are &lt;em&gt;token categories&lt;/em&gt; that target the different groups of words that the PostgreSQL full text parser recognizes.
 For each category there are one or more dictionaries defined which will receive the token and try to return a lexeme.
 We also call this overview a configuration map, for it maps a category to one or more dictionaries.&lt;/p&gt;
&lt;p&gt;If the parser encounters a URL, for example, it will categorize it as a &lt;em&gt;url&lt;/em&gt; or &lt;em&gt;url_path&lt;/em&gt; token and as a result, PostgreSQL will consult the dictionaries &lt;em&gt;mapped&lt;/em&gt; to this category to try and create a single lexeme containing a URL pointing to the same path. Example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example.com&lt;/li&gt;
&lt;li&gt;example.com/index.html&lt;/li&gt;
&lt;li&gt;example.com/foo/../index.html&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The URLs all result in the same document being served, so it makes sense to only save one variant as a lexeme in the resulting vector.
The same kind of &lt;em&gt;normalization&lt;/em&gt; is done for file paths, version numbers, host names, units of measure, ... . A lot more then normal, English words.&lt;/p&gt;
&lt;p&gt;There are 23 categories in total that the parser can recognize, ones not included here, for example, are &lt;em&gt;tag&lt;/em&gt; for XML tags, &lt;em&gt;blank&lt;/em&gt; for whitespace or punctuation, etc.&lt;/p&gt;
&lt;p&gt;To see a description of the different token categories supported, use the 'p' flag together with '+' for more information:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;dFp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;When parsing, the chain of command goes as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A string is fed to PostgreSQL's full text&lt;/li&gt;
&lt;li&gt;The parser crawls over the string and chops it into tokens of a certain type&lt;/li&gt;
&lt;li&gt;For each token category a list of dictionaries (or a single dictionary) is consulted&lt;/li&gt;
&lt;li&gt;If a dictionary list is used, the dictionaries are (generally) ordered from most precise (narrow) to most generic (wide)&lt;/li&gt;
&lt;li&gt;As soon as a dictionary returns a lexeme (single or in the form of an array), the flow for that token stops&lt;/li&gt;
&lt;li&gt;If no lexeme is proposed (a dictionary returns &lt;em&gt;NULL&lt;/em&gt;) the token is given to the next dictionary in line or if a stop word list returns a match (returns &lt;em&gt;empty array&lt;/em&gt;), the token is discarded&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Dictionary templates and dictionaries&lt;/h3&gt;
&lt;p&gt;In the list of token categories that were supported by the built-in 'english' configuration, you will find that only two &lt;em&gt;dictionaries&lt;/em&gt; are used: &lt;em&gt;simple&lt;/em&gt; and &lt;em&gt;english_stem&lt;/em&gt;, which in turn come from the &lt;em&gt;simple&lt;/em&gt; and &lt;em&gt;snowball&lt;/em&gt; dictionary &lt;em&gt;templates&lt;/em&gt; respectively.&lt;/p&gt;
&lt;p&gt;So, what exactly is the difference between a &lt;em&gt;dictionary template&lt;/em&gt; and a &lt;em&gt;dictionary&lt;/em&gt;?&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;dictionary template&lt;/em&gt; is the skeleton (hence template) of a dictionary. It defines the actual &lt;em&gt;C&lt;/em&gt; functions that will do the heavy lifting.
A &lt;em&gt;dictionary&lt;/em&gt; is an instantiation of that template - providing it with data to work with.&lt;/p&gt;
&lt;p&gt;Let me try to clear any confusion on this. &lt;/p&gt;
&lt;p&gt;Take, for example, the &lt;em&gt;simple&lt;/em&gt; dictionary &lt;em&gt;template&lt;/em&gt;. It does two things: it first checks a token against a &lt;em&gt;stop word&lt;/em&gt; list. If it finds a match it returns an &lt;em&gt;empty array&lt;/em&gt;, which will result in the token being discarded. If no match is found in the stop word list, the process will return the same token, but with &lt;em&gt;casing removed&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;All the checking and case removing is done by functions, under the hood. The stop word file, however, is something that the &lt;em&gt;dictionary&lt;/em&gt; (the instantiation) provides.
The instantiation of the &lt;em&gt;simple&lt;/em&gt; dictionary template, thus the &lt;em&gt;dictionary&lt;/em&gt; itself, would be defined as follows:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="k"&gt;DICTIONARY&lt;/span&gt; &lt;span class="k"&gt;simple&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;simple&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;stopwords&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;english&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;No need to run this SQL for PostgreSQL already comes shipped with the &lt;em&gt;simple&lt;/em&gt; dictionary, but I wish to show you how you &lt;em&gt;could&lt;/em&gt; create it.&lt;/p&gt;
&lt;p&gt;First, you will see that we &lt;em&gt;have&lt;/em&gt; to define the template, thus telling PostgreSQL which set of functions to use.
Next we feed it the data it is expecting, in case of &lt;em&gt;simple&lt;/em&gt; it only expects a stop word list.&lt;/p&gt;
&lt;p&gt;The reason for this separation is a safe guard one. Only a database user with &lt;em&gt;super user&lt;/em&gt; privileges can write the actual template, because this template will contain functions that, if written incorrectly, could slow down or crash the database. You need someone who knows what they are doing and not your local script kiddy who has normal user access to your part of the database.&lt;/p&gt;
&lt;p&gt;Notice that we only give the stopwords attribute the word &lt;em&gt;english&lt;/em&gt; instead of a full file path.
This is because PostgreSQL has set a few standards in place for all dictionary types we will see in this chapter.&lt;/p&gt;
&lt;p&gt;First, in case of a stop word list, the file &lt;em&gt;must&lt;/em&gt; have the &lt;em&gt;.stop&lt;/em&gt; extension.&lt;/p&gt;
&lt;p&gt;Next, you can provide a full path to the file, anywhere on your system. 
However, if you do not provide a full path, PostgreSQL will search for it inside a directory called &lt;em&gt;tsearch_data&lt;/em&gt; within PostgreSQL's portion of your system's user &lt;em&gt;shared&lt;/em&gt; directory.&lt;/p&gt;
&lt;p&gt;On a Debian system (using PostgreSQL 9.3) the path to this directory reads: "/usr/share/postgresql/9.3/tsearch_data".&lt;/p&gt;
&lt;p&gt;A dictionary like the &lt;em&gt;simple&lt;/em&gt; dictionary is one that is most of the time put at the beginning of a &lt;em&gt;dictionary list&lt;/em&gt; to remove all the stop words before other dictionaries are being consulted. However, in all the cases where we see &lt;em&gt;simple&lt;/em&gt; in the dictionary column of the token type list above, only this dictionary is used, meaning that only stop words are removed and all else is stripped of casing.&lt;/p&gt;
&lt;h3&gt;Creating the "simple" dictionary&lt;/h3&gt;
&lt;p&gt;Say that we wanted to setup our own &lt;em&gt;simple&lt;/em&gt; dictionary based on the &lt;em&gt;simple&lt;/em&gt; dictionary template, but feed it our own list of stop words. Before setting up this new dictionary, we would first have to write a stop word file. &lt;/p&gt;
&lt;p&gt;Luckily for us, this is trivial. A stop word file is nothing more then a plain text file with one word on each line. Empty lines and trailing whitespace are ignored. We would then have to save this file with the &lt;em&gt;.stop&lt;/em&gt; extension. Let us try just that.&lt;/p&gt;
&lt;p&gt;Open up your editor and punch in the words "dolphin" and "the", both on their own line. Write the file out as "shisaa_stop.stop", preferably in PostgreSQL's shared directory.&lt;/p&gt;
&lt;p&gt;Next we need to setup our dictionary. Connect to the "phrases" database from chapter one and run the following SQL:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="k"&gt;DICTIONARY&lt;/span&gt; &lt;span class="n"&gt;shisaa_simple&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;simple&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;stopwords&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shisaa_stop&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;h3&gt;Setting up a configuration&lt;/h3&gt;
&lt;p&gt;Now, the dictionary by itself is not very helpful. As we have seen before, we need to map it to token categories before we can actually use it for parsing.
This means that we need to make our own configuration.&lt;/p&gt;
&lt;p&gt;Let us setup an empty configuration (not based on an existing one like 'english'):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="n"&gt;CONFIGURATION&lt;/span&gt; &lt;span class="n"&gt;shisaa&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'default'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This statement will create a new configuration for us which is completely empty, it has no mappings. The argument we have to give here can be either &lt;em&gt;parser&lt;/em&gt; or &lt;em&gt;copy&lt;/em&gt;. With parser you define which parser to use and it will create an empty configuration. PostgreSQL has only one parser by default which is named...&lt;em&gt;default&lt;/em&gt;. If you choose &lt;em&gt;copy&lt;/em&gt; then you will have to provide an &lt;em&gt;existing&lt;/em&gt; configuration name (like english) from which you would like to make a copy.&lt;/p&gt;
&lt;p&gt;To verify that the configuration is empty, run our describe on it:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;dF&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;shisaa&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And marvel at its emptiness.&lt;/p&gt;
&lt;p&gt;Now, let us add the &lt;em&gt;shisaa_simple&lt;/em&gt; dictionary we created before:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="n"&gt;CONFIGURATION&lt;/span&gt; &lt;span class="n"&gt;shisaa&lt;/span&gt;
    &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="n"&gt;MAPPING&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;asciiword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;asciihword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword_asciipart&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword_part&lt;/span&gt;
    &lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;shisaa_simple&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you will see throughout this (and the next) chapter, full text extends not only the data types and functions we have available, but also extends PostgreSQL's SQL syntax with a handful of new statements.
I need to note that all of these statements are &lt;em&gt;not&lt;/em&gt; SQL standard (for SQL has no full text standard) and thus cannot be easily ported to a different database.
But then again...what is this folly...who would even need a different database!&lt;/p&gt;
&lt;p&gt;The new statements introduced here (and in the previous SQL blocks) are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;CREATE TEXT SEARCH DICTIONARY&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;CREATE TEXT SEARCH CONFIGURATION&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Just remember that these are not part of the SQL standard (something which PostgreSQL holds very dear, in high contrast with many other databases).&lt;/p&gt;
&lt;p&gt;Did it work? Well, describe it:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;dF&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;shisaa&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt; asciihword      &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple
 asciiword       &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple
 hword           &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple
 hword_asciipart &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple
 hword_part      &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple
 word            &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple
&lt;/pre&gt;


&lt;p&gt;Perfect!&lt;/p&gt;
&lt;p&gt;Here we mapped our fresh dictionary to the token groups "asciihword", "asciiword", "hword", "hword_asciipart", "hword_part", "word", because these will target most of a normal, English sentence.&lt;/p&gt;
&lt;p&gt;It is time to try out this new search configuration! Punch in the same on-the-fly SQL as we had in the previous chapter, but this time with &lt;em&gt;our own&lt;/em&gt; configuration:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'shisaa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'The big blue elephant jumped over the crippled blue dolphin.'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'big'&lt;/span&gt;:2 &lt;span class="s1"&gt;'blue'&lt;/span&gt;:3,9 &lt;span class="s1"&gt;'crippled'&lt;/span&gt;:8 &lt;span class="s1"&gt;'elephant'&lt;/span&gt;:4 &lt;span class="s1"&gt;'jumped'&lt;/span&gt;:5 &lt;span class="s1"&gt;'over'&lt;/span&gt;:6
&lt;/pre&gt;


&lt;p&gt;Ha! All squeaky flippers unite! The word &lt;em&gt;dolphin&lt;/em&gt; is &lt;em&gt;removed&lt;/em&gt;, because we defined it to be a stop word. A world as it should be.&lt;/p&gt;
&lt;p&gt;We now have a basic full text configuration with a &lt;em&gt;simple&lt;/em&gt; dictionary. To have a more real world full text search we will need more then just this dictionary though, we will at least need to take care of stemming.&lt;/p&gt;
&lt;h3&gt;Extending the configuration: stemming with the Snowball&lt;/h3&gt;
&lt;p&gt;Stemming, the process of reducing words to their basic form, is done by a special, dedicated kind of dictionary, the &lt;em&gt;Snowball&lt;/em&gt; dictionary. &lt;/p&gt;
&lt;p&gt;What?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Snowball&lt;/em&gt; is a &lt;em&gt;very proven&lt;/em&gt; string processing language specially designed for stemming purposes and supports a wide range of languages. It originated from the &lt;em&gt;Porter stemming algorithm&lt;/em&gt; and uses a natural syntax to define stemming rules. &lt;/p&gt;
&lt;p&gt;And luckily for us, PostgreSQL has a &lt;em&gt;Snowball&lt;/em&gt; dictionary template ready to use. This template has the Snowball stemming rules embedded for a wide variety of languages. Let us create a &lt;em&gt;dictionary&lt;/em&gt; for our shisaa configuration, shall we?&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="k"&gt;DICTIONARY&lt;/span&gt; &lt;span class="n"&gt;shisaa_snowball&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snowball&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;language&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;english&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Again, very easy to setup. The snowball dictionary &lt;em&gt;template&lt;/em&gt; accepts two variables to be setup. The first, mandatory one is the language you wish to support. Without this, the template does not know which of the Snowball stemming rules to take.&lt;/p&gt;
&lt;p&gt;The next, optional one is, again, a stop word list. But...why can we feed this dictionary a stop word list? Did we not already do that with the &lt;em&gt;simple&lt;/em&gt; dictionary?&lt;/p&gt;
&lt;p&gt;That is correct, we did setup the &lt;em&gt;simple&lt;/em&gt; dictionary to remove stop words for us, but we are not required to use the &lt;em&gt;simple&lt;/em&gt; and the &lt;em&gt;snowball&lt;/em&gt; dictionary in tandem.
It is perfectly possible to &lt;em&gt;map&lt;/em&gt; only the &lt;em&gt;snowball&lt;/em&gt; dictionary for various token categories and ignore all other dictionaries.
If you would not tell the &lt;em&gt;snowball&lt;/em&gt; dictionary to remove stop words, it could become messy for the Snowball stemmer will try and stem &lt;em&gt;all&lt;/em&gt; words it finds.&lt;/p&gt;
&lt;p&gt;This stop word list can be the exact same list we fed the &lt;em&gt;simple&lt;/em&gt; dictionary.&lt;/p&gt;
&lt;p&gt;Also, because a &lt;em&gt;snowball&lt;/em&gt; dictionary will try and parse &lt;em&gt;all&lt;/em&gt; the tokens it is being fed, it is consider to be a &lt;em&gt;wide&lt;/em&gt; dictionary. Therefor, as we have seen earlier, it is a good idea when chaining dictionaries together to put this dictionary at the end of your chain.&lt;/p&gt;
&lt;p&gt;We now have our own version of the &lt;em&gt;snowball&lt;/em&gt; dictionary and need to extend our configuration and map this dictionary to the desired token categories:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="n"&gt;CONFIGURATION&lt;/span&gt; &lt;span class="n"&gt;shisaa&lt;/span&gt;
    &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="n"&gt;MAPPING&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;asciiword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;asciihword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword_asciipart&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword_part&lt;/span&gt;
    &lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;shisaa_simple&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shisaa_snowball&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Notice that in the &lt;em&gt;WITH&lt;/em&gt; clause we are now chaining the &lt;em&gt;simple&lt;/em&gt; and the &lt;em&gt;snowball&lt;/em&gt; dictionary together. The order is, of course, important.
Describe our configuration once more:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;dF&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;shisaa&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;asciihword      &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple,shisaa_snowball
asciiword       &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple,shisaa_snowball
hword           &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple,shisaa_snowball
hword_asciipart &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple,shisaa_snowball
hword_part      &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple,shisaa_snowball
word            &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple,shisaa_snowball
&lt;/pre&gt;


&lt;p&gt;Perfect, now the &lt;em&gt;simple&lt;/em&gt; dictionary will be consulted first followed by the &lt;em&gt;snowball&lt;/em&gt; dictionary.&lt;/p&gt;
&lt;p&gt;Note that throughout this chapter I will chain together dictionaries in order. This will &lt;em&gt;not&lt;/em&gt; always be the most smart or desired order, just an order to demonstrate &lt;em&gt;how&lt;/em&gt; you can chain dictionaries.&lt;/p&gt;
&lt;p&gt;To the test, throw a new query at it:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'shisaa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'The big blue elephant jumped over the crippled blue dolphin.'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'big'&lt;/span&gt;:2 &lt;span class="s1"&gt;'blue'&lt;/span&gt;:3,9 &lt;span class="s1"&gt;'crippled'&lt;/span&gt;:8 &lt;span class="s1"&gt;'elephant'&lt;/span&gt;:4 &lt;span class="s1"&gt;'jumped'&lt;/span&gt;:5 &lt;span class="s1"&gt;'over'&lt;/span&gt;:6
&lt;/pre&gt;


&lt;p&gt;Nice, that is very...oh wait. Something is not correct. I am getting back &lt;em&gt;exactly&lt;/em&gt; the same result as before. The words "crippled" and "elephant" are not stemmed at all. Why?&lt;/p&gt;
&lt;p&gt;Well, the &lt;em&gt;simple&lt;/em&gt; dictionary, as we defined it earlier, is setup to be a bit greedy. In its current state it will return an unmatched token as a lexeme with casing removed.
It does not return &lt;em&gt;NULL&lt;/em&gt;. And, as you know by now, &lt;em&gt;NULL&lt;/em&gt; is needed to give other dictionaries a chance to examine the token.&lt;/p&gt;
&lt;p&gt;So, we need to alter the &lt;em&gt;simple&lt;/em&gt; dictionary's behavior. For this, we can use the &lt;em&gt;ALTER&lt;/em&gt; syntax provided to us. And as it turns out, the &lt;em&gt;simple&lt;/em&gt; dictionary &lt;em&gt;template&lt;/em&gt; can accept one more variable: the &lt;em&gt;accept&lt;/em&gt; variable. If this is set to false, then it will return &lt;em&gt;NULL&lt;/em&gt; for every unmatched token. Let us alter that dictionary:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="k"&gt;DICTIONARY&lt;/span&gt; &lt;span class="n"&gt;shisaa_simple&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;accept&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Run the ts_vector query again, and look at the results:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'big'&lt;/span&gt;:2 &lt;span class="s1"&gt;'blue'&lt;/span&gt;:3,9 &lt;span class="s1"&gt;'crippl'&lt;/span&gt;:8 &lt;span class="s1"&gt;'eleph'&lt;/span&gt;:4 &lt;span class="s1"&gt;'jump'&lt;/span&gt;:5 &lt;span class="s1"&gt;'over'&lt;/span&gt;:6
&lt;/pre&gt;


&lt;p&gt;That is what we were looking for, nicely stemmed results!&lt;/p&gt;
&lt;h3&gt;Extending the configuration: fun with synonyms&lt;/h3&gt;
&lt;p&gt;By now we have seen the first and the last dictionary in our control chain, but at least one more important part is missing: synonyms are not removed.&lt;/p&gt;
&lt;p&gt;Let us extend our favorite sentence and add a few synonyms to it: "The big blue elephant, joined by its enormous blue mammoth friend, jumped over the crippled blue dolphin while smiling at the orca."&lt;/p&gt;
&lt;p&gt;Still perfectly possible.&lt;/p&gt;
&lt;p&gt;In the light of (cue dark en deep Batman voice) "science" (end Batman voice), let us first see what we get when we run it through our current configuration:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'at'&lt;/span&gt;:20 &lt;span class="s1"&gt;'big'&lt;/span&gt;:2 &lt;span class="s1"&gt;'blue'&lt;/span&gt;:3,9,16 &lt;span class="s1"&gt;'by'&lt;/span&gt;:6 &lt;span class="s1"&gt;'crippl'&lt;/span&gt;:15 &lt;span class="s1"&gt;'eleph'&lt;/span&gt;:4 &lt;span class="s1"&gt;'enorm'&lt;/span&gt;:8 &lt;span class="s1"&gt;'friend'&lt;/span&gt;:11 &lt;span class="s1"&gt;'it'&lt;/span&gt;:7 &lt;span class="s1"&gt;'join'&lt;/span&gt;:5 &lt;span class="s1"&gt;'jump'&lt;/span&gt;:12 &lt;span class="s1"&gt;'mammoth'&lt;/span&gt;:10 &lt;span class="s1"&gt;'orca'&lt;/span&gt;:22 &lt;span class="s1"&gt;'over'&lt;/span&gt;:13 &lt;span class="s1"&gt;'smile'&lt;/span&gt;:19 &lt;span class="s1"&gt;'while'&lt;/span&gt;:18
&lt;/pre&gt;


&lt;p&gt;That is one big result set. Maybe we should cut the blue dolphin a little bit of slack and feed a real stop word list to our &lt;em&gt;simple&lt;/em&gt; dictionary before continuing by altering our &lt;em&gt;dictionary&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="k"&gt;DICTIONARY&lt;/span&gt; &lt;span class="n"&gt;shisaa_simple&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;stopwords&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;english&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you see you can simply use the same &lt;em&gt;ALTER&lt;/em&gt; syntax as before. The "english" here refers to the shipped "english.stop" stop word list.&lt;/p&gt;
&lt;p&gt;Querying again, we will get back a better, short list (including our Dolphin friend):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'big'&lt;/span&gt;:2 &lt;span class="s1"&gt;'blue'&lt;/span&gt;:3,9,16 &lt;span class="s1"&gt;'crippl'&lt;/span&gt;:15 &lt;span class="s1"&gt;'dolphin'&lt;/span&gt;:17 &lt;span class="s1"&gt;'eleph'&lt;/span&gt;:4 &lt;span class="s1"&gt;'enorm'&lt;/span&gt;:8 &lt;span class="s1"&gt;'friend'&lt;/span&gt;:11 &lt;span class="s1"&gt;'join'&lt;/span&gt;:5 &lt;span class="s1"&gt;'jump'&lt;/span&gt;:12 &lt;span class="s1"&gt;'mammoth'&lt;/span&gt;:10 &lt;span class="s1"&gt;'orca'&lt;/span&gt;:22 &lt;span class="s1"&gt;'smile'&lt;/span&gt;:19
&lt;/pre&gt;


&lt;p&gt;Now we would like to reduce this result even further by compacting synonyms into one lexeme.&lt;/p&gt;
&lt;p&gt;Enter the &lt;em&gt;synonym&lt;/em&gt; dictionary &lt;em&gt;template&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This template requires you to have a so-called "synonym" file; A file containing lists of words with the same meaning. For the sake of learning, let us create our own synonym file. This file has to end with the &lt;em&gt;.syn&lt;/em&gt; extension.&lt;/p&gt;
&lt;p&gt;Open up your editor again and write out a file called "shisaa_syn.syn" with the following contents:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;big enormous
elephant mammoth
dolphin orca
&lt;/pre&gt;


&lt;p&gt;And let us setup the &lt;em&gt;dictionary&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="k"&gt;DICTIONARY&lt;/span&gt; &lt;span class="n"&gt;shisaa_synonym&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;synonym&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;synonyms&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shisaa_syn&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And add the mapping for it:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="n"&gt;CONFIGURATION&lt;/span&gt; &lt;span class="n"&gt;shisaa&lt;/span&gt;
    &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="n"&gt;MAPPING&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;asciiword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;asciihword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword_asciipart&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword_part&lt;/span&gt;
    &lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;shisaa_simple&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shisaa_synonym&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shisaa_snowball&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Okay, time to test our big string again and see the results:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'blue'&lt;/span&gt;:3,9,16 &lt;span class="s1"&gt;'crippl'&lt;/span&gt;:15 &lt;span class="s1"&gt;'enorm'&lt;/span&gt;:8 &lt;span class="s1"&gt;'enormous'&lt;/span&gt;:2 &lt;span class="s1"&gt;'friend'&lt;/span&gt;:11 &lt;span class="s1"&gt;'join'&lt;/span&gt;:5 &lt;span class="s1"&gt;'jump'&lt;/span&gt;:12 &lt;span class="s1"&gt;'mammoth'&lt;/span&gt;:4,10 &lt;span class="s1"&gt;'orca'&lt;/span&gt;:17,22 &lt;span class="s1"&gt;'smile'&lt;/span&gt;:19
&lt;/pre&gt;


&lt;p&gt;Very neat. The words "elephant", "big" and "dolphin" are now removed and only their synonyms are kept.
Also notice that both "mammoth" and "orca" have two pointers each, one for every synonym.&lt;/p&gt;
&lt;p&gt;But look at the words 'enorm' and 'enormous', why is this happening?&lt;/p&gt;
&lt;p&gt;If you look at the pointers, you see that &lt;em&gt;enormous&lt;/em&gt; points to the second word in the string, being &lt;em&gt;big&lt;/em&gt;, while &lt;em&gt;enorm&lt;/em&gt; points to the original &lt;em&gt;enormous&lt;/em&gt; word.
The reason why this is happening is because our &lt;em&gt;synonym&lt;/em&gt; dictionary has priority over our &lt;em&gt;snowball&lt;/em&gt; one. The &lt;em&gt;synonym&lt;/em&gt; dictionary emits a lexeme as a synonym for &lt;em&gt;big&lt;/em&gt;, being &lt;em&gt;enormous&lt;/em&gt;, simply because we told it to do so in our &lt;em&gt;synonym file&lt;/em&gt;. Now, because it emits a lexeme, the original token, &lt;em&gt;big&lt;/em&gt;, is not available anymore for the rest of the dictionary chain.&lt;/p&gt;
&lt;p&gt;The token &lt;em&gt;enormous&lt;/em&gt; itself has &lt;em&gt;no&lt;/em&gt; synonym because we did not define it in our synonym file. It is ignored by the &lt;em&gt;synonym&lt;/em&gt; dictionary and passed over to the &lt;em&gt;snowball&lt;/em&gt; dictionary which then stems the token into a lexeme resulting in &lt;em&gt;enorm&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;If you wish to prevent this from happening, you could add a self pointing line to your synonym list:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;enormous enormous
&lt;/pre&gt;


&lt;p&gt;Now load in the file on disk to pull the changes into PostgreSQL:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="k"&gt;DICTIONARY&lt;/span&gt; &lt;span class="n"&gt;shisaa_synonym&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;synonyms&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;shisaa_syn&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And run the query again, the result should now read:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'blue'&lt;/span&gt;:3,9,16 &lt;span class="s1"&gt;'crippl'&lt;/span&gt;:15 &lt;span class="s1"&gt;'enormous'&lt;/span&gt;:2,8 &lt;span class="s1"&gt;'friend'&lt;/span&gt;:11 &lt;span class="s1"&gt;'join'&lt;/span&gt;:5 &lt;span class="s1"&gt;'jump'&lt;/span&gt;:12 &lt;span class="s1"&gt;'mammoth'&lt;/span&gt;:4,10 &lt;span class="s1"&gt;'orca'&lt;/span&gt;:17,22 &lt;span class="s1"&gt;'smile'&lt;/span&gt;:19
&lt;/pre&gt;


&lt;p&gt;Now &lt;em&gt;enorm&lt;/em&gt; will be removed and both &lt;em&gt;big&lt;/em&gt; and &lt;em&gt;enormous&lt;/em&gt; are cast to the same lexeme. &lt;/p&gt;
&lt;p&gt;PostgreSQL does not ship a synonym list, so you will have to compile your own just like we did above but hopefully a little bit more useful&lt;/p&gt;
&lt;h3&gt;Extending the configuration: phrasing with a Thesaurus&lt;/h3&gt;
&lt;p&gt;Next up is the &lt;em&gt;thesaurus&lt;/em&gt; dictionary, which is quite close to the &lt;em&gt;synonym&lt;/em&gt; dictionary, with one exception: &lt;em&gt;phrases&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;thesaurus&lt;/em&gt; dictionary is used to recognize phrases and convert them into lexemes with the same meaning. Again, this dictionary relies on a file containing the phrase conversions.
This time, the file has the &lt;em&gt;.ths&lt;/em&gt; extension. &lt;/p&gt;
&lt;p&gt;Open up your editor and write out a file called "shisaa_thesaurus.ths" with the following contents:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;big blue elephant : PostgreSQL
crippled blue dolphin : MySQL
&lt;/pre&gt;


&lt;p&gt;Before we can create the dictionary, there is one more required variable we have to set, the &lt;em&gt;subdictionary&lt;/em&gt; the &lt;em&gt;thesaurus&lt;/em&gt; dictionary can use.
This subdictionary will be &lt;em&gt;another&lt;/em&gt; dictionary you have defined before. Most of the time a stemmer is fed to this variable to let the thesaurus stem the input before comparing it with its thesaurus file.&lt;/p&gt;
&lt;p&gt;So let us feed it our &lt;em&gt;snowball&lt;/em&gt; dictionary and set it up:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="k"&gt;DICTIONARY&lt;/span&gt; &lt;span class="n"&gt;shisaa_thesaurus&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;TEMPLATE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;thesaurus&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;DICTFILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shisaa_thesaurus&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;DICTIONARY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shisaa_snowball&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Map it:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="n"&gt;CONFIGURATION&lt;/span&gt; &lt;span class="n"&gt;shisaa&lt;/span&gt;
    &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="n"&gt;MAPPING&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;asciiword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;asciihword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword_asciipart&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword_part&lt;/span&gt;
    &lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;shisaa_simple&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shisaa_thesaurus&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shisaa_snowball&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Notice that I took out the &lt;em&gt;synonym&lt;/em&gt; dictionary. If we chain up to many dictionaries, the results might turn out to be undesirable in our demonstration use case.&lt;/p&gt;
&lt;p&gt;Querying will result in the following tsvector:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'blue'&lt;/span&gt;:7 &lt;span class="s1"&gt;'enorm'&lt;/span&gt;:6 &lt;span class="s1"&gt;'friend'&lt;/span&gt;:9 &lt;span class="s1"&gt;'join'&lt;/span&gt;:3 &lt;span class="s1"&gt;'jump'&lt;/span&gt;:10 &lt;span class="s1"&gt;'mammoth'&lt;/span&gt;:8 &lt;span class="s1"&gt;'mysql'&lt;/span&gt;:13 &lt;span class="s1"&gt;'orca'&lt;/span&gt;:18 &lt;span class="s1"&gt;'postgresql'&lt;/span&gt;:2 &lt;span class="s1"&gt;'smile'&lt;/span&gt;:15
&lt;/pre&gt;


&lt;p&gt;That is quite awesome, it now recognizes "big blue elephant" as PostgreSQL and "crippled blue dolphin" as MySQL. We have created a &lt;em&gt;pun-aware&lt;/em&gt; full text search configuration!&lt;/p&gt;
&lt;p&gt;As you can see,  both the "MySQL" and "PostgreSQL" lexemes have &lt;em&gt;one&lt;/em&gt; pointer each, pointing to the first word of the substring that got converted.&lt;/p&gt;
&lt;h3&gt;Extending the configuration a last time: morphing with Ispell&lt;/h3&gt;
&lt;p&gt;Okay, we are almost at the end of the dictionary &lt;em&gt;templates&lt;/em&gt; that PostgreSQL supports.&lt;/p&gt;
&lt;p&gt;This last one is a fun one too. Many Unix and Linux systems come shipped with a spell checker called &lt;em&gt;Ispell&lt;/em&gt; or with the more modern variant called &lt;em&gt;HunSpell&lt;/em&gt;.
Besides your average spell checking, these dictionaries are very good at morphological lookups, meaning that they can link all different writing structures of words together.&lt;/p&gt;
&lt;p&gt;A synonym or thesaurus dictionary would not catch these, unless explicitly set with a huge amount of lines in the &lt;em&gt;.syn&lt;/em&gt; or &lt;em&gt;.ths&lt;/em&gt; files, which is error prone and inelegant. 
The Ispell or Hunspell dictionaries &lt;em&gt;will&lt;/em&gt; capture these and try to make them into one lexeme.&lt;/p&gt;
&lt;p&gt;Before setting up the &lt;em&gt;dictionary&lt;/em&gt;, we first need to make sure that we have the Ispell or Hunspell dictionary files for the language we wish to support.
Normally you would want to download these files from the official OpenOffice page. These pages, however, seem to be confusing and the correct files very hard to find. I have found &lt;a href="http://fmg-www.cs.ucla.edu/geoff/ispell-dictionaries.html" title="OpenOffice Extension page."&gt;the following page&lt;/a&gt; of great help to get the files you need for your desired language
.
Download the files for your desired language and place the &lt;em&gt;.dict&lt;/em&gt; and the &lt;em&gt;.affix&lt;/em&gt; files into the PostgreSQL shared directory.&lt;/p&gt;
&lt;p&gt;For now, let us just take the basic &lt;em&gt;english&lt;/em&gt; dict and affix files (named both &lt;em&gt;en_us&lt;/em&gt; and already shipped with PostgreSQL) and feed them to the configuration:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="k"&gt;DICTIONARY&lt;/span&gt; &lt;span class="n"&gt;shisaa_ispell&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ispell&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;DictFile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;en_us&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;AffFile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;en_us&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;StopWords&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;english&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And chain it:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="nb"&gt;TEXT&lt;/span&gt; &lt;span class="k"&gt;SEARCH&lt;/span&gt; &lt;span class="n"&gt;CONFIGURATION&lt;/span&gt; &lt;span class="n"&gt;shisaa&lt;/span&gt;
    &lt;span class="k"&gt;ALTER&lt;/span&gt; &lt;span class="n"&gt;MAPPING&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;asciiword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;asciihword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword_asciipart&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hword_part&lt;/span&gt;
    &lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;shisaa_simple&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shisaa_ispell&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shisaa_snowball&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Notice again I took out the &lt;em&gt;thesaurus&lt;/em&gt; dictionary, not to pile up too many dictionaries at once.&lt;/p&gt;
&lt;p&gt;Query it once more, and look at what we get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'big'&lt;/span&gt;:2 &lt;span class="s1"&gt;'blue'&lt;/span&gt;:3,9,16 &lt;span class="s1"&gt;'cripple'&lt;/span&gt;:15 &lt;span class="s1"&gt;'dolphin'&lt;/span&gt;:17 &lt;span class="s1"&gt;'elephant'&lt;/span&gt;:4 &lt;span class="s1"&gt;'enormous'&lt;/span&gt;:8 &lt;span class="s1"&gt;'friend'&lt;/span&gt;:11 &lt;span class="s1"&gt;'join'&lt;/span&gt;:5 &lt;span class="s1"&gt;'joined'&lt;/span&gt;:5 &lt;span class="s1"&gt;'jump'&lt;/span&gt;:12 &lt;span class="s1"&gt;'mammoth'&lt;/span&gt;:10 &lt;span class="s1"&gt;'orca'&lt;/span&gt;:22 &lt;span class="s1"&gt;'smile'&lt;/span&gt;:19 &lt;span class="s1"&gt;'smiling'&lt;/span&gt;:19
&lt;/pre&gt;


&lt;p&gt;Hmm, interesting. Notice that we now got &lt;em&gt;more&lt;/em&gt; lexemes than before, &lt;em&gt;smile&lt;/em&gt; and &lt;em&gt;smiling&lt;/em&gt; for example, and &lt;em&gt;join&lt;/em&gt; and &lt;em&gt;joined&lt;/em&gt;. Also, both these cases have the &lt;em&gt;same&lt;/em&gt; pointer. Why is that?&lt;/p&gt;
&lt;p&gt;What is happening here is a feature of the Ispell dictionary called &lt;em&gt;morphology&lt;/em&gt;, or as we seen above, &lt;em&gt;morphological lookups&lt;/em&gt;.
One of the reasons why Ispell is such a powerful dictionary is because it can recognize and act upon the &lt;em&gt;structure&lt;/em&gt; of a word. &lt;/p&gt;
&lt;p&gt;In our case, Ispell recognizes &lt;em&gt;joined&lt;/em&gt; (or &lt;em&gt;smiling&lt;/em&gt;) and emits an array of &lt;em&gt;two&lt;/em&gt; lexemes, the original token converted to a lexeme &lt;em&gt;and&lt;/em&gt; the stemmed version of the token.&lt;/p&gt;
&lt;p&gt;This concludes all the dictionaries that PostgreSQL ships with by default and the ones you will most likely ever need. What is next?&lt;/p&gt;
&lt;h3&gt;Debugging&lt;/h3&gt;
&lt;p&gt;Now that you have a good understanding of how to build your own configuration and setup your own dictionaries, I would like to introduce a few new functions that can come in handy when your configuration would produce seemingly strange results.&lt;/p&gt;
&lt;h4&gt;ts_debug()&lt;/h4&gt;
&lt;p&gt;The first function I want show you is a &lt;em&gt;very&lt;/em&gt; handy one that is built to test your &lt;em&gt;whole&lt;/em&gt; full text configuration. It helps you keep your mental condition to just mildly insane, so to speak.&lt;/p&gt;
&lt;p&gt;The function &lt;em&gt;ts_debug()&lt;/em&gt; accepts a configuration and a string of text you wish to test. As a result you will get back a set that contains an overview of how the parser chopped your string into tokens,  which category it picked for each token, which dictionary was consulted and which lexeme(s) where emitted. Oh boy, this is too much fun, let us just try it out! &lt;/p&gt;
&lt;p&gt;Feed our original pun string and let us test the current &lt;em&gt;shisaa&lt;/em&gt; configuration:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ts_debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'shisaa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'The big blue elephant jumped over the crippled blue dolphin.'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Hmm, that may not be very readable, rather use the wildcard selector and a FROM clause to include column names into our result set (one of the few times you may use this selector without getting smacked):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;ts_debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'shisaa'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'The big blue elephant jumped over the crippled blue dolphin.'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Which will result in the following, huge set:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="nb"&gt;alias&lt;/span&gt;   &lt;span class="p"&gt;|&lt;/span&gt;   description   &lt;span class="p"&gt;|&lt;/span&gt;  token   &lt;span class="p"&gt;|&lt;/span&gt;                 dictionaries                  &lt;span class="p"&gt;|&lt;/span&gt;  dictionary   &lt;span class="p"&gt;|&lt;/span&gt;  lexemes   
-----------+-----------------+----------+-----------------------------------------------+---------------+------------
asciiword &lt;span class="p"&gt;|&lt;/span&gt; Word, all ASCII &lt;span class="p"&gt;|&lt;/span&gt; The      &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;shisaa_simple,shisaa_ispell,shisaa_snowball&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
blank     &lt;span class="p"&gt;|&lt;/span&gt; Space symbols   &lt;span class="p"&gt;|&lt;/span&gt;          &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;                                            &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt; 
asciiword &lt;span class="p"&gt;|&lt;/span&gt; Word, all ASCII &lt;span class="p"&gt;|&lt;/span&gt; big      &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;shisaa_simple,shisaa_ispell,shisaa_snowball&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; shisaa_ispell &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;big&lt;span class="o"&gt;}&lt;/span&gt;
blank     &lt;span class="p"&gt;|&lt;/span&gt; Space symbols   &lt;span class="p"&gt;|&lt;/span&gt;          &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;                                            &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt; 
asciiword &lt;span class="p"&gt;|&lt;/span&gt; Word, all ASCII &lt;span class="p"&gt;|&lt;/span&gt; blue     &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;shisaa_simple,shisaa_ispell,shisaa_snowball&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; shisaa_ispell &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;blue&lt;span class="o"&gt;}&lt;/span&gt;
blank     &lt;span class="p"&gt;|&lt;/span&gt; Space symbols   &lt;span class="p"&gt;|&lt;/span&gt;          &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;                                            &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt; 
asciiword &lt;span class="p"&gt;|&lt;/span&gt; Word, all ASCII &lt;span class="p"&gt;|&lt;/span&gt; elephant &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;shisaa_simple,shisaa_ispell,shisaa_snowball&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; shisaa_ispell &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;elephant&lt;span class="o"&gt;}&lt;/span&gt;
blank     &lt;span class="p"&gt;|&lt;/span&gt; Space symbols   &lt;span class="p"&gt;|&lt;/span&gt;          &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;                                            &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt; 
asciiword &lt;span class="p"&gt;|&lt;/span&gt; Word, all ASCII &lt;span class="p"&gt;|&lt;/span&gt; jumped   &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;shisaa_simple,shisaa_ispell,shisaa_snowball&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; shisaa_ispell &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;jump&lt;span class="o"&gt;}&lt;/span&gt;
blank     &lt;span class="p"&gt;|&lt;/span&gt; Space symbols   &lt;span class="p"&gt;|&lt;/span&gt;          &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;                                            &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt; 
asciiword &lt;span class="p"&gt;|&lt;/span&gt; Word, all ASCII &lt;span class="p"&gt;|&lt;/span&gt; over     &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;shisaa_simple,shisaa_ispell,shisaa_snowball&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
blank     &lt;span class="p"&gt;|&lt;/span&gt; Space symbols   &lt;span class="p"&gt;|&lt;/span&gt;          &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;                                            &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt; 
asciiword &lt;span class="p"&gt;|&lt;/span&gt; Word, all ASCII &lt;span class="p"&gt;|&lt;/span&gt; the      &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;shisaa_simple,shisaa_ispell,shisaa_snowball&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; shisaa_simple &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;
blank     &lt;span class="p"&gt;|&lt;/span&gt; Space symbols   &lt;span class="p"&gt;|&lt;/span&gt;          &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;                                            &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt; 
asciiword &lt;span class="p"&gt;|&lt;/span&gt; Word, all ASCII &lt;span class="p"&gt;|&lt;/span&gt; crippled &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;shisaa_simple,shisaa_ispell,shisaa_snowball&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; shisaa_ispell &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;cripple&lt;span class="o"&gt;}&lt;/span&gt;
blank     &lt;span class="p"&gt;|&lt;/span&gt; Space symbols   &lt;span class="p"&gt;|&lt;/span&gt;          &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;                                            &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt; 
asciiword &lt;span class="p"&gt;|&lt;/span&gt; Word, all ASCII &lt;span class="p"&gt;|&lt;/span&gt; blue     &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;shisaa_simple,shisaa_ispell,shisaa_snowball&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; shisaa_ispell &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;blue&lt;span class="o"&gt;}&lt;/span&gt;
blank     &lt;span class="p"&gt;|&lt;/span&gt; Space symbols   &lt;span class="p"&gt;|&lt;/span&gt;          &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;                                            &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt; 
asciiword &lt;span class="p"&gt;|&lt;/span&gt; Word, all ASCII &lt;span class="p"&gt;|&lt;/span&gt; dolphin  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;shisaa_simple,shisaa_ispell,shisaa_snowball&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; shisaa_ispell &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;dolphin&lt;span class="o"&gt;}&lt;/span&gt;
blank     &lt;span class="p"&gt;|&lt;/span&gt; Space symbols   &lt;span class="p"&gt;|&lt;/span&gt; .        &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;                                            &lt;span class="p"&gt;|&lt;/span&gt;               &lt;span class="p"&gt;|&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You now have a complete overview of the flow from string to vector of lexemes. Let me go over some interesting facts of this result set.&lt;/p&gt;
&lt;p&gt;First, notice how the tokens &lt;em&gt;the&lt;/em&gt; and &lt;em&gt;over&lt;/em&gt; got removed by the &lt;em&gt;simple&lt;/em&gt; dictionary. They where a hit in the stop word list, so the dictionary returned an &lt;em&gt;empty array&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Next you see the alias &lt;em&gt;blank&lt;/em&gt; between each &lt;em&gt;asciiword&lt;/em&gt;. &lt;em&gt;Blank&lt;/em&gt; is a category used for spaces or punctuation. A &lt;em&gt;space&lt;/em&gt; and a &lt;em&gt;.&lt;/em&gt; (full stop) is considered a token, but is stripped out by the parser itself for it has no value in this context.&lt;/p&gt;
&lt;p&gt;And last, see that our &lt;em&gt;snowball&lt;/em&gt; dictionary was never consulted. This means that, in this string, the &lt;em&gt;shisaa_ispell&lt;/em&gt; gobbled all the lexemes that &lt;em&gt;shisaa_simple&lt;/em&gt; threw at it.&lt;/p&gt;
&lt;h4&gt;ts_lexize()&lt;/h4&gt;
&lt;p&gt;The second function is &lt;em&gt;ts_lexize()&lt;/em&gt;. This little helper lets you test different &lt;em&gt;parts&lt;/em&gt; of your whole setup. Take the unexpected result of our last dictionary, where we got back multiple lexemes. As it turned out it is normal behavior, but you may want to verify that the result is coming from the dictionary and not from a side effect of how you chained your dictionaries together.&lt;/p&gt;
&lt;p&gt;To test our single, &lt;em&gt;shisaa_ispell&lt;/em&gt; dictionary, we could feed it to this new function, together with &lt;em&gt;one token&lt;/em&gt; we wish to test:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ts_lexize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'shisaa_ispell'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'joined'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will return:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;joined,join&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Same as we had before, but now we know, for sure, that it is a feature of our Ispell dictionary. 
Notice that I stressed the fact that you can only feed this function &lt;em&gt;one token&lt;/em&gt;, not a string of text and not multiple tokens.&lt;/p&gt;
&lt;p&gt;You can use this function to test all your dictionaries individually, one token at a time.&lt;/p&gt;
&lt;p&gt;Phew, that was a lot to take in for we covered a lot of ground here today. You can turn the lights back high and go get some fresh air.
In the next chapter, I will round up this introduction by introducing you to the following, new material:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ranking search results&lt;/li&gt;
&lt;li&gt;Highlighting words inside search results&lt;/li&gt;
&lt;li&gt;Creating special full text search indexes&lt;/li&gt;
&lt;li&gt;Setting up update triggers for tsvector records&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And as always...thanks for reading!&lt;/p&gt;
&lt;!--  LocalWords:  instantiation PostgreSQL
 --&gt;&lt;/div&gt;</description><category>full text search</category><category>postgresql</category><guid>http://shisaa.jp/postset/postgresql-full-text-search-part-2.html</guid><pubDate>Wed, 07 May 2014 13:00:00 GMT</pubDate></item><item><title>PostgreSQL: A full text search engine - Part 1</title><link>http://shisaa.jp/postset/postgresql-full-text-search-part-1.html</link><dc:creator>Tim van der Linden</dc:creator><description>&lt;div&gt;&lt;h3&gt;Preface&lt;/h3&gt;
&lt;p&gt;PostgreSQL, the database of miracles, the RDBMS of wonders.&lt;/p&gt;
&lt;p&gt;People who have read my stuff before know that I am a fan of the blue-ish elephant and I greatly entrust it with my data. 
For reasons why, I invite you to read the "Dolphin ass-whopping" part of the &lt;a href="http://shisaa.jp/postset/mailserver-2.html" title="Second chapter of the mail setup series."&gt;second chapter&lt;/a&gt; of my mail server setup series.&lt;/p&gt;
&lt;p&gt;But what some of you may not know is that PostgreSQL is capable of much more then simply storing and retrieving your data.
Well, that is actually not entirely correct...you are &lt;em&gt;always&lt;/em&gt; storing and retrieving data.
A more correct way to say it is that PostgreSQL is capable of storing all &lt;em&gt;kinds&lt;/em&gt; of data and gives you all &lt;em&gt;kinds&lt;/em&gt; of ways to retrieve it.
It is not limited to &lt;em&gt;storing&lt;/em&gt; boring stuff like "VARCHAR" or "INT". Neither is it limited to retrieving and &lt;em&gt;comparing&lt;/em&gt; with boring
operators like "=", "ILIKE" or "~". &lt;/p&gt;
&lt;p&gt;For instance, are you familiar with PostgreSQL's &lt;em&gt;"tsvector"&lt;/em&gt; data type? Or the &lt;em&gt;"tsquery"&lt;/em&gt; type? Or what these two represent? No?
Well, diddlydangeroo, then by all means, keep reading, because that is exactly what this series is all about!&lt;/p&gt;
&lt;p&gt;In the following three chapters I would like to show you how you can configure PostgreSQL to be a batteries included, blazing fast, competition crunching, full text search engine.&lt;/p&gt;
&lt;h3&gt;But, I can already search strings of text with PostgreSQL!&lt;/h3&gt;
&lt;p&gt;Hmm, that is very correct. But the basic operators you have at your disposal are limited. &lt;/p&gt;
&lt;p&gt;Let me demonstrate.&lt;/p&gt;
&lt;p&gt;Imagine we would have a table, called "phraseTable" containing thousands of strings, all saved in a regular, old VARCHAR column named "phrase".
Now we would like to find the string &lt;em&gt;"An elephant a day keeps the dolphins at bay."&lt;/em&gt;.
We do not fully remember the above string, but we do remember it had the word "elephant" in it.
With regular SQL you could use the "LIKE" operator to try and find a matching substring. The resulting query would look something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;LIKE&lt;/span&gt; &lt;span class="s1"&gt;'%elephant%'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;It would work, you render any index on the table mute when using front &lt;em&gt;and&lt;/em&gt; back wildcards, but it would work.
Now imagine a humble user would like to find the same string but their memory is bad, they thought the word elephant was capitalized, because it may refer to PostgreSQL, of course.
The query would become this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;LIKE&lt;/span&gt; &lt;span class="s1"&gt;'%Elephant%'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And as a result, you get back zero records.&lt;/p&gt;
&lt;p&gt;"But wait!", you shout, "I am a smart ass, there is a solution to this!". And you are correct: the ILIKE operator.
The "I" stands for Insensitive...as in &lt;em&gt;Case Insensitive&lt;/em&gt;. So you change the query:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;ILIKE&lt;/span&gt; &lt;span class="s1"&gt;'%Elephant%'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And now you will get back a result. Good for you.&lt;/p&gt;
&lt;p&gt;A day goes by and the same user comes back and wishes to find this string again. But, his memory still being bad and all, he thought there where multiple elephants keeping the dolphins at bay, because, you know, pun. So the query, you altered yesterday, now reads:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;ILIKE&lt;/span&gt; &lt;span class="s1"&gt;'%Elephants%'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And...now the query will return zero results.&lt;/p&gt;
&lt;p&gt;"Ha!", you shout in my general direction. "I am a master of Regular Expressions! I shall fix thay query!".&lt;/p&gt;
&lt;p&gt;No, you shall &lt;em&gt;not&lt;/em&gt; fix my query. Never, ever go smart on my derriÃ¨re by throwing a regular expression in the mix to solve a database lookup problem. It is unreadable, un-scalable and fits only one solution perfectly-ish. And, not to forget, is &lt;em&gt;slow as hell&lt;/em&gt; for it not only ignores any index you have set, it also asks more of the database engine then a LIKE or ILIKE.&lt;/p&gt;
&lt;p&gt;Let me put an end to this and tell you that I am afraid there are no more (scalable) smart ass tricks left to perform and the possibilities to search text with regular, build-in operators are exhausted.&lt;/p&gt;
&lt;p&gt;You agree? Yes? Good! So, enter "&lt;em&gt;full text search&lt;/em&gt;"!&lt;/p&gt;
&lt;h3&gt;Full text search?&lt;/h3&gt;
&lt;p&gt;But before we delve into the details of the PostgreSQL implementation, let us take a step back and first see what exactly a full text search engine is.&lt;/p&gt;
&lt;p&gt;Short version: A full text search engine is a system that can retrieve documents, or parts of documents, based on natural language searching.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Natural language&lt;/em&gt; means the living, breathing language we humans use. And as you know, human language can be complex and above all &lt;em&gt;ambiguous&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Consider yourself in the situation where you knew, for sure, that you have read an interesting article about elephants in the latest edition of "Your Favorite Elephant Magazine".
You liked it so much that you want to show it to your best friend, who happens to be an elephant lover too.
The only bummer is, you cannot remember the title, but you do remember it has an interesting sentence in it.&lt;/p&gt;
&lt;p&gt;So what do you do? First you quote the sentence in your mind: "The best elephants have a blue skin color.".
Next, you pick up the latest edition and you start &lt;em&gt;searching&lt;/em&gt;, flipping through the pages, skimming for that sentence.&lt;/p&gt;
&lt;p&gt;After a minute or two you shout: "Dumbo!, I have found the article!". You read the sentence out loud: "The best Elephants bear a blue skin tone.".
You are happy with yourself, call up your friend and tell him that you will be over right away to show him that specific article.&lt;/p&gt;
&lt;p&gt;One thing you forgot to notice was that the sentence in your head, and the sentence that was actually printed where &lt;em&gt;different&lt;/em&gt;, but your brain (which is trained in this natural stuff), sees them as the same.
How did that work? Well, your brain used its internal &lt;em&gt;synonym&lt;/em&gt; list and &lt;em&gt;thesaurus&lt;/em&gt; to link the different words together, making them the same thing, just written differently:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"elephants" is the same as "Elephants"&lt;/li&gt;
&lt;li&gt;"have" is the same as "bear"&lt;/li&gt;
&lt;li&gt;"skin color" is the same "skin tone"&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Without noticing it, you have just completed a full text search using natural language algorithms, your magazine as the database, your brain as the engine.&lt;/p&gt;
&lt;h3&gt;But how does such a natural language lookup work...on an unnatural computer?&lt;/h3&gt;
&lt;p&gt;What a perfectly timed question, I was just getting to that.&lt;/p&gt;
&lt;p&gt;Now that you have a basic understanding of what natural language searching is, how does one port this idea to a stupid, binary ticking tin box?
By dissecting the process we do in our brains, lay it out in several programmable steps and concepts. 
Such a process, run by computers, will never be as good on the &lt;em&gt;natural&lt;/em&gt; part as our brains are, but it is certainly a lot faster with flipping and skimming through the magazine pages.&lt;/p&gt;
&lt;p&gt;Let us look at how a computer, regardless of which program, platform or engine you use, would go about being "natural" when searching for strings of text.&lt;/p&gt;
&lt;p&gt;To speed up the search process, a full text search engine will never search through the actual document itself.
That is how we humans would do it, and that is slow and (for our eyes) error prone. Before a document can be searched through with a full text search engine, it has to be parsed into a list of words first.
The parsing is where the magic happens, this is our attempt at programming the natural language process. Once the document is parsed, the parsed state is saved. Depending on your database model, you can save the parsed state together with a reference to the original document for later retrieval.&lt;/p&gt;
&lt;p&gt;Note that a document, in this context, is simply a big collection of words contained within a file. The engine does not care, and most of the time does not know, about what kind of file (plain text, LibreOffice document, HTML file, ...) it is handling or what the files structure is. It simply looks at all the readable words inside of the file.&lt;/p&gt;
&lt;p&gt;So how does the parsing work? Parsing, in this regard, is all about compressing the text found in a document. Cutting down the word count to the least possible, so later, when a user searches, the engine has to plow through fewer words. This compressing, in most engines, is done in roughly three steps.&lt;/p&gt;
&lt;h4&gt;Remove stop words&lt;/h4&gt;
&lt;p&gt;The first step is the removal of words that do not add any searchable value to the text and are seldom searched for.
These words are known as "stop words", a term first coined by Hans Peter Luhn, a renowned IBM computer scientist who specialized in the retrieval and indexing of information stored in computer systems.&lt;/p&gt;
&lt;p&gt;The list of stop words is not limited to simply ones like "and" or "the". There is an extensive list of hundreds and hundreds of words which are generally considered to be of little value in a search context.
A (very) short list of stop words: her, him, the, also, each, was, we, after, been, they, would, up, from, only, you, while, ... .&lt;/p&gt;
&lt;h4&gt;Eliminate casing&lt;/h4&gt;
&lt;p&gt;The following step in the compression process is the elimination of casing - keeping only the lower case versions of a word.
If you would keep a search case sensitive, then "The ElEphAnt" would not match "the elephant", but generally you do want a match to happen.
The user will many times not care (or not know) about casing in a full text search.&lt;/p&gt;
&lt;h4&gt;Remove synonyms, employing a thesaurus and perform stemming&lt;/h4&gt;
&lt;p&gt;The last part in the compacting of our to-be-indexed document is removing words that have the same meaning and perform stemming.
Synonym lookups are used for removing &lt;em&gt;words&lt;/em&gt; of the same meaning where as thesaurus lookups are used to compact whole &lt;em&gt;phrases&lt;/em&gt; with similar meaning.&lt;/p&gt;
&lt;p&gt;Only one instance of all the synonyms, thesaurus phrases and case eliminations is stored, the surviving word is referred to as a &lt;em&gt;lexeme&lt;/em&gt;, the smallest, meaningful word.
The lexemes that are stored usually (depending on the engine you use) get an accompanying list of (alpha)numeric values stored alongside. Two types of (alpha)numeric values can be stored in case of PostgreSQL:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first type are pure numerical and represent pointer(s) to where the word occurs in the original document.&lt;/li&gt;
&lt;li&gt;The second type is pure alphabetical (actually only capital A,B,C,D) and represent the weight a certain lexeme has. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Do not worry to much about these two (alpha)numerical values for now, we will get to that later.&lt;/p&gt;
&lt;p&gt;Next, let us get practical and start to actually use PostgreSQL to see how all of this works. &lt;/p&gt;
&lt;h3&gt;The tsvector&lt;/h3&gt;
&lt;p&gt;As PostgreSQL is an &lt;em&gt;extendable&lt;/em&gt; database engine, two new data types where added to make full text search possible, as you have seen in the beginning.
One of them is called &lt;em&gt;tsvector&lt;/em&gt;, "ts" for &lt;em&gt;t&lt;/em&gt;ext &lt;em&gt;s&lt;/em&gt;earch and "vector", which is analogous with the generic programming data type "vector".
It is the container in which the result of the parsing is eventually stored.&lt;/p&gt;
&lt;p&gt;Let me show you an example of such a tsvector, as presented by PostgreSQL on querying.
Imagine a document with the following string of text inside: &lt;em&gt;"The big blue elephant jumped over the crippled blue dolphin."&lt;/em&gt;.
A perfectly normal sentence, elephants jump over dolphins all the time.&lt;/p&gt;
&lt;p&gt;Without bothering about how to do it, if we let PostgreSQL parse this string, we will get the following tsvector stored in our record:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'big'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="s1"&gt;'blue'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="s1"&gt;'crippl'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="s1"&gt;'dolphin'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="s1"&gt;'eleph'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="s1"&gt;'jump'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You will notice a few things about this vector, let me go over them one by one.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, you recognize the structure of a vector-ish data type. Hence the name "tsvector".&lt;/li&gt;
&lt;li&gt;Next, the numbers behind the lexemes themselves, like I said before, represent the pointer(s) to that word. Notice the word "blue" in particular, it has two pointers for the two occurrences in the string.&lt;/li&gt;
&lt;li&gt;And last, notice how some lexemes do not even look like English words at all. The lexeme "crippl" or "eleph" do not mean anything, to us humans anyway. These are the surviving lexemes of "cripple" and "elephant". PostgreSQL has stemmed and reduced the words to match all possible variants. The lexeme "crippl", for example, matches "cripple", "crippled", "crippling", "cripples", ... .&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that the above example is the simplest of full text search parsing results, we did not add any weights nor did we employ a thesaurus (or an advanced dictionary) to get back a more efficient compressing.&lt;/p&gt;
&lt;p&gt;Now that we are dwelling inside of PostgreSQL, I can elaborate a bit more about how the parsing works exactly.
As we have seen above, it happens in roughly three steps. But I intentionally neglected to say that with PostgreSQL, there is an intermediate state between the word and the resulting lexeme.&lt;/p&gt;
&lt;p&gt;When PostgreSQL parses the string of text it goes over them and first &lt;em&gt;categorizes&lt;/em&gt; each word into sections like "word", "url", "int", "hword", "asciiword", ... .
Once the words are broken down into categories, we refer to them as &lt;em&gt;tokens&lt;/em&gt;. This is the intermediate state.
For a token to become a lexeme, PostgreSQL will consult a set of defined &lt;em&gt;dictionaries&lt;/em&gt; for each category to try and find a match.
If a match is found, the dictionary will propose a lexeme. This lexeme is the one that will finally be put in the vector as the parsed result.&lt;/p&gt;
&lt;p&gt;If the dictionaries did not find a match, the word is discarded. The one exception to this are the "stop words", if a word matches a stop word, it will be discarded instead of kept.&lt;/p&gt;
&lt;p&gt;Let us now get our hands dirty and setup a quick testing database and rig it up with the phraseTable table we have been using in our journey so far.
But instead of a varchar column, this table will contain a tsvector type for we will unleash to power of Full Text Search!&lt;/p&gt;
&lt;p&gt;Note: I am assuming you have at least PostgreSQL 9.1 or higher. This post was written with PostgreSQL 9.3 in mind.&lt;/p&gt;
&lt;p&gt;So connect to your PostgreSQL install and create the database:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;DATABASE&lt;/span&gt; &lt;span class="n"&gt;phrases&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Do not worry to much about the ownership of this database nor the ownership of its tables, you can discard it whole later.
Now, switch over to the database:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt; &lt;span class="n"&gt;phrases&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And create the phraseTable table:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="n"&gt;tsvector&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="k"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Okay, simple enough. We now have a tiny database, with a table containing one column of type &lt;em&gt;tsvector&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Let us insert a parsed vector into the table.
Again, without employing a thesaurus or any other tools, we only use the built-in, default configuration to parse a string and save it as a vector.&lt;/p&gt;
&lt;p&gt;Let us insert the vector, shall we?&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'english'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'The big blue elephant jumped over the crippled blue dolphin.'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;That was easy enough. Most of what you see is simple, regular SQL with one new kid on the block: "&lt;em&gt;to_tsvector&lt;/em&gt;".
The latter is a &lt;em&gt;function&lt;/em&gt; that is shipped with PostgreSQL's Full Text Search extension and it does what its name suggests: it takes a string of text and converts it into a &lt;em&gt;tsvector&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As a first argument to this function you can optionally input the full text search &lt;em&gt;configuration&lt;/em&gt; you wish the parser to use. The default is &lt;em&gt;"english"&lt;/em&gt;, so I could have omitted it from the argument list.
This configuration holds everything that PostgreSQL will employ to do all of the parsing, including a basic dictionary, stop word list, ... .
PostgreSQL has some default settings, which many times are good enough. The 'english' configuration is such an example.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; As was pointed out by one of my observant readers, depending on how your PostgreSQL is packaged, it could be &lt;em&gt;localized&lt;/em&gt;. This means that the default 'english' configuration could be changed to reflect the language of the localized package. If this is the case with your install, be sure to &lt;em&gt;not omit&lt;/em&gt; the optional parameter and keep its value set to 'english' for all the tsvector and tsquery work we will do in this chapter. Otherwise your full text parsing will produce different, unpredictable results which will make this chapter difficult to follow.&lt;/p&gt;
&lt;p&gt;In the next chapter we will delve &lt;em&gt;deep&lt;/em&gt; into creating our own configuration, for now just take it for granted.&lt;/p&gt;
&lt;p&gt;If we query the result, with a simple select, it will return our newly created vector:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Will return:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'big'&lt;/span&gt;:2 &lt;span class="s1"&gt;'blue'&lt;/span&gt;:3,9 &lt;span class="s1"&gt;'crippl'&lt;/span&gt;:8 &lt;span class="s1"&gt;'dolphin'&lt;/span&gt;:10 &lt;span class="s1"&gt;'eleph'&lt;/span&gt;:4 &lt;span class="s1"&gt;'jump'&lt;/span&gt;:5
&lt;/pre&gt;


&lt;p&gt;Now remember that I talked about the second kind of value we could store alongside the numeric pointers, the &lt;em&gt;weights&lt;/em&gt;? Let us take a deeper look into that now.&lt;/p&gt;
&lt;p&gt;First, weights are not mandatory and only give you an extra tool for ranking the results afterwards.
They are nothing more then a label you can put on a lexeme to group it together. With weights you could, for example, reflect the structure the original document had.
You may wish to put a higher weight on lexemes that come from a title element and a lower weight on those from the body text.&lt;/p&gt;
&lt;p&gt;PostgreSQL knows four weight labels &lt;em&gt;A&lt;/em&gt;, &lt;em&gt;B&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;D&lt;/em&gt;. The lowest in rank being &lt;em&gt;D&lt;/em&gt;. In fact, if you do not define any weights to the lexemes inside a tsvector, all of them will implicitly get a &lt;em&gt;D&lt;/em&gt; assigned.
If all the lexemes in a tsvector carry a &lt;em&gt;D&lt;/em&gt;, it is omitted from display when printing the tsvector, simply for readability.
The above query result could thus also be written as:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'big'&lt;/span&gt;:2D &lt;span class="s1"&gt;'blue'&lt;/span&gt;:3D,9D &lt;span class="s1"&gt;'crippl'&lt;/span&gt;:8D &lt;span class="s1"&gt;'dolphin'&lt;/span&gt;:10D &lt;span class="s1"&gt;'eleph'&lt;/span&gt;:4D &lt;span class="s1"&gt;'jump'&lt;/span&gt;:5D
&lt;/pre&gt;


&lt;p&gt;It is &lt;em&gt;exactly&lt;/em&gt; the same result, but unnecessarily verbose.&lt;/p&gt;
&lt;p&gt;I told you, in the very beginning, that a full text engine does not know or care about the structure of a document, it only sees the words.
So how can it then put labels on lexemes based on a document structure that it does not know?&lt;/p&gt;
&lt;p&gt;It cannot.&lt;/p&gt;
&lt;p&gt;It is your job to provide PostgreSQL with label information when building the tsvector.
Up until now we have been working with simple text strings, which contain no hierarchy. 
If you wish to reflect your original document structure by using weights, you will have to preprocess the document and construct your &lt;em&gt;to_tsvector&lt;/em&gt; query manually.&lt;/p&gt;
&lt;p&gt;Just for demonstration purposes, we could, of course, assign weights to the lexemes inside a simple text string.
The process of weight assignment is trivial. PostgreSQL gives you the appropriately named &lt;em&gt;setweight&lt;/em&gt; function for this.
This function accepts a tsvector as the first argument and a weight label as the second.&lt;/p&gt;
&lt;p&gt;To demonstrate, let me update our record and give all the lexemes in our famous sentence a &lt;em&gt;A&lt;/em&gt; weight label:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;UPDATE&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;setweight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'A'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;If we now query this table, the result will be this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'big'&lt;/span&gt;:2A &lt;span class="s1"&gt;'blue'&lt;/span&gt;:3A,9A &lt;span class="s1"&gt;'crippl'&lt;/span&gt;:8A &lt;span class="s1"&gt;'dolphin'&lt;/span&gt;:10A &lt;span class="s1"&gt;'eleph'&lt;/span&gt;:4A &lt;span class="s1"&gt;'jump'&lt;/span&gt;:5A
&lt;/pre&gt;


&lt;p&gt;Simple, right?&lt;/p&gt;
&lt;p&gt;One more for fun. What if you wanted to assign different weights to the lexemes?
For this, you have to concatenate several &lt;em&gt;setweight&lt;/em&gt; functions together.
An example query would look something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;update&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="n"&gt;setweight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'the big blue elephant'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;'A'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
&lt;span class="n"&gt;setweight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'jumped over the'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;'B'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
&lt;span class="n"&gt;setweight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'crippled blue dolphin.'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;'C'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The result:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s1"&gt;'big'&lt;/span&gt;:2A &lt;span class="s1"&gt;'blue'&lt;/span&gt;:3A,7C &lt;span class="s1"&gt;'crippl'&lt;/span&gt;:6C &lt;span class="s1"&gt;'dolphin'&lt;/span&gt;:8C &lt;span class="s1"&gt;'eleph'&lt;/span&gt;:4A &lt;span class="s1"&gt;'jump'&lt;/span&gt;:5B
&lt;/pre&gt;


&lt;p&gt;Not very usefull, but it demonstrates the principle.&lt;/p&gt;
&lt;p&gt;If the documents you wish to index have a fixed structure, many times the table that will hold the tsvectors for these documents will reflect that structure with appropriately named columns.
For example, if your document would always have a title, body text and a footer, you could create a table which contains three tsvector type columns, named after each structure type.
When you parse the document and construct the query, you could assign all lexemes that will be stored in the title column with an &lt;em&gt;A&lt;/em&gt; label, in the body column with a &lt;em&gt;B&lt;/em&gt; and in the footer column with a &lt;em&gt;C&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Okay, that is enough about weights. Simply remember that they give you extra power to influence the search result ranking, if needed.&lt;/p&gt;
&lt;p&gt;We now have a table with a decent tsvector inside. The data is in, so to speak. But what can we do with it now?&lt;/p&gt;
&lt;p&gt;Well, let us try to retrieve and compare it, shall we!&lt;/p&gt;
&lt;h3&gt;The tsquery&lt;/h3&gt;
&lt;p&gt;You could, of course, simply retrieve the results stored in a &lt;em&gt;tsvector&lt;/em&gt; by doing a &lt;em&gt;SELECT&lt;/em&gt; on the column. However, you have no way of filtering out the results using the operators we have seen before (LIKE, ILIKE). Even if you could use them, you would still run into the same kind of problems as before. You would still have a user who will search for a synonym or search for a plural form of the stemmed lexeme actually stored in the vector.&lt;/p&gt;
&lt;p&gt;So how do we query it?&lt;/p&gt;
&lt;p&gt;Step in &lt;em&gt;tsquery&lt;/em&gt;. What is it? It is a data type that gives us extra tools to &lt;em&gt;query&lt;/em&gt; the full &lt;em&gt;text search&lt;/em&gt; vector.&lt;/p&gt;
&lt;p&gt;Pay attention to the fact that we do not call &lt;em&gt;tsquery&lt;/em&gt; a set of extra &lt;em&gt;operators&lt;/em&gt; but we call it a &lt;em&gt;data type&lt;/em&gt;. This is very important to understand.
With &lt;em&gt;tsquery&lt;/em&gt; we can construct search &lt;em&gt;predicates&lt;/em&gt;, which can search through a &lt;em&gt;tsvector&lt;/em&gt; type and can employ specially designed indexes to speed up the process. &lt;/p&gt;
&lt;p&gt;Let me throw a query at you that will try to find the word "elephants" in our favorite string using &lt;em&gt;tsquery&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'english'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'elephants'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Try it out, this will give you back the same result set we had before. Let me explain what just happened.&lt;/p&gt;
&lt;p&gt;As you can see, there is again a new function introduced: &lt;em&gt;to_tsquery&lt;/em&gt; and it is almost identical to its &lt;em&gt;to_tsvector&lt;/em&gt; counterpart.
The function &lt;em&gt;to_tsquery&lt;/em&gt; takes one argument, a string containing the &lt;em&gt;tokens&lt;/em&gt; (not the words, not the lexemes) you wish to search for.
The first argument I give in this example, 'english', is again the full text configuration and is optional.&lt;/p&gt;
&lt;p&gt;Let us first look a bit more at this one. Say, for instance, you wish to find two tokens of the sentence inside your database.
Your first instinct would be to query this the following way:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'elephants blue'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Unfortunately, this will throw an error stating there is a syntax error. Why? Because the string your provided as an argument is malformed.
The &lt;em&gt;to_tsquery&lt;/em&gt; helper function does not accept a simple string of text, it needs a string of tokens &lt;em&gt;separated by operators&lt;/em&gt;.
The operators at your disposal are the regular &lt;em&gt;&amp;amp;&lt;/em&gt; (AND), &lt;em&gt;|&lt;/em&gt; (OR) and &lt;em&gt;!&lt;/em&gt; (NOT). Note that the &lt;em&gt;!&lt;/em&gt; operator &lt;em&gt;needs&lt;/em&gt; the &lt;em&gt;&amp;amp;&lt;/em&gt; or the &lt;em&gt;|&lt;/em&gt; operator.&lt;/p&gt;
&lt;p&gt;It then goes and creates a true &lt;em&gt;tsquery&lt;/em&gt; to retrieve the results. Let us try this query again, but with correct syntax this time:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'elephants &amp;amp; blue'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Perfect! This will return, once more, the same result as before. You could even use parenthesis inside your string argument to enforce grouping if desired.
Like I said before, what this helper function does is translate its input (the tokens in the string) into actual lexemes. After that, it tries to match this result with the lexemes present in the tsvector.&lt;/p&gt;
&lt;p&gt;We still have a problem if we would let a user type her or his search string into an interface search box and feed it to &lt;em&gt;to_tsquery&lt;/em&gt;, for a user does not know about the operators they need to use.
Luckily for us, there is another help function, the &lt;em&gt;plainto_tsquery&lt;/em&gt; which takes care of exactly that problem: convert an arbitrary string of text into lexemes.&lt;/p&gt;
&lt;p&gt;Let me demonstrate:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phraseTable&lt;/span&gt; &lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;phrase&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;plainto_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'elephants blue'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Notice we did not separate the words with operators, now it is a simple search string. In fact, &lt;em&gt;plainto_tsquery&lt;/em&gt; converts it to a list of lexemes separated by an &lt;em&gt;&amp;amp;&lt;/em&gt; (AND) operator.
The only drawback is that this function can only separate the lexemes with an &lt;em&gt;&amp;amp;&lt;/em&gt; operator.
If you wish to have something other then the &lt;em&gt;&amp;amp;&lt;/em&gt; operator, you will have to stick to &lt;em&gt;to_tsquery&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A word of caution though, the &lt;em&gt;plainto_tsvector&lt;/em&gt; may seem interesting, but is most of the time not a general solution for building a higher level search interface. When you are building, say, a web application that contains a full text search box, there are a few more steps between the string entered in that box, and the final query that will be preformed. &lt;/p&gt;
&lt;p&gt;Building a web application and safely handling user input that travels to the database is a separate story and &lt;em&gt;way&lt;/em&gt; beyond the scope of this post, but you will have to build your own parser that sits between the user input and the query.&lt;/p&gt;
&lt;p&gt;If you would play dumb and accept the fact that your interface would only allow to enter a string in the search box (no operators, no grouping, ...) then you still need to send over the user input using query parameters &lt;em&gt;and&lt;/em&gt; you need to make sure that the parameter sent over is a string. This, of course, is not really a parser, this is more basic, sane database handling on the web. &lt;/p&gt;
&lt;p&gt;As tempting (and simple) it might seem to be to build a query like that, it will probably frustrate your end users. The reason why is because as I mentioned before, the &lt;em&gt;plainto_tsquery&lt;/em&gt; accepts a string, but will chop the string into separate lexemes and put the &lt;em&gt;&amp;amp;&lt;/em&gt; operator between them. This means that &lt;em&gt;all&lt;/em&gt; the words entered by the user (or at least their resulting lexemes) must be found in the string.&lt;/p&gt;
&lt;p&gt;Many times, this may not be what you want. Users expect to have their search string interpreted as &lt;em&gt;|&lt;/em&gt; (OR) separated lexemes, or users may want the ability to define these operators themselves on the interface.&lt;/p&gt;
&lt;p&gt;So, one way or the other, you will have to write your own parser if you want a non-database user to work with your application. This parser looks at the options your present on your search form and will crawl over the user entered string to interpret certain characters not as words to search but as operators or grouping tokens to build your final query.&lt;/p&gt;
&lt;p&gt;But enough about web applications, that is not our focus now. Let us continue.&lt;/p&gt;
&lt;p&gt;The next, new item you will see in the last few queries is the &lt;em&gt;@@&lt;/em&gt; operator. This operator (also referred to as text-search-matching operator) is also specific to a full text search context. It allows you to &lt;em&gt;match&lt;/em&gt; a &lt;em&gt;ts_vector&lt;/em&gt; against the results of a &lt;em&gt;ts_query&lt;/em&gt;. In our queries we matched the result of a &lt;em&gt;ts_query&lt;/em&gt; against a column, but you could also match against a &lt;em&gt;ts_vector&lt;/em&gt; on the fly:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;to_tsvector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'The blue elephant.'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'blue &amp;amp; the'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;A nice little detail about the &lt;em&gt;@@&lt;/em&gt; operator is that it can also match against a &lt;em&gt;TEXT&lt;/em&gt; or &lt;em&gt;VARCHAR&lt;/em&gt; data type, giving you a poor-mans full text capability. Let me demonstrate:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="s1"&gt;'The blue elephant.'&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="nb"&gt;VARCHAR&lt;/span&gt; &lt;span class="o"&gt;@@&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'blue &amp;amp; the'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This 'on-the-fly' query will generate a &lt;em&gt;VARCHAR&lt;/em&gt; string (by using the &lt;em&gt;::&lt;/em&gt; or &lt;em&gt;cast&lt;/em&gt; operator) and try to match the tokens &lt;em&gt;blue&lt;/em&gt; and &lt;em&gt;the&lt;/em&gt;. The result will be &lt;em&gt;t&lt;/em&gt;, meaning that a match is found.&lt;/p&gt;
&lt;p&gt;Before I continue, it is nice to know that you can always test the result of a &lt;em&gt;ts_query&lt;/em&gt;, meaning, test the output of what it will use to find lexemes in the &lt;em&gt;ts_vector&lt;/em&gt;.
To see that output, you simply call it with the helper function, the same way we called the &lt;em&gt;to_tsvector&lt;/em&gt; a while ago:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'elephants &amp;amp; blue'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will result in:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="s1"&gt;'eleph'&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="s1"&gt;'blue'&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;It is also important to note that &lt;em&gt;to_tsquery&lt;/em&gt; (and &lt;em&gt;plainto_tsquery&lt;/em&gt;) too uses a configuration of the same kind &lt;em&gt;to_tsvector&lt;/em&gt; uses, for it too has to do the same parsing to find the lexemes of the string or tokens you feed it. So the first, optional argument to &lt;em&gt;to_tsquery&lt;/em&gt; is the configuration, this also defaults to "english". This means we could rewrite the query as such:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;to_tsquery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'english'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'elephants &amp;amp; blue'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we would get back the same results.&lt;/p&gt;
&lt;p&gt;Okay, I think this is enough to take in for now. You have got a basic understanding of what full text search means, you know how to construct a vector containing lexemes, pointers and weights. You also know how to build a query data type and perform basic matching to retrieve the text you desire.&lt;/p&gt;
&lt;p&gt;In part 2 we will look at how we can dig deeper and setup our own full text search configuration.
We will cover fun stuff like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Looking deeper into PostgreSQL's guts&lt;/li&gt;
&lt;li&gt;Defining dictionaries&lt;/li&gt;
&lt;li&gt;Building Stop word lists&lt;/li&gt;
&lt;li&gt;Mapping token categories to our dictionaries&lt;/li&gt;
&lt;li&gt;Defining our own, super awesome full text configuration&lt;/li&gt;
&lt;li&gt;And, of course, more dolphin pun...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the last part we will break open yet another can of full text search goodness and look at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Creating special, full text search indexes&lt;/li&gt;
&lt;li&gt;Ranking search results&lt;/li&gt;
&lt;li&gt;Highlighting word inside search results&lt;/li&gt;
&lt;li&gt;Setting up update triggers for ts_vector records&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hang in there!&lt;/p&gt;
&lt;p&gt;And as always...thanks for reading!&lt;/p&gt;&lt;/div&gt;</description><category>full text search</category><category>postgresql</category><guid>http://shisaa.jp/postset/postgresql-full-text-search-part-1.html</guid><pubDate>Wed, 30 Apr 2014 14:00:00 GMT</pubDate></item></channel></rss>