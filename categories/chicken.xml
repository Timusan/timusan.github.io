<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>shisaa.jp (Posts about chicken)</title><link>http://shisaa.jp/</link><description></description><atom:link href="http://shisaa.jp/categories/chicken.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><copyright>Contents Â© 2017 &lt;a href="mailto:tim@shisaa.jp"&gt;Tim van der Linden&lt;/a&gt; </copyright><lastBuildDate>Sat, 17 Jun 2017 07:08:39 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>The Scheme programming language AKA The CHICKEN hens nest - Part 3</title><link>http://shisaa.jp/postset/chicken-scheme-3.html</link><dc:creator>Tim van der Linden</dc:creator><description>&lt;div&gt;&lt;h3&gt;Chapter 3 - Wrapping the egg&lt;/h3&gt;
&lt;p&gt;And here we arrive at the final stage of our egg development.&lt;/p&gt;
&lt;p&gt;If you did not yet do so, please go and read &lt;a href="http://shisaa.jp/postset/chicken-scheme-1.html" title="Chapter 1 of the CHICKEN series."&gt;chapter 1&lt;/a&gt; and &lt;a href="http://shisaa.jp/postset/chicken-scheme-2.html" title="Chapter 2 of the CHICKEN series."&gt;chapter 2&lt;/a&gt; before you endeavor on this final hop to a published egg in CHICKEN.&lt;/p&gt;
&lt;p&gt;Let us find out what we will be dealing with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Explain a little bit about &lt;em&gt;why the hell we need to write tests for our code&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Look at how we can actually write basic tests in CHICKEN&lt;/li&gt;
&lt;li&gt;While writing our tests, look at some new items like "let" and "apply"&lt;/li&gt;
&lt;li&gt;Create our setup file to automatically setup our egg when people install it&lt;/li&gt;
&lt;li&gt;Create the needed meta file for the CHICKEN egg system&lt;/li&gt;
&lt;li&gt;Create the release-info file for CHICKEN's code host independent deployment system &lt;/li&gt;
&lt;li&gt;Quickly compile and install our egg&lt;/li&gt;
&lt;li&gt;Submit the egg to CHICKEN&lt;/li&gt;
&lt;li&gt;Write the egg's documentation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You have got your battle axe ready? Then by all means...dive in!&lt;/p&gt;
&lt;h4&gt;Why tests?&lt;/h4&gt;
&lt;p&gt;First, let me explain to you the importance of writing tests for your code:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IT IS FRACKING IMPORTANT!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ahum...sorry, got carried away there for a bit...let me rephrase that:&lt;/p&gt;
&lt;p&gt;Writing tests is rather smart to do.&lt;/p&gt;
&lt;p&gt;Why?&lt;/p&gt;
&lt;p&gt;Well, it is actually a cultural thing inside a programmers mind or inside a community of programmers. Some (many) programmers find writing tests a cumbersome task, time consuming.&lt;/p&gt;
&lt;p&gt;Their train of thought usually runs past &lt;em&gt;Lazy Ville&lt;/em&gt; and stops at &lt;em&gt;I'm Freaking Awesome - Don't Need Tests&lt;/em&gt; station.&lt;/p&gt;
&lt;p&gt;Phrases you often hear are: "My code works, screw your tests!" or "I can test my code better then a computer can" or "I wanted to write tests, but then my cat sat on my keyboard, switched on YouTube and watched other cats do silly things. It was awesome so I decided to not write tests tonight...I will do that first thing in the morning &lt;small&gt;after washing the car, letting out my cat, putting out the garbage, reading my awesome Facebook page, ...&lt;/small&gt;".&lt;/p&gt;
&lt;p&gt;The problem, however, is that we are all stupid dumb ass bags of watery flesh. Thinking that we never make mistakes and therefor do not need sufficient testing of our work is downright ignorant and even arrogant. We &lt;em&gt;all&lt;/em&gt; suck at programming. Some of us less, some of us more. We humans have a tendency of slacking. We let our brains trick ourselves into thinking we always have the whole picture in our minds and therefor know what we are doing.&lt;/p&gt;
&lt;p&gt;In other engineering professions where folks build bridges or airplanes, there is a strong sense of not making the same mistake twice (and thus spare a life or two). People learn from mistakes made in the past and implement a huge amount of time and money into testing their work before releasing it to the public. Somehow, in the programming world we dwell in, we tend to neglect all of these values as if we are some kind of super humans. We are not.&lt;/p&gt;
&lt;p&gt;Good programmers implement the same engineering values as our neighboring colleagues: they learn from others mistakes and they test their work.&lt;/p&gt;
&lt;p&gt;Got it?&lt;/p&gt;
&lt;p&gt;Good...then let us write some tests!&lt;/p&gt;
&lt;h4&gt;Testing in CHICKEN&lt;/h4&gt;
&lt;p&gt;Because testing is so vital for every serious project, the CHICKEN community has put a lot of effort into making this as trivial as possible to setup.
Especially the work of &lt;a href="http://wiki.call-cc.org/users/alex-shinn" title="CHICKEN User page of Alex Shinn."&gt;Alex Shinn&lt;/a&gt; and  &lt;a href="http://wiki.call-cc.org/users/mario-domenech-goulart" title="CHICKEN User page of Mario Domenech Goulart."&gt;Mario Domenech Goulart&lt;/a&gt; made our CHICKEN testing lives a lot easier.&lt;/p&gt;
&lt;p&gt;Alex created an egg called "&lt;em&gt;Test&lt;/em&gt;" which gives us a bunch of handy procedures to easily write tests for our code. Mario has written an &lt;em&gt;immense&lt;/em&gt; egg neatly called "&lt;em&gt;Salmonella&lt;/em&gt;" that you can use to automatically test your egg. Once you submit your egg to CHICKEN, the server will run Salmonella automatically every night on all submitted eggs. It will generate a report that you can check at any time to see if you egg fails its tests.&lt;/p&gt;
&lt;p&gt;For my JSON-RPC egg I decided to write two different kind of tests:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A normal test where we tell CHICKEN which result we except with the given code&lt;/li&gt;
&lt;li&gt;An error test where we explicitly test if something throws an error&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let the writing commence!&lt;/p&gt;
&lt;p&gt;All of your tests go into one file called &lt;em&gt;run.scm&lt;/em&gt; and for Salmonella to find your tests that file has to be placed inside a directory of your egg called &lt;em&gt;tests&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In the &lt;em&gt;run.scm&lt;/em&gt; the first thing you have to put is a line that will actually load the test suite for you:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="nv"&gt;test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Next we need to load in our egg itself, since this is an external test file. Once your egg is compiled you can load it using the &lt;em&gt;use&lt;/em&gt; procedure like so:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="nv"&gt;json-rpc-client&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We can, of course, pull these two lines together to form:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="nv"&gt;test&lt;/span&gt; &lt;span class="nv"&gt;json-rpc-client&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This will not yet work since we still have to compile and install our egg. First, let us write the test file.&lt;/p&gt;
&lt;p&gt;When testing it is a good idea to divide your tests into groups so that the reports that will roll out later can group your tests to make everything more readable.
For this we can use &lt;em&gt;test-group&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-group&lt;/span&gt; &lt;span class="s"&gt;"A name for your group"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You define a name for the group and then list all the tests you would like to perform.
In my case, I would like to test if the JSON-RPC call I do gets formatted to correct JSON-RPC. Therefore I named my first group "JSON-RPC string output checks".
We will first concentrate on writing some tests and later wrap this group around them.&lt;/p&gt;
&lt;p&gt;A normal test is very easy to setup and uses easy to read syntax:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt; &lt;span class="s"&gt;"Description of the test"&lt;/span&gt; &lt;span class="s"&gt;"The result you want to see"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;procedure&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;test&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We start a test by using the "test" procedure and we give it a description.
Next we set the result that we &lt;em&gt;expect&lt;/em&gt; to see if our code is correct, this can be a string, a list, anything that could be returned.
Finally we call the to be tested procedure itself.&lt;/p&gt;
&lt;p&gt;We want to test that the final JSON-RPC string, that will be sent to the server, is correctly formatted.
Because during testing, we generally do not have access to a real JSON-RPC server to communicate with and thus cannot setup any real world ports to communicate, we need to setup a different kind of port.
These kind of ports are called &lt;em&gt;string ports&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An &lt;em&gt;input&lt;/em&gt; string port holds a string that you define&lt;/li&gt;
&lt;li&gt;An &lt;em&gt;output&lt;/em&gt; string port captures strings written to it that you can read out&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once we have these string ports setup we can use it to catch the string that normally would be send to a JSON-RPC server and compare it with a string we defined.
Before testing, we have to define the ports and setup the JSON-RPC connection, in our case called "xbmc":&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;open-input-string&lt;/span&gt; &lt;span class="s"&gt;"some-string"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;open-output-string&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;xbmc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now we can throw something at the simulated server and check how it comes out the other end:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;xbmc&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt; &lt;span class="s"&gt;"Call with only a method"&lt;/span&gt; &lt;span class="s"&gt;"{\"jsonrpc\":\"2.0\",\"method\":\"Player.PlayPause\",\"id\":\"1\"}"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-output-string&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We call "xbmc" with only a method. Then we call "test", give it a description, give the string we are expecting and finally read out the output port that our xbmc call used with the build in "get-output-string" procedure.&lt;/p&gt;
&lt;p&gt;While this test works fine, the whole is not very flexible.
Let me illustrate this by showing you what happens when we create a second test in our "run.scm" file:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;xbmc&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt; &lt;span class="nv"&gt;playerid:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt; &lt;span class="s"&gt;"Call with a method and a one dimensional params"&lt;/span&gt; &lt;span class="s"&gt;"{\"jsonrpc\":\"2.0\",\"method\":\"Player.PlayPause\",\"params\":{\"playerid\":0},\"id\":\"1\"}"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-output-string&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;With this test, we not only check the method, but we also give a param and check how that turns out. This is also a perfectly legal and sensible test.&lt;/p&gt;
&lt;p&gt;The problem here is that the &lt;em&gt;output&lt;/em&gt; port we defined above will contain both the output of the first &lt;em&gt;and&lt;/em&gt; the second test. It is a characteristic of the string output port that it will accumulate the strings that it receives. So when we read from that port we will again receive the result of the first test followed by the result of the second test, which is the one we are actually interested in.&lt;/p&gt;
&lt;p&gt;This, of course, means that our second test will fail, because the string comparison will be #f (false).&lt;/p&gt;
&lt;p&gt;To solve this problem, we need to create our own little test procedure specifically tailored for our JSON-RPC server. This procedure will just be a small wrapper around the normal "test" procedure, but will take care of the accumulating output port problem described above. Let me present the code to you:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="nv"&gt;description&lt;/span&gt; &lt;span class="nv"&gt;expected&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;output&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;open-output-string&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt;
            &lt;span class="nv"&gt;message&lt;/span&gt;
            &lt;span class="nv"&gt;expected&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-output-string&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Okay, there are some new things in here, so let us break this down line by line.&lt;/p&gt;
&lt;p&gt;The first line:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="nv"&gt;description&lt;/span&gt; &lt;span class="nv"&gt;expected&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This is nothing new, we define a new procedure called "test-server" which takes three mandatory and one optional argument.
The first argument will be the description we print in our test report, the second argument is the "datum" we except.
The third and fourth arguments are the familiar method and optional params we use in our testing.&lt;/p&gt;
&lt;p&gt;Next line:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;output&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;open-output-string&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Here we have a new "thing" in sight: &lt;em&gt;let&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;"Let" is actually not a procedure, but a "special form" that is quite commonly used when programming in CHICKEN and is needed for &lt;em&gt;local scoping&lt;/em&gt; of your variables.
The difference between procedures and special forms is (way) beyond the scope of this chapter, just know there is a difference between the two.&lt;/p&gt;
&lt;h5&gt;Local scoping?&lt;/h5&gt;
&lt;p&gt;In almost all programming languages you have a concept called &lt;em&gt;"scoping"&lt;/em&gt; and it is nothing more then the name suggests. It is the process of keeping parts of your code (variables, procedures, ...)  "hidden" from other parts of your code. When you scope variables, you make them available to only a certain part of your program. Other parts of your code do not even know that those variables exists and thus cannot read or overwrite them.&lt;/p&gt;
&lt;p&gt;In CHICKEN, and most other Scheme languages, "let" will do that job for you. How does "let" work? Simple:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;(let ((foo "a local string")
      (bar "another local string"))
     (cons foo bar))
&lt;/pre&gt;


&lt;p&gt;In a "let" you have to define your local variables first, in our case "foo" and "bar". These definitions form the first argument.
The second argument to "let" is the procedure body; the code that will be executed using your locally stored variables.
Code that resides outside of the "let" never knows the existence of these local variables "foo" and "bar".&lt;/p&gt;
&lt;p&gt;In our case, "let" can help us by making the output port a local one so that every time the "let" is called, a new output port will be created and thus will only contain one string at a time.&lt;/p&gt;
&lt;p&gt;The next line is the start of the body of the "let":&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Here we encounter yet another new player in town: &lt;em&gt;"apply"&lt;/em&gt;. This procedure takes an "infinite" amount of arguments; the first always being a procedure and the rest being arguments that the procedure we be applied upon. A very important thing to note about the arguments is that the last argument &lt;em&gt;has&lt;/em&gt; to be a list, otherwise "apply" does not work.&lt;/p&gt;
&lt;p&gt;"Apply" will cons the arguments you put in between its first and last argument onto the last argument, before calling the given procedure with those arguments. Let me demonstrate:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="nv"&gt;some-procedure&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now "apply" simply has two arguments, a fictional procedure called "some-procedure" and a list of three arguments '(1 2 3). It is allowed to put additional arguments &lt;em&gt;between&lt;/em&gt; the two given here:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="nv"&gt;some-procedure&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now three extra arguments will be placed in between the original procedure and the original, last argument '(1 2 3). "Apply" will first cons every argument onto the last list given:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="nv"&gt;some-procedure&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Then it will take that list and call the procedure with every item, as if it where the actual arguments to that function.&lt;/p&gt;
&lt;p&gt;In our case, we have the procedure "json-rpc-server" with its own arguments, one of which is the locally scoped output port. Because this procedure will return a lambda expecting a method and optional params, we can use "apply" to give these arguments to this returned lambda. "Apply" will in turn return the result of the lambda with the method and params applied.&lt;/p&gt;
&lt;p&gt;Next we have the rest of our "let" body:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt;
    &lt;span class="nv"&gt;description&lt;/span&gt;
    &lt;span class="nv"&gt;expected&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-output-string&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Here we simply do what we did before: we call the "test" procedure, give it a description, tell it what we expect to get and finally read out the local output string port to compare with.&lt;/p&gt;
&lt;p&gt;Let us use this newly created procedure in our test:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="s"&gt;"Call with only a method"&lt;/span&gt; &lt;span class="s"&gt;"{\"jsonrpc\":\"2.0\",\"method\":\"Player.PlayPause\",\"id\":\"1\"}"&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now we have a piece of code that is a little bit more readable and tailored to our JSON-RPC egg:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We call the test-server procedure&lt;/li&gt;
&lt;li&gt;First argument is just a description of what we will be testing&lt;/li&gt;
&lt;li&gt;Second is the string we expect to get&lt;/li&gt;
&lt;li&gt;Last is, in this case, the method we want to test our "json-rpc-server" procedure with&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One more thing to note is the escaping that you may have noticed in the string we expect. Because a double quote " means something in CHICKEN (it wraps a string) we need to escape it inside the string by using a backslash. The JSON-RPC valid JSON string we use here normally looks like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nt"&gt;"jsonrpc"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;"method"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;"id"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;"1"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And with the double quotes escaped in a CHICKEN string becomes this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"{\"jsonrpc\":\"2.0\",\"method\":\"Player.PlayPause\",\"id\":\"1\"}"&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now we have a valid test for the case where we call our procedure with only a method. Let us now write one with a method and a single param:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="s"&gt;"Call with a method and a one dimensional params"&lt;/span&gt; &lt;span class="s"&gt;"{\"jsonrpc\":\"2.0\",\"method\":\"Player.PlayPause\",\"params\":{\"playerid\":0},\"id\":\"1\"}"&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt; &lt;span class="nv"&gt;playerid:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Nothing strange happening here. We give it a different description of course, and we expect a different string, including params this time. And at the end we, of course, include a param in there.&lt;/p&gt;
&lt;p&gt;Let us now put these two tests in a group, like we said we would do a moment ago:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-group&lt;/span&gt; &lt;span class="s"&gt;"JSON-RPC string output checks"&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="s"&gt;"Call with only a method"&lt;/span&gt; &lt;span class="s"&gt;"{\"jsonrpc\":\"2.0\",\"method\":\"Player.PlayPause\",\"id\":\"1\"}"&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="s"&gt;"Call with a method and a one dimensional params"&lt;/span&gt; &lt;span class="s"&gt;"{\"jsonrpc\":\"2.0\",\"method\":\"Player.PlayPause\",\"params\":{\"playerid\":0},\"id\":\"1\"}"&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt; &lt;span class="nv"&gt;playerid:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;There, this does not look scary, right? We have a test group called "JSON-RPC string output checks" containing the two tests we just have written.&lt;/p&gt;
&lt;p&gt;You know what? That is all there is to basic testing. We have just written a few simple tests to verify the whole purpose of the JSON-RPC client side egg.&lt;/p&gt;
&lt;p&gt;The full code that we have in our "run.scm" up until now looks like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="nv"&gt;test&lt;/span&gt; &lt;span class="nv"&gt;json-rpc-client&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;open-input-string&lt;/span&gt; &lt;span class="s"&gt;"just-a-test-string"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;open-output-string&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;xbmc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="nv"&gt;description&lt;/span&gt; &lt;span class="nv"&gt;expected&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;output&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;open-output-string&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt;
            &lt;span class="nv"&gt;description&lt;/span&gt;
            &lt;span class="nv"&gt;expected&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-output-string&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-group&lt;/span&gt; &lt;span class="s"&gt;"JSON-RPC string output checks"&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="s"&gt;"Call with only a method"&lt;/span&gt; &lt;span class="s"&gt;"{\"jsonrpc\":\"2.0\",\"method\":\"Player.PlayPause\",\"id\":\"1\"}"&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="s"&gt;"Call with a method and a one dimensional params"&lt;/span&gt; &lt;span class="s"&gt;"{\"jsonrpc\":\"2.0\",\"method\":\"Player.PlayPause\",\"params\":{\"playerid\":0},\"id\":\"1\"}"&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt; &lt;span class="nv"&gt;playerid:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;A few things to note about the above snippet:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We use "use" in the beginning, but this does not work yet until we actually compile and install our egg.&lt;/li&gt;
&lt;li&gt;We define a &lt;em&gt;global&lt;/em&gt; input and output port plus a JSON-RPC connection called xbmc, we will need this later on.&lt;/li&gt;
&lt;li&gt;The input port we defined globally is used in our "test-server" procedure, but the output port is locally scoped in that same procedure.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The next kind of tests we want to write are error tests. This sort of test does exactly what you would expect, test if something gives an error.
In our case we need these kind of tests to see if our error handlers work correctly.&lt;/p&gt;
&lt;p&gt;The first error handler we wrote is the one for our main "json-rpc-server" procedure. So to write an error test for this, we simply have to do an erroneous call.
If we recall our "json-rpc-server" procedure we need three things to correctly setup the connection:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A valid input port&lt;/li&gt;
&lt;li&gt;A valid output port&lt;/li&gt;
&lt;li&gt;A correct version number (a string that equals "2.0")&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we would like to test if it fails when we use a faulty input port, we would write the test like so:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-error&lt;/span&gt; &lt;span class="s"&gt;"Non port call on input"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="s"&gt;"input"&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The syntax looks quite familiar. We call the procedure "test-error" instead of "test" and give it a description. Then we simply call our procedure with some kind of error in it.
In this case we give the string &lt;em&gt;"input"&lt;/em&gt; instead of the defined variable &lt;em&gt;input&lt;/em&gt;. This string is not a valid input port of course, so our error handler fires and we get an error.
Getting an error in this case means that the test will pass!&lt;/p&gt;
&lt;p&gt;In my test I include some more error checks:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-error&lt;/span&gt; &lt;span class="s"&gt;"Non port call on output"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="s"&gt;"output"&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-error&lt;/span&gt; &lt;span class="s"&gt;"Non correct version number call"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"3.0"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And of course, this can become a group, giving you this code:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-group&lt;/span&gt; &lt;span class="s"&gt;"Non-port or non-version calls"&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-error&lt;/span&gt; &lt;span class="s"&gt;"Non port call on input"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="s"&gt;"input"&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-error&lt;/span&gt; &lt;span class="s"&gt;"Non port call on output"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="s"&gt;"output"&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-error&lt;/span&gt; &lt;span class="s"&gt;"Non correct version number call"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"3.0"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;A tricky thing to note about error tests is that &lt;em&gt;any&lt;/em&gt; kind of failure will make the test pass. This can be very misleading because even real errors in your code can cause a failure to occur and the test to pass. To more correctly setup these error tests, I should also check if the error I get back is of the custom type I defined specifically for the JSON-RPC egg. This way I know for sure that it is &lt;em&gt;my&lt;/em&gt; custom error handler that raises the situation, and not something else. But that kind of setup is beyond the scope of this chapter. For now just remember to be careful when writing error tests.&lt;/p&gt;
&lt;p&gt;A very important last step in your "run.scm" file is to end the file with the following code:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-exit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;If you omit this line the automated tests on the server will fail, so it is vital you end your file with this one.&lt;/p&gt;
&lt;p&gt;Good, we finished writing our tests!&lt;/p&gt;
&lt;p&gt;To recapitulate, here is the total code we have written so far:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="nv"&gt;test&lt;/span&gt; &lt;span class="nv"&gt;json-rpc-client&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;open-input-string&lt;/span&gt; &lt;span class="s"&gt;"some-string"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;open-output-string&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;xbmc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="nv"&gt;description&lt;/span&gt; &lt;span class="nv"&gt;expected&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;output&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;open-output-string&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt;
            &lt;span class="nv"&gt;description&lt;/span&gt;
            &lt;span class="nv"&gt;expected&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-output-string&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-group&lt;/span&gt; &lt;span class="s"&gt;"JSON-RPC string output checks"&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="s"&gt;"Call with only a method"&lt;/span&gt; &lt;span class="s"&gt;"{\"jsonrpc\":\"2.0\",\"method\":\"Player.PlayPause\",\"id\":\"1\"}"&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-server&lt;/span&gt; &lt;span class="s"&gt;"Call with a method and a one dimensional params"&lt;/span&gt; &lt;span class="s"&gt;"{\"jsonrpc\":\"2.0\",\"method\":\"Player.PlayPause\",\"params\":{\"playerid\":0},\"id\":\"1\"}"&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt; &lt;span class="nv"&gt;playerid:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-group&lt;/span&gt; &lt;span class="s"&gt;"Non-port or non-version calls"&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-error&lt;/span&gt; &lt;span class="s"&gt;"Non port call on input"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="s"&gt;"input"&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-error&lt;/span&gt; &lt;span class="s"&gt;"Non port call on output"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="s"&gt;"output"&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-error&lt;/span&gt; &lt;span class="s"&gt;"Non correct version number call"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="s"&gt;"3.0"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-exit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;But before we can run our tests, we first have to build some extra files that in total will define our egg and make it able to be compiled.&lt;/p&gt;
&lt;h4&gt;The setup file&lt;/h4&gt;
&lt;p&gt;file: &lt;em&gt;"json-rpc.setup"&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This file mainly contains information for the compiler and for the CHICKEN install system. Check the &lt;a href="http://wiki.call-cc.org/eggs%20tutorial#the-setup-file" title="Setup file wiki page on CHICKEN."&gt;wiki page&lt;/a&gt; for more information.&lt;/p&gt;
&lt;p&gt;The JSON-RPC eggs setup file looks like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;compile&lt;/span&gt; &lt;span class="nv"&gt;-s&lt;/span&gt; &lt;span class="nv"&gt;-O2&lt;/span&gt; &lt;span class="nv"&gt;-d1&lt;/span&gt; &lt;span class="nv"&gt;json-rpc-client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;scm&lt;/span&gt; &lt;span class="nv"&gt;-j&lt;/span&gt; &lt;span class="nv"&gt;json-rpc-client&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;compile&lt;/span&gt; &lt;span class="nv"&gt;-s&lt;/span&gt; &lt;span class="nv"&gt;json-rpc-client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;import&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;scm&lt;/span&gt; &lt;span class="nv"&gt;-O2&lt;/span&gt; &lt;span class="nv"&gt;-d0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;install-extension&lt;/span&gt;
    &lt;span class="ss"&gt;'json-rpc&lt;/span&gt;
    &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"json-rpc-client.so"&lt;/span&gt; &lt;span class="s"&gt;"json-rpc-client.import.so"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"0.1.4"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;documentation&lt;/span&gt; &lt;span class="s"&gt;"json-rpc.html"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The first two lines are the lines the compiler will use to compile your "scm" files into actual raw C code.
The top line contains the CHICKEN file we have been working on in chapter one and two. The flags that are set here are a sensible default, what they mean is beyond the scope of these posts. You can, in most cases, just use these flags as is.&lt;/p&gt;
&lt;p&gt;The second line contains a CHICKEN file called "json-rpc-client.import.scm" which we did not create but which will be automatically created for you.
This file will contain information for the CHICKEN module system and also needs to be compiled to C.&lt;/p&gt;
&lt;p&gt;The rest of the file is occupied by a list containing some meta data about your egg. Let me break this down for you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;'json-rpc - This is the actual name of your egg&lt;/li&gt;
&lt;li&gt;'("json-rpc-client.so" "json-rpc-client.import.so") - Will be the compiled files, the two CHICKEN file we mentioned above, but just with the extension "so" instead of "scm"&lt;/li&gt;
&lt;li&gt;'(version "0.1.4") - The version that you wish to compile. Every time you update the version you should &lt;em&gt;change&lt;/em&gt; this here as well&lt;/li&gt;
&lt;li&gt;'(documentation "json-rpc.html") - The place where CHICKEN can find your documentation. I have placed my documentation on the CHICKEN Wiki, which is the standard. If you place it on the wiki, all you need to do is to put the name of you egg (in this case "json-rpc") with the extension ".html" in there. Next it is important to also actually create that page on the wiki. We will do this in a bit.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The meta file&lt;/h4&gt;
&lt;p&gt;file: &lt;em&gt;"json-rpc.meta"&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The meta file contains all kinds of information related to your egg. This information will later be displayed on the CHICKEN egg pages. Check the &lt;a href="http://wiki.call-cc.org/eggs%20tutorial#the-meta-file" title="Meta file wiki page on CHICKEN."&gt;wiki page&lt;/a&gt; for more information.
In the case of my JSON-RPC egg I input the following information:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;egg&lt;/span&gt; &lt;span class="s"&gt;"json-rpc.egg"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;synopsis&lt;/span&gt; &lt;span class="s"&gt;"JSON RPC client/server implementation"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;category&lt;/span&gt; &lt;span class="nv"&gt;web&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;needs&lt;/span&gt; &lt;span class="nv"&gt;medea&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test-depends&lt;/span&gt; &lt;span class="nv"&gt;test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;doc-from-wiki&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;license&lt;/span&gt; &lt;span class="s"&gt;"BSD"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;author&lt;/span&gt; &lt;span class="s"&gt;"Tim van der Linden"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Let us go over them:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Give the eggs name, together with the extension ".egg"&lt;/li&gt;
&lt;li&gt;Write a short synopsis about the function of your egg&lt;/li&gt;
&lt;li&gt;Say which category the eggs belongs to. The different categories are listed &lt;a href="http://wiki.call-cc.org/eggs%20tutorial#the-setup-file" title="Egg categories wiki page on CHICKEN."&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tell CHICKEN which &lt;em&gt;non-core&lt;/em&gt; dependencies your egg has. In the case of the JSON-RPC egg, we have "srfi-1", "medea" and "extras", but only "medea" is a non-core dependency.&lt;/li&gt;
&lt;li&gt;Give the type of documentation you have. If your documentation resides on the CHICKEN Wiki, you need to put this line in&lt;/li&gt;
&lt;li&gt;Tell about the license you have included in your ".scm" files&lt;/li&gt;
&lt;li&gt;Tell them who the author is&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That is all that goes in the meta file, save and close it.&lt;/p&gt;
&lt;h4&gt;The release-info file&lt;/h4&gt;
&lt;p&gt;file: &lt;em&gt;"release-info"&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;CHICKEN has the unique ability to be totally code host independent.&lt;/p&gt;
&lt;p&gt;You can put your code on CHICKEN's own SVN repositories or on your favorite code hosting site and the CHICKEN egg server will pull all information from there.
The "release-info" file contains information about where your code is hosted and which version numbers you have available.
Even when your third party code host is down, CHICKEN still has a local copy of the latest available version of your egg, so people installing your egg can still continue their development.&lt;/p&gt;
&lt;p&gt;Depending on which code hosting site you use there are different settings you ave to configure. There is an &lt;a href="http://wiki.call-cc.org/releasing-your-egg#creating-a-release-info-file" title="Release-info file creation on the CHICKEN wiki."&gt;extensive page&lt;/a&gt; about how to setup your release-info for your code host.&lt;/p&gt;
&lt;p&gt;I personally resent the hype around GIT (among other things) and chose Mercurial as my version control system and Bitbucket as my host. So the settings in the release-info file became:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;repo&lt;/span&gt; &lt;span class="nv"&gt;hg&lt;/span&gt; &lt;span class="s"&gt;"https://bitbucket.org/Timusan/{egg-name}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;uri&lt;/span&gt; &lt;span class="nv"&gt;targz&lt;/span&gt; &lt;span class="s"&gt;"https://bitbucket.org/Timusan/{egg-name}/get/{egg-release}.tar.gz"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;release&lt;/span&gt; &lt;span class="s"&gt;"0.1"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;release&lt;/span&gt; &lt;span class="s"&gt;"0.1.1"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;What is means:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first line is the url to the eggs main location&lt;/li&gt;
&lt;li&gt;Then we have the url to the gzipped tar files for each egg release I make (using Mercurial tags)&lt;/li&gt;
&lt;li&gt;And finally we have the different versions listed that are released&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Doing a test install&lt;/h4&gt;
&lt;p&gt;Okay, we now have the correct environment to install our egg via the &lt;em&gt;chicken-install&lt;/em&gt; command we used in chapter one.
Make sure you are in the main directory of your egg and that you are root. Then simply call "chicken-install" without any arguments:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ chicken-install
&lt;/pre&gt;


&lt;p&gt;Or if you do not want to become root, simply use the "-s" switch to temporarily sudo the install:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ chicken-install -s
&lt;/pre&gt;


&lt;p&gt;The installer will now look in the current directory for all the needed files and install your egg.&lt;/p&gt;
&lt;p&gt;If all went well you will have some compiler output and your egg is compiled and installed in your local CHICKEN ecosystem.
This means you can now run your tests!&lt;/p&gt;
&lt;p&gt;You can either run "Salmonella" that will not only run your "run.scm" tests file, but also will do checks on the availability of the documentation among other things.
Since our egg is not published yet, those checks would fail. But by simply running the "run.scm" file by itself, we can run our tests without anything interfering.&lt;/p&gt;
&lt;p&gt;So go into your "tests" directory and run your CHICKEN file with "csi":&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ csi run.scm
&lt;/pre&gt;


&lt;p&gt;CHICKEN will now print a neat little report with the results of our tests. Cool!&lt;/p&gt;
&lt;h4&gt;Publishing &amp;amp; Documentation&lt;/h4&gt;
&lt;p&gt;You now what? You are ready!&lt;/p&gt;
&lt;p&gt;The only thing left for you to do now is to first commit your code to your favorite code hosting site, then announce the existence of your egg and finally write the documentation for it.&lt;/p&gt;
&lt;p&gt;Before you can finally publish your egg for the world to see, you &lt;em&gt;have&lt;/em&gt; to write some form of documentation.
Since it is common to write the documentation on the CHICKEN Wiki itself, you will first have to ask for an account so you can properly access the Wiki.&lt;/p&gt;
&lt;p&gt;After committing your code, send an email to the &lt;a href="https://lists.nongnu.org/mailman/listinfo/chicken-users" title="The CHICKEN Users mailing list."&gt;CHICKEN Users&lt;/a&gt; mailing list with the location to your egg so the CHICKEN peeps can add your egg into the system.&lt;/p&gt;
&lt;p&gt;Your account details are best mailed to the private address of &lt;a href="http://wiki.call-cc.org/users/mario-domenech-goulart" title="CHICKEN User page of Mario Domenech Goulart."&gt;Mario Domenech Goulart&lt;/a&gt;. Check out &lt;a href="http://wiki.call-cc.org/contribute" title="The CHICKEN egg contribute page."&gt;this&lt;/a&gt; page to find out his email. Mail him your desired user name and your hashed password. To generate the hash for your password, use the "OpenSSL" program:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;$ openssl passwd -apr1 your-password-here
&lt;/pre&gt;


&lt;p&gt;Once you get confirmation of your account creation, you can start writing.&lt;/p&gt;
&lt;p&gt;The way this is usually done is to create a page on the Wiki with the same name as your egg.
For the JSON-RPC egg, this would be:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;http://wiki.call-cc.org/eggref/4/json-rpc
&lt;/pre&gt;


&lt;p&gt;Say, for the sake of exampling, that your eggs name is "foo-bar", you would surf to:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;http://wiki.call-cc.org/eggref/4/foo-bar
&lt;/pre&gt;


&lt;p&gt;The Wiki will tell you that that page does not exist, but it also gives you the chance to create it.
Create the page and be sure to authenticate with your fresh, new credentials when saving.&lt;/p&gt;
&lt;p&gt;To get inspiration on how to write the documentation for your egg, check out other contributors their documentation pages. Make sure that you always include the following items:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A clear description of your egg&lt;/li&gt;
&lt;li&gt;The name of the author&lt;/li&gt;
&lt;li&gt;The non-core dependencies your egg has&lt;/li&gt;
&lt;li&gt;A link to the external repository where you eggs code is hosted&lt;/li&gt;
&lt;li&gt;Documentation about the procedure the users of your egg can use&lt;/li&gt;
&lt;li&gt;Some real-world examples&lt;/li&gt;
&lt;li&gt;Version history&lt;/li&gt;
&lt;li&gt;A copy of the license you use&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The end&lt;/h4&gt;
&lt;p&gt;Okay, that is it folks, we have a working, tested and published egg!&lt;/p&gt;
&lt;p&gt;I hope this three chapter CHICKEN saga has brought you a little bit closer to CHICKEN or Scheme and that you can gradually find out the power behind this tiny language.&lt;/p&gt;
&lt;p&gt;Now go out and create some awesome eggs for the whole community to enjoy! And remember, if you run stuck, have questions or just want a little chat, there is a great CHICKEN community out there ready to help you out. &lt;/p&gt;
&lt;p&gt;And as always...thanks for reading!&lt;/p&gt;&lt;/div&gt;</description><category>chicken</category><category>json rpc</category><category>scheme</category><guid>http://shisaa.jp/postset/chicken-scheme-3.html</guid><pubDate>Sat, 21 Sep 2013 10:00:00 GMT</pubDate></item><item><title>The Scheme programming language AKA The CHICKEN hens nest - Part 2</title><link>http://shisaa.jp/postset/chicken-scheme-2.html</link><dc:creator>Tim van der Linden</dc:creator><description>&lt;div&gt;&lt;h3&gt;Chapter 2 - Laying the egg&lt;/h3&gt;
&lt;p&gt;Welcome to the second installment of this introduction into the CHICKEN programming language.&lt;/p&gt;
&lt;p&gt;If you haven't done so, I encourage you to go and read &lt;a href="http://shisaa.jp/postset/chicken-scheme-1.html" title="Chapter 1 of the CHICKEN series."&gt;chapter 1&lt;/a&gt; before you continue.&lt;/p&gt;
&lt;p&gt;In the first chapter we talked about the programming language CHICKEN, which is a Scheme implementation. To introduce you to this language I decided to guide you trough making your own egg.
This egg will become a translator to talk to a JSON-RPC server so you could send over commands and invoke remote procedure calls trough JSON right out of CHICKEN.&lt;/p&gt;
&lt;p&gt;I left you with the beginning of our main procedure called &lt;em&gt;json-rpc-server&lt;/em&gt; which would do two things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It would setup the connection to the server&lt;/li&gt;
&lt;li&gt;It would then be used to translate the commands into JSON and send them over&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before we dive in, let me give you a quick perspective of what we will be dealing with today:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create an exception handler for the arguments of the lambda&lt;/li&gt;
&lt;li&gt;See how we can abstract out positional and named params in the arguments&lt;/li&gt;
&lt;li&gt;Build the actual list that will hold the CHICKEN JSON-RPC request object we wish to send&lt;/li&gt;
&lt;li&gt;While building this, we can see a little bit about proper and improper lists&lt;/li&gt;
&lt;li&gt;Still while building, we can also dive into recursion in CHICKEN for building the params list&lt;/li&gt;
&lt;li&gt;After the request object is build, actually send it over to Medea&lt;/li&gt;
&lt;li&gt;Make sure we export only the needed procedures&lt;/li&gt;
&lt;li&gt;Setting the correct license for our egg&lt;/li&gt;
&lt;li&gt;Take a small peek at what lies ahead in chapter three.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Let us dive in!&lt;/h4&gt;
&lt;p&gt;We where busy writing the second part of our procedure. Once the connection was setup we would return a &lt;em&gt;lambda&lt;/em&gt; or &lt;em&gt;anonymous procedure&lt;/em&gt; to the user which she or he could then use to send commands with.
This is how we left our procedure:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;!key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"input port"&lt;/span&gt; &lt;span class="s"&gt;"input-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"output port"&lt;/span&gt; &lt;span class="s"&gt;"ouput-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-version?&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"version"&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;else&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you can see, we started to return a lambda that accepts two arguments: &lt;em&gt;method&lt;/em&gt; and &lt;em&gt;params&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As we have seen in the previous chapter, params are &lt;em&gt;optional&lt;/em&gt;. We thus want them to be optional too in our CHICKEN implementation.
To give optional arguments to a procedure we can use the &lt;em&gt;dot notation&lt;/em&gt;: everything left of the dot is required and right of the dot is optional.&lt;/p&gt;
&lt;p&gt;And as you remember from the first chapter, we have to help the user when they input wrong information. In this case it means we have to check two arguments. But since both method and params are completely custom to our egg, we will have to build the predicates ourselves and then build a custom exception handler that will inform the user about her or his mistake.&lt;/p&gt;
&lt;p&gt;We know that the "method" argument must be a string, so the first predicate is quite simple:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-method?&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;string? &lt;/span&gt;&lt;span class="nv"&gt;method&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The "params" argument is a little bit different. Since we are implementing JSON-RPC in CHICKEN, we have the chance of also making some aspects more abstract, more easy to use.
As we have seen in the JSON-RPC spec, params can be &lt;em&gt;positional&lt;/em&gt;, which in CHICKEN becomes a &lt;em&gt;vector&lt;/em&gt; or they can be &lt;em&gt;named&lt;/em&gt; which is an &lt;em&gt;alist&lt;/em&gt;.
So we could opt for the situation where the user has to input either an alist or a vector as a "params" argument, or we could try and find a more simple way of input.&lt;/p&gt;
&lt;p&gt;I chose the latter and opted to let the user either input &lt;em&gt;symbol arguments&lt;/em&gt; (positional params) or &lt;em&gt;keyword arguments&lt;/em&gt; (named params):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;'these&lt;/span&gt; &lt;span class="ss"&gt;'are&lt;/span&gt; &lt;span class="ss"&gt;'five&lt;/span&gt; &lt;span class="ss"&gt;'positional&lt;/span&gt; &lt;span class="ss"&gt;'params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;;symbols&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;these:&lt;/span&gt; &lt;span class="nv"&gt;are&lt;/span&gt; &lt;span class="nv"&gt;keyword:&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;;keywords&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Inside the procedure body which implements the params, both keywords and symbols become lists we can use, just as the example above.
So to make the predicate for checking valid params input the only thing we really have to do is to check if the given params are a list.
Even when we do not give any params, they will be considered &lt;em&gt;null&lt;/em&gt;. And as we have seen in the previous chapter, &lt;em&gt;null&lt;/em&gt; in CHICKEN is the same as the &lt;em&gt;empty list&lt;/em&gt; or &lt;em&gt;'()&lt;/em&gt;, which, of course, is also a list!&lt;/p&gt;
&lt;p&gt;Cool, right?&lt;/p&gt;
&lt;p&gt;So our params predicate would look like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;are-valid-params?&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Next we have to make a new exception handler. This one we will call &lt;em&gt;server-setup-data-error&lt;/em&gt; and it will be called if one of the predicates fail or in other words, when the method or the params are invalid:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-data-error&lt;/span&gt; &lt;span class="nv"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;signal&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-property-condition&lt;/span&gt;
      &lt;span class="ss"&gt;'exn&lt;/span&gt; &lt;span class="ss"&gt;'message&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sprintf&lt;/span&gt; &lt;span class="s"&gt;"Cannot setup connection, the given ~S data is invalid. The ~S ~A"&lt;/span&gt;
      &lt;span class="nv"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;message&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Looks quite the same as the first one we wrote in chapter 1, no?&lt;/p&gt;
&lt;p&gt;The only difference is the message we print and the arguments we give to this procedure.
We can now implement the predicates and the exception handling the same way we did before, so this becomes:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;!key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"input port"&lt;/span&gt; &lt;span class="s"&gt;"input-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"output port"&lt;/span&gt; &lt;span class="s"&gt;"ouput-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-version?&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"version"&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;else&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-method?&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-data-error&lt;/span&gt; &lt;span class="s"&gt;"method"&lt;/span&gt; &lt;span class="s"&gt;"can only be a string."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                    &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;are-valid-params?&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-data-error&lt;/span&gt; &lt;span class="s"&gt;"params"&lt;/span&gt; &lt;span class="s"&gt;"can only be a vector or an alist."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;I also added the &lt;em&gt;else&lt;/em&gt; statement at the end which will carry the code that will be executed when the given arguments are correct.&lt;/p&gt;
&lt;p&gt;What's next?&lt;/p&gt;
&lt;p&gt;We now have to start looking at actually building the JSON-RPC request object in CHICKEN and sending it to server.
First let us concentrate on the building part:&lt;/p&gt;
&lt;h4&gt;Building the request object&lt;/h4&gt;
&lt;p&gt;Let us assume that we already finished our egg and we define a connection to the "XBMC" box I described in the first chapter, we would call our &lt;em&gt;json-rpc-server&lt;/em&gt; procedure as follows (assuming we have a valid input-port and output-port):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;xbmc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;When we now call "xbmc" we will get a new procedure (the lambda we are writing now) that excepts a method and optional params.
Given the example from chapter 1 (Player.PlayPause), let us see how we would call "xbmc" to send this to the server:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;xbmc&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt; &lt;span class="nv"&gt;playerid:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;&lt;em&gt;Player.PlayPause&lt;/em&gt; is the method, which is a string and &lt;em&gt;playerid: 0&lt;/em&gt; is a &lt;em&gt;keyword&lt;/em&gt; param where &lt;em&gt;playerid:&lt;/em&gt; is the keyword and &lt;em&gt;0&lt;/em&gt; the value of that keyword.
We now have to write the code that will take that and turn it into this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;params&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;playerid&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The above code is a list, so we can also say that we want to &lt;em&gt;build&lt;/em&gt; a list containing the &lt;em&gt;"Player.PlayPause"&lt;/em&gt; and &lt;em&gt;playerid: 0&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In chapter one we have seen that the &lt;em&gt;jsonrpc&lt;/em&gt; version is always &lt;em&gt;2.0&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;On top of that, we can always keep the &lt;em&gt;id&lt;/em&gt; at a fixed number.&lt;/p&gt;
&lt;p&gt;The reasoning behind the &lt;em&gt;id&lt;/em&gt; in a JSON-RPC call is that the server can use the same &lt;em&gt;id&lt;/em&gt; in its &lt;em&gt;response&lt;/em&gt; or &lt;em&gt;error&lt;/em&gt; object it returns so you know the server's feedback belongs to your &lt;em&gt;request&lt;/em&gt;. But because we only send one request at a time, it is overkill to generate a unique &lt;em&gt;id&lt;/em&gt; for each &lt;em&gt;request&lt;/em&gt; we send. In our egg, we will keep this &lt;em&gt;id&lt;/em&gt; at &lt;em&gt;1&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Let us concentrate on building the request object from only the &lt;em&gt;version&lt;/em&gt; and the &lt;em&gt;id&lt;/em&gt; for now. The &lt;em&gt;method&lt;/em&gt; and the &lt;em&gt;params&lt;/em&gt; will need some further attention later on.&lt;/p&gt;
&lt;p&gt;So the first thing we encounter in the &lt;em&gt;s-expression&lt;/em&gt; above is the &lt;em&gt;cons cell&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The "version" is an argument to the "json-rpc-server procedure", so to create this cons cell we can use &lt;em&gt;cons&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Mind the &lt;em&gt;'&lt;/em&gt; or &lt;em&gt;quote&lt;/em&gt; before "jsonrpc". This is needed for otherwise CHICKEN will see this as &lt;em&gt;code&lt;/em&gt; instead of &lt;em&gt;data&lt;/em&gt; and try to execute it.
The last cons cell is our "id", the same idea applies here:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Again, mind the &lt;em&gt;'&lt;/em&gt; in front of "id". We use the &lt;em&gt;number&lt;/em&gt; 1 here without any quoting because we want CHICKEN to treat this as an actual &lt;em&gt;number&lt;/em&gt; data type and not as a &lt;em&gt;symbol&lt;/em&gt; or &lt;em&gt;string&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;How can we put these two &lt;em&gt;cons cells&lt;/em&gt; together?&lt;/p&gt;
&lt;p&gt;Let us try it with cons and see what happens. Remember that cons only accepts two arguments and &lt;em&gt;conses&lt;/em&gt; them on to each other. So if we want to put the two cons cells together, it will look something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This code will result in:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Hmm, that is not really what we want, is it? It has now become a list containing one &lt;em&gt;cons cell&lt;/em&gt; and two &lt;em&gt;atoms&lt;/em&gt; separated by a dot.
Why is this happening and why do we not get the following code?&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Good question, the answer is: You have just created an &lt;em&gt;improper list&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Improper list?&lt;/p&gt;
&lt;p&gt;To explain this we have to take another look at the primitive &lt;em&gt;cons&lt;/em&gt; procedure we saw in chapter 1. There we learned that &lt;em&gt;cons&lt;/em&gt; is used to &lt;em&gt;cons&lt;/em&gt;truct pairs, just as we did above. And with pairs, we can eventually construct &lt;em&gt;lists&lt;/em&gt;. But there was also one important detail we saw, the &lt;em&gt;null&lt;/em&gt;, &lt;em&gt;'()&lt;/em&gt; or &lt;em&gt;the empty list&lt;/em&gt;. I showed you that when we look at a list, we are actually looking at cons cells and the last item in the list is actually a cons cell that contains the empty list at the end. You do not &lt;em&gt;see&lt;/em&gt; the empty list, but it is there.&lt;/p&gt;
&lt;p&gt;An improper list, as opposed to a proper list, does &lt;em&gt;not&lt;/em&gt; end in the empty list. In the example above, we ended with the cons cell:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This is considered wrong, it is even said that an improper list is not a list at all. To turn this into a proper list, we simply have to add the empty list into our consing adventure:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And this will give as a proper list and thus the result we are after:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Nice!&lt;/p&gt;
&lt;p&gt;There is one annoying thing about building lists this way: its verbose. Luckily for us, CHICKEN has a shorthand for building lists, amazingly called &lt;em&gt;list&lt;/em&gt;.
The above example would thus be translated to:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;That is a little bit less to type, and maybe even more easy to read. The procedure &lt;em&gt;list&lt;/em&gt; can take an infinite amount of arguments and construct a proper list for you which means that it will always automatically add the &lt;em&gt;empty list&lt;/em&gt; at the end.&lt;/p&gt;
&lt;p&gt;Let us now take this one step further and include a &lt;em&gt;method&lt;/em&gt; in our construction. If we would use &lt;em&gt;cons&lt;/em&gt;, the construction would look like this&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'method&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And if we used &lt;em&gt;list&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'method&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Both approaches give us:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You are of course free to choose if you want to use "cons" or "list", the take-home message here is that you know &lt;em&gt;how&lt;/em&gt; to cons together a proper list and that you understand how "list" will create a &lt;em&gt;proper list&lt;/em&gt; for you by adding the empty list at the final cons cell.&lt;/p&gt;
&lt;p&gt;The next bit we have to deal with are our &lt;em&gt;optional&lt;/em&gt; params. The fact that they are optional means that we cannot simply add them in our consing goodness. We have to take the process of putting together our final list apart and build in the necessary checks to see if the params are given or not.&lt;/p&gt;
&lt;p&gt;One way to do this is to simply go about and check if there are any params present and if they are, just cons them onto the list we already build. While this would work fine, there is still a theoretical problem that could stick its head up. When we would cons the params onto the existing list, the params will end up at the &lt;em&gt;beginning&lt;/em&gt; of the list. You would get something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;params&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;playerid&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This is actually perfectly fine. The order of the &lt;em&gt;jsonrpc&lt;/em&gt;, &lt;em&gt;method&lt;/em&gt;, &lt;em&gt;params&lt;/em&gt; and &lt;em&gt;id&lt;/em&gt; is arbitrary. In the final JSON string the order of these keywords does not matter and the server you are sending your string to will perfectly understand your call. So the above CHICKEN code is correct.&lt;/p&gt;
&lt;p&gt;However, like I said, there is a theoretical problem. In the JSON-RPC specification they use &lt;em&gt;exactly&lt;/em&gt; the same order throughout the documentation. The &lt;em&gt;jsonrpc&lt;/em&gt; version is first, then the &lt;em&gt;method&lt;/em&gt;, then optionally the &lt;em&gt;params&lt;/em&gt; and finally the &lt;em&gt;id&lt;/em&gt;. They do this for clarity, of course, but somebody building a JSON-RPC server could interpreted this as part of the spec and only accept JSON-RPC calls that are formatted in that exact order.&lt;/p&gt;
&lt;p&gt;As assuming a particular order would be a wrong interpretation of the JSON-RPC spec, you could ignore this. If somebody would use your egg to communicate to such a faulty JSON-RPC server, you simply could blame the programmer who build the server. You would be perfectly correct. Or not...?&lt;/p&gt;
&lt;p&gt;You could also think about it from a slightly different perspective. If 99 percent of the JSON-RPC servers do not care about the order, you could as well provide the same order as the spec demonstrated. This way even the faulty servers would still work and the users of your egg will have one frustration less to worry about.&lt;/p&gt;
&lt;p&gt;The latter is the path I choose with my egg, I construct my JSON-RPC call in exactly the same order as demonstrated in the specification.&lt;/p&gt;
&lt;p&gt;But by choosing this path, we bring forth another interesting challenge. In the order of the examples, the &lt;em&gt;params&lt;/em&gt; come not at the end, not at the beginning but in the middle of our list.&lt;/p&gt;
&lt;p&gt;Luckily for us we are using CHICKEN and this problem is actually quite trivial. We can simply put an &lt;em&gt;if&lt;/em&gt; condition around our &lt;em&gt;param&lt;/em&gt; while putting our string together. Let me demonstrate:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'method&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'params&lt;/span&gt; &lt;span class="ss"&gt;'theparams&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you can see, we put a simple &lt;em&gt;if&lt;/em&gt; procedure around our &lt;em&gt;params&lt;/em&gt; cons cell. When we do not give any &lt;em&gt;params&lt;/em&gt; we simply return the empty list. When we do have &lt;em&gt;params&lt;/em&gt; we return those. Note that in the example above I used &lt;em&gt;'theparams&lt;/em&gt; to substitute for the actual &lt;em&gt;params&lt;/em&gt; that we have to build later on.&lt;/p&gt;
&lt;p&gt;If you would like to try this example in the REPL, we first have to define &lt;em&gt;params&lt;/em&gt;, otherwise our &lt;em&gt;if&lt;/em&gt; procedure will fail stating that it does not know &lt;em&gt;params&lt;/em&gt;. So first, for the sake of testing, define &lt;em&gt;params&lt;/em&gt; in the REPL:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We now defined it as &lt;em&gt;#t&lt;/em&gt; or &lt;em&gt;true&lt;/em&gt; which means it is &lt;em&gt;not empty&lt;/em&gt;. If you now type in "params" in the REPL, you will get back &lt;em&gt;#t&lt;/em&gt;.
Now, let us input our slightly modified statement into the REPL:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="ss"&gt;'version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'method&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'params&lt;/span&gt; &lt;span class="ss"&gt;'theparams&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Notice that I quoted &lt;em&gt;version&lt;/em&gt; also, because this is still unknown for the REPL in this stage of development.
If you punch this in, you will get the following output:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;params&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;theparams&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Neat! We have four &lt;em&gt;cons cells&lt;/em&gt;, including our params. Seems to work so far, no?&lt;/p&gt;
&lt;p&gt;Okay, now let us try it when &lt;em&gt;params&lt;/em&gt; are not given.
We first need to redefine &lt;em&gt;params&lt;/em&gt; to not be &lt;em&gt;#t&lt;/em&gt; but be &lt;em&gt;the empty list&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And now run our code again:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="ss"&gt;'version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'method&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'params&lt;/span&gt; &lt;span class="ss"&gt;'theparams&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The output will now read:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Hmmm, you notice the problem? There is an empty list right in the middle of our list.&lt;/p&gt;
&lt;p&gt;This, of course, makes perfect sense, since we told CHICKEN to input the empty list if we had no &lt;em&gt;params&lt;/em&gt;.
But if we would later go and convert this into a &lt;em&gt;JSON-RPC&lt;/em&gt; valid call, we would run into trouble.&lt;/p&gt;
&lt;p&gt;We have to find a way to &lt;em&gt;remove&lt;/em&gt; this empty list from our resulting list.&lt;/p&gt;
&lt;p&gt;How?&lt;/p&gt;
&lt;p&gt;With &lt;em&gt;remove&lt;/em&gt; of course! &lt;em&gt;Remove&lt;/em&gt; is a procedure that is delivered by the so-called &lt;em&gt;SRFI-1&lt;/em&gt; and is in CHIKCKEN core.&lt;/p&gt;
&lt;p&gt;What is &lt;em&gt;SRFI-1&lt;/em&gt; you ask?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SRFI&lt;/em&gt; stands for &lt;em&gt;S&lt;/em&gt;cheme &lt;em&gt;R&lt;/em&gt;equests &lt;em&gt;f&lt;/em&gt;or &lt;em&gt;I&lt;/em&gt;mplementation and are well defined Scheme libraries. The reasoning is that Schemers can use these libraries to extend the functionality of their Scheme. Somebody building a Scheme implementation can choose which SRFI's he or she would include or implement in its core. If a library proves to be useful enough it even makes a tiny chance of being included into a new RnRS spec. You can check out &lt;a href="http://srfi.schemers.org/" title="The official SRFI repository."&gt;the SRFI website&lt;/a&gt; containing all the available SRFI's.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SRFI-1&lt;/em&gt;, aka the &lt;em&gt;List Library&lt;/em&gt;, contains several useful procedures for working with lists. One of these procedures is called &lt;em&gt;remove&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Remove&lt;/em&gt; accepts two arguments, a predicate and a list. Whatever matches the predicate will be, well, removed. So in our case, we want to remove everything that is &lt;em&gt;null&lt;/em&gt; or &lt;em&gt;the empty list&lt;/em&gt;.
In the previous chapter we already saw that we have a &lt;em&gt;null?&lt;/em&gt; predicate. Now we can add the procedure &lt;em&gt;remove&lt;/em&gt; together with that predicate to get rid of our &lt;em&gt;empty list&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;remove&lt;/span&gt;
    &lt;span class="nv"&gt;null?&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="ss"&gt;'version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'method&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'params&lt;/span&gt; &lt;span class="ss"&gt;'theparams&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Which will result in:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Good! The empty list is now gone!&lt;/p&gt;
&lt;p&gt;But before we can use stuff from SRFI-1 in our egg, we will have to &lt;em&gt;load in&lt;/em&gt; its procedures the same way we loaded in &lt;em&gt;Extras&lt;/em&gt; in chapter one.
To load in multiple libraries or eggs at once, simply list the names as arguments to &lt;em&gt;use&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="nv"&gt;extras&lt;/span&gt; &lt;span class="nv"&gt;srfi-1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Let us take a look at the full code we have now for our &lt;em&gt;json-rpc-server&lt;/em&gt; procedure:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;!key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"input port"&lt;/span&gt; &lt;span class="s"&gt;"input-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"output port"&lt;/span&gt; &lt;span class="s"&gt;"ouput-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-version?&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"version"&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;else&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-method?&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-data-error&lt;/span&gt; &lt;span class="s"&gt;"method"&lt;/span&gt; &lt;span class="s"&gt;"can only be a string."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                  &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;are-valid-params?&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-data-error&lt;/span&gt; &lt;span class="s"&gt;"params"&lt;/span&gt; &lt;span class="s"&gt;"can only be a vector or an alist."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;else&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;remove&lt;/span&gt;
                        &lt;span class="nv"&gt;null?&lt;/span&gt;
                        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'method&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'params&lt;/span&gt; &lt;span class="ss"&gt;'theparams&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="p"&gt;))))))))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;That starts to look like a nice little program!&lt;/p&gt;
&lt;p&gt;But as you can notice, we still have &lt;em&gt;'theparams&lt;/em&gt; in there, which needs to be replaced with the actual params the user inputs.
In the beginning of the chapter I explained that the &lt;em&gt;params&lt;/em&gt; can be either an &lt;em&gt;alist&lt;/em&gt; or a &lt;em&gt;vector&lt;/em&gt; so that they can later be converted correctly into JSON.But we also saw that we don't want to bother the user with that. We want the user to input simple keywords or symbols.
This means we have to make a translation from keywords/symbols to alists/vectors.&lt;/p&gt;
&lt;p&gt;The first thing we need to do is to check what the user has input for &lt;em&gt;params&lt;/em&gt;. Are it keywords? Or are it symbols? After we know what the user has input, we can build either an &lt;em&gt;alist&lt;/em&gt; or a &lt;em&gt;vector&lt;/em&gt;. This calls for three small procedures, one that checks the input, one that builds an &lt;em&gt;alist&lt;/em&gt; and one that builds a &lt;em&gt;vector&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Let us begin with the input checker. This procedure will check the input and call the appropriate procedure, then it will return that result. So let us call this procedure &lt;em&gt;build-params&lt;/em&gt;. It will take one argument: the params that the user has input. This little fellow will look something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-params&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;keyword?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; 
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-alist&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list-&amp;gt;vector &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-vector&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you can see, we have an &lt;em&gt;if&lt;/em&gt; procedure that checks the &lt;em&gt;car&lt;/em&gt; of the &lt;em&gt;params&lt;/em&gt; to be a &lt;em&gt;keyword&lt;/em&gt;. The &lt;em&gt;keyword?&lt;/em&gt; procedure is a build in predicate that we have at our disposal. If the &lt;em&gt;car&lt;/em&gt; is a keyword we have to build an &lt;em&gt;alist&lt;/em&gt;. So it calls a custom procedure &lt;em&gt;build-alist&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Let us forget the rest for a moment and see how we can put together &lt;em&gt;build-alist&lt;/em&gt;.
Before we start writing code, let us do it in our minds first.&lt;/p&gt;
&lt;p&gt;If the user has input keywords, we can safely assume they will be in the following form:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;first:&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt; &lt;span class="nv"&gt;second:&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt; &lt;span class="nv"&gt;third:&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we also know the resulting alist we would like to see:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;first&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;second&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;third&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;What we need to do is take the keywords (first:, second: and third:) and make them the car of each pair, then take the value of the keywords and make them the cdr of each pair.&lt;/p&gt;
&lt;p&gt;We have already seen almost every tool we need to do this job of putting together these pairs. If we had, for example, three keywords like in the above example, the code to put this together would look something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))))(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;
            &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Wow...that seems quite verbose, no? Look at all the car, cdr and cons procedures, not to mention the unscalability of such code. If we get, for example, four or five keywords, this gets twice as long! So we have to be a bit more lazy and let CHICKEN do that heavy lifting for us. We need some kind of loop.&lt;/p&gt;
&lt;h4&gt;Recursion&lt;/h4&gt;
&lt;p&gt;A loop in CHICKEN or any other Scheme is not like your average loop in Python or C, in CHICKEN there actually is &lt;em&gt;no&lt;/em&gt; loop. Instead of a loop there exists an idea that is called &lt;em&gt;recursion&lt;/em&gt;. This is quite a simple idea where you do something over and over again until a certain condition is met. Let me demonstrate:&lt;/p&gt;
&lt;p&gt;Say for example, we have a list with three numbers:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we want to do the quite useless exercises of adding one to each of the numbers.&lt;/p&gt;
&lt;p&gt;We could do this by writing a tiny procedure that takes the first number, adds one to it, go over to the next number and do this over and over until there are no numbers left.&lt;/p&gt;
&lt;p&gt;In code, this tiny &lt;em&gt;recursive&lt;/em&gt; procedure looks like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The + sign we use here is a build-in procedure that adds up numbers, just so you know. Remember, in CHICKEN you can use almost any character as a variable or procedure name.&lt;/p&gt;
&lt;p&gt;Then we call this newly made procedure:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we get back:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You have just seen recursion in action!&lt;/p&gt;
&lt;p&gt;To fully understand what just happened we have to dig in a little bit deeper and take a look at how the &lt;em&gt;recursion&lt;/em&gt; is happening behind the curtains.&lt;/p&gt;
&lt;p&gt;We created the procedure called "addone" that calls &lt;em&gt;itself&lt;/em&gt; until the so-called &lt;em&gt;base case&lt;/em&gt; is reached. The base case here being:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;An important detail to know is that every time the procedure calls itself it will be put on a waiting list and wait for the newly called procedure to finish and give back its result.
When the base case is reached, the final procedure call returns its result (in this case the &lt;em&gt;empty list&lt;/em&gt;) and this empty list will be given to the second last procedure which can cons its result on to that.
This second last procedure then finishes and gives its result to the third last procedure that was waiting. This continues until the first, original procedure gets its result and returns this to you (or the procedure that called it in the first place).&lt;/p&gt;
&lt;p&gt;You can think of it as having a big box right in front of you, you open the box only to find another box, you open that one and you find yet another box.
This goes on until there are no boxes in boxes left (the base case is reached). But before you can close the big, original box, you will have to close every box, starting with the most smallest inner box working your way back to the big, original box.&lt;/p&gt;
&lt;p&gt;Let us look at each step of the recursion for our "addone" procedure.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1&lt;/em&gt; - We call "addone" for the first time, the argument is not null, so the base case is not reached. This means we continue with the final cons line.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;which translates to&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;You can notice that the "addone" procedure is now called with the argument '(2 3).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2&lt;/em&gt; - The base case is still not reached, because '(2 3) is not null, we continue again with the last line.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;which translates to&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The procedure "addone" is now called again, with the '(3) as the argument.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3&lt;/em&gt; - The base case is still not reached, because '(3) is not null, we continue again with the last line.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;which translates to&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now "addone" is called with the argument '(), because that is the &lt;em&gt;cdr&lt;/em&gt; of '(3).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4&lt;/em&gt; - Aha! Now the base case &lt;em&gt;is&lt;/em&gt; reached  because the argument is '() or in other words: null.&lt;/p&gt;
&lt;p&gt;So the base case condition is executed:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;which simply translates to:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you can see, this time we don't call the "addone" procedure again, but we return a value instead.
This means we now can walk back up the tree and start to give back a value to each procedure waiting.&lt;/p&gt;
&lt;p&gt;The procedure waiting for its result was the previous one before our base case was met:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We can now fill in the result of the &lt;em&gt;addone&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And the result of the sum:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now this procedure also has a value, being the cons cell &lt;em&gt;(4 . '())&lt;/em&gt;, we can go one more up.
The one procedure waiting now is this one:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;So this one now becomes:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We have yet another value, up to the next, final procedure:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;addone&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Which now becomes:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This is the final, top most procedure, so this one simply can return its value, becoming:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And there we have our result!&lt;/p&gt;
&lt;h4&gt;Back to our egg&lt;/h4&gt;
&lt;p&gt;So let us put this recursion idea into practice with our &lt;em&gt;alist&lt;/em&gt; builder. The procedure &lt;em&gt;build-alist&lt;/em&gt; would look like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-alist&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-alist&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This looks much like the simple &lt;em&gt;addone&lt;/em&gt; procedure, does it not? Okay, the last part is different of course, but the principle is the same.&lt;/p&gt;
&lt;p&gt;First we put in our &lt;em&gt;base case&lt;/em&gt;, which in many cases is to check for the empty list with the &lt;em&gt;null?&lt;/em&gt; predicate. If the given &lt;em&gt;params&lt;/em&gt; are not empty, the base case is not met and we perform a &lt;em&gt;cons&lt;/em&gt;.
Let us take this cons line apart and see where the recursion happens:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-alist&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We are consing two things together:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;cons cell&lt;/em&gt; containing the &lt;em&gt;car&lt;/em&gt; of the params (the first keyword) and the &lt;em&gt;car of the cdr&lt;/em&gt; of the params (the value of the first keyword)&lt;/li&gt;
&lt;li&gt;A call to the &lt;em&gt;same procedure&lt;/em&gt; but with the first keyword and the value of the first keyword stripped off (cdr (cdr params))&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we call this procedure with a list of keyword arguments:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-alist&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;first:&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt; &lt;span class="nv"&gt;second:&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt; &lt;span class="nv"&gt;third:&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;CHICKEN will return us:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;first:&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;second:&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;third:&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Which is a list of cons cells instead of a list of keyword arguments, that is exactly what we want!&lt;/p&gt;
&lt;p&gt;When the recursion ends, this procedure can return its value to the procedure that called it in the first place: our "build-params":&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-params&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;keyword?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; 
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-alist&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list-&amp;gt;vector &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-vector&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Which does nothing more then give this result back to the procedure that called it, the &lt;em&gt;if&lt;/em&gt; condition we where using to check if params existed while building our request object.&lt;/p&gt;
&lt;p&gt;That is all there is to it for building an alist, but what if we have to build a vector using the "build-vector" procedure? Well, this turns out to be very much the same.&lt;/p&gt;
&lt;p&gt;Let me present to you the code for "build-vector":&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-vector&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-&amp;gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Pretty much the same, right? The only difference here is, again, the consing line at the end.
Since it is a vector we are building we do not need a keyword and its value, we simply have to build a list of items, one by one.&lt;/p&gt;
&lt;p&gt;So the recursion here is the fact that we cons together the &lt;em&gt;car&lt;/em&gt; of the params and call the procedure again with the &lt;em&gt;cdr&lt;/em&gt;.
One odd thing you might notice is the &lt;em&gt;symbol-&amp;gt;string&lt;/em&gt; procedure that I have put in front of the &lt;em&gt;(car params)&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This is needed to convert the symbols we input as arguments to the lambda to be converted into real strings.
If we would not do this, we would build a list containing symbol types which would make no sense at all to a JSON-RPC call.&lt;/p&gt;
&lt;p&gt;Good. We now have our code almost completely finished, the full code for our "json-rpc-server" procedure and the procedures for building alists or vectors looks like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;!key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"input port"&lt;/span&gt; &lt;span class="s"&gt;"input-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"output port"&lt;/span&gt; &lt;span class="s"&gt;"ouput-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-version?&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"version"&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;else&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-method?&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-data-error&lt;/span&gt; &lt;span class="s"&gt;"method"&lt;/span&gt; &lt;span class="s"&gt;"can only be a string."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;are-valid-params?&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-data-error&lt;/span&gt; &lt;span class="s"&gt;"params"&lt;/span&gt; &lt;span class="s"&gt;"can only be a vector or an alist."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;remove&lt;/span&gt; &lt;span class="nv"&gt;null?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'method&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'params&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-params&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
              &lt;span class="nv"&gt;input&lt;/span&gt; 
              &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-params&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;keyword?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; 
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-alist&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list-&amp;gt;vector &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-vector&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-alist&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
        &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-alist&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-vector&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-&amp;gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;There we have our whole mechanism for creating our request object. We have the procedure that sets up a connection and returns another procedure that builds the actually object using the small recursive procedures we just wrote.&lt;/p&gt;
&lt;p&gt;The only problem now is that this code build the request object...and that is it. We still need to hand it over to Medea, the JSON&amp;lt;-&amp;gt;CHICKEN converter we saw in chapter one.
Luckily for us (and thanks to &lt;a href="http://wiki.call-cc.org/users/moritz-heidkamp" title="Moritz Heidkamp user page on the CHICKEN wiki"&gt;Moritz Heidkamp&lt;/a&gt; who made the Medea egg), this is yet another trivial task.&lt;/p&gt;
&lt;h4&gt;Sending over the data&lt;/h4&gt;
&lt;p&gt;All we need to do is to call the sending procedure of Medea with our build request object and the output port we set when creating our connection with "json-rpc-server".
So first thing to do is to make sure we load in the Medea egg using the same &lt;em&gt;use&lt;/em&gt; procedure as we did when loading in the SRFI-1 and Extras:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="nv"&gt;extras&lt;/span&gt; &lt;span class="nv"&gt;srfi-1&lt;/span&gt; &lt;span class="nv"&gt;medea&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As we are now used to doing, let us create a small procedure that will send the data over to Medea:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;send-request&lt;/span&gt; &lt;span class="nv"&gt;request&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;write-json&lt;/span&gt; &lt;span class="nv"&gt;request&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;That is how simple it works. The "write-json" is a procedure from Medea that, well, takes the given object or "datum", converts it into JSON and sends it over to the output port given.&lt;/p&gt;
&lt;p&gt;And now we need to call this procedure in our lambda, where the "request" argument will become the whole building process we have been seeing in this chapter:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;!key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"input port"&lt;/span&gt; &lt;span class="s"&gt;"input-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"output port"&lt;/span&gt; &lt;span class="s"&gt;"ouput-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-version?&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"version"&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;else&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-method?&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-data-error&lt;/span&gt; &lt;span class="s"&gt;"method"&lt;/span&gt; &lt;span class="s"&gt;"can only be a string."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;are-valid-params?&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-data-error&lt;/span&gt; &lt;span class="s"&gt;"params"&lt;/span&gt; &lt;span class="s"&gt;"can only be a vector or an alist."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;send-request&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;remove&lt;/span&gt; &lt;span class="nv"&gt;null?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'jsonrpc&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'method&lt;/span&gt; &lt;span class="nv"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;null? &lt;/span&gt;&lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'params&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build-params&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="ss"&gt;'id&lt;/span&gt; &lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                        &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Voila, we now call the procedure "send-request" where its first argument is the &lt;em&gt;whole&lt;/em&gt; request object building process and the output port is the second argument.&lt;/p&gt;
&lt;h4&gt;Defining and exporting&lt;/h4&gt;
&lt;p&gt;Good, we finished up the total code, &lt;em&gt;congratulations&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;Next up is to actually tell CHICKEN that this file is the source code of an egg.&lt;/p&gt;
&lt;p&gt;First we load in the actual CHICKEN core at the beginning of our file:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;import&lt;/span&gt; &lt;span class="nv"&gt;chicken&lt;/span&gt; &lt;span class="nv"&gt;scheme&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Next we have to give this file a place inside our egg (eggs can consist of multiple source code files).&lt;/p&gt;
&lt;p&gt;This is done trough the &lt;em&gt;module&lt;/em&gt; procedure. This procedure takes several arguments, the first being the actual name of the module. In our case, the file we have been creating the past two chapters will contains the code for the &lt;em&gt;client&lt;/em&gt; implementation. So I choose &lt;em&gt;json-rpc-client&lt;/em&gt; as the name for this module file.&lt;/p&gt;
&lt;p&gt;The next argument is the procedures you wish to export. When creating an egg with one or multiple files, you can choose to which of the procedures the user of your egg has access to. In our case, the users does need to use our predicate procedures or anything like that. There is only one procedure that they will need to use: our &lt;em&gt;json-rpc-server&lt;/em&gt; procedure. So to scope their access, we can set this procedure to be exported.&lt;/p&gt;
&lt;p&gt;The third argument is the &lt;em&gt;whole code&lt;/em&gt; of our egg. Everything we have been writing up to this point goes into that procedure.&lt;/p&gt;
&lt;p&gt;So, in the top of our egg file, we will end up with this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;module&lt;/span&gt; &lt;span class="nv"&gt;json-rpc-client&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;import&lt;/span&gt; &lt;span class="nv"&gt;chicken&lt;/span&gt; &lt;span class="nv"&gt;scheme&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;; the whole egg code ; ...&lt;/span&gt;

&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Mind the ending parenthesis at the end of your CHICKEN file to close off the last argument.&lt;/p&gt;
&lt;h4&gt;Licensing&lt;/h4&gt;
&lt;p&gt;There is one more thing left before we can start dreaming of chapter three: setting the correct license.&lt;/p&gt;
&lt;p&gt;It is important to set a correct license on your work, for protecting it, but also for making it possible for people to know if they can include it in &lt;em&gt;their&lt;/em&gt; work.
The CHICKEN website has &lt;a href="http://wiki.call-cc.org/eggs-licensing" title="Licensing page on the CHICKEN website."&gt;a page&lt;/a&gt; containing all sorts of licenses you can use. Pick one carefully and put it in the top of your CHICKEN files.&lt;/p&gt;
&lt;h4&gt;Looking ahead&lt;/h4&gt;
&lt;p&gt;While we probably have a functioning CHICKEN Scheme file, it is still not a real egg, it is merely one file containing a bunch of CHICKEN code and a module wrapper to give it a name and export the needed procedures.
As we have seen in chapter one, we now need to create some extra files so that CHICKEN will recognize this as a real module.&lt;/p&gt;
&lt;p&gt;And one other &lt;em&gt;very important&lt;/em&gt; thing we have to setup before you can release an egg is a &lt;em&gt;testing suite&lt;/em&gt;.
It is not mandatory for releasing an egg, but it is highly recommended.
&lt;em&gt;Always&lt;/em&gt; write tests for your code, this takes a little bit of your time, but can be a huge benefit in further development of your code.&lt;/p&gt;
&lt;p&gt;Okay, I will leave you to rest now, take a deep breath and relax.&lt;/p&gt;
&lt;p&gt;And as always...thanks for reading!&lt;/p&gt;&lt;/div&gt;</description><category>chicken</category><category>json rpc</category><category>scheme</category><guid>http://shisaa.jp/postset/chicken-scheme-2.html</guid><pubDate>Thu, 05 Sep 2013 19:00:00 GMT</pubDate></item><item><title>The Scheme programming language AKA The CHICKEN hens nest - Part 1</title><link>http://shisaa.jp/postset/chicken-scheme-1.html</link><dc:creator>Tim van der Linden</dc:creator><description>&lt;div&gt;&lt;h3&gt;Chapter 1 - A Schemey world of wonder&lt;/h3&gt;
&lt;p&gt;I just recently finished writing my first egg (module) for the Scheme implementation called CHICKEN.
For me, this seemed as a good point in time to take you on a journey to the world of the Scheme programming language.&lt;/p&gt;
&lt;p&gt;The goal of these posts is to show you how to write your own egg for CHICKEN.
Or, in other words, how to contribute and in turn learn about this dialect.&lt;/p&gt;
&lt;p&gt;I assume that you have a basic notion of computer programming and know how to use a Unix system on a basic level.
All the rest we can explore in these three chapters!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Beware:&lt;/strong&gt; I will fire a lot of information in your general direction...so if you don't understand something, allow yourself to take a step back.
Put these posts down and pick them up a day later. Don't push yourself to read something if you did not understand the part that came before it.&lt;/p&gt;
&lt;h4&gt;So what will we see in this first chapter?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;A preface&lt;/li&gt;
&lt;li&gt;Another preface&lt;/li&gt;
&lt;li&gt;What is CHICKEN?&lt;/li&gt;
&lt;li&gt;Draw an outline of the egg we will make&lt;/li&gt;
&lt;li&gt;Looking at (CHICKEN) data types&lt;/li&gt;
&lt;li&gt;Using Medea, an egg for CHCIKEN &amp;lt;-&amp;gt; JSON translation&lt;/li&gt;
&lt;li&gt;Learning about cons cells&lt;/li&gt;
&lt;li&gt;What are car, cdr and cons?&lt;/li&gt;
&lt;li&gt;Start to hatch our egg&lt;/li&gt;
&lt;li&gt;Looking at the skeleton of a CHICKEN egg&lt;/li&gt;
&lt;li&gt;Using predicates&lt;/li&gt;
&lt;li&gt;Looking at exception handling&lt;/li&gt;
&lt;li&gt;Take a deep breath and look at what we have seen&lt;/li&gt;
&lt;li&gt;Prepare for chapter 2&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Preface&lt;/h3&gt;
&lt;p&gt;Imagine me and Bill (also known as Bill the Brogrammer) walking down a street on a rainy evening.
Next to us, there is something else walking, a stranger, an unknown.
All of a sudden I turn to Bill and say: "Ever heard of LISP or Scheme?".&lt;/p&gt;
&lt;p&gt;Bill gives me a blank stare.&lt;/p&gt;
&lt;p&gt;"No? Well, then it's time that I introduce you to each other!"
I take a step back so he can see our stranger and shake its hand. 
"Bill, this is Scheme! Scheme, this is Bill!"&lt;/p&gt;
&lt;p&gt;But Bill frowns and says: "It looks strange, almost from another planet...and...it looks like my grandfather."&lt;/p&gt;
&lt;p&gt;"Now, now, no need to judge so early!", I say, "True that it may look a bit uncommon, and true that it's older then the pilot episode of Lost in Space, but that does not mean a thing!".&lt;/p&gt;
&lt;p&gt;Bill looks closer into it's luminescent little eyes and states in a monotone voice: "If I befriend it, people will frown upon me. People will think that I'm smug, a weeny, something better then they are, they will hit me with sticks and chaise me with pitchforks...".&lt;/p&gt;
&lt;p&gt;"All of that...just because you have befriended Scheme?", I ask a bit confused.&lt;/p&gt;
&lt;p&gt;"Yes! If I come too close to it, I may loose interest in my other friends, especially my good friends Pee-hey-pee&lt;sup&gt;1&lt;/sup&gt; and Jaabaa&lt;sup&gt;1&lt;/sup&gt;."&lt;/p&gt;
&lt;p&gt;I snuggle ever so slightly: "What did &lt;em&gt;those&lt;/em&gt; friends ever do for you?"&lt;/p&gt;
&lt;p&gt;"&lt;em&gt;Those&lt;/em&gt; friends gave me scripts, a corporate look...and...a shiny bandwagon to ride on together with all my other Brogrammers...", Bills eyes turn watery.
With a small voice he asks: "Does Scheme have a shiny bandwagon too?".&lt;/p&gt;
&lt;p&gt;I shake my head: "No, I'm sorry, it does not. But it has something else..."&lt;/p&gt;
&lt;p&gt;The Schemy little thing puts out its bony hands, holding out a small box.&lt;/p&gt;
&lt;p&gt;"Take the box", I instruct Bill, "Take it and open it up.".&lt;/p&gt;
&lt;p&gt;Full with doubt Bill takes the box and slowly opens it. His face becomes lit with a bright, angle-like light. A street choir starts to sing.
From the box rises and ancient figure, elegant, light as a feather. Bill starts to weep, tears streaming from his eyes.
"Its....its...the Lambda!", he bursts out in tears of joy, "I see the light...I see it now...its so beautiful!".&lt;/p&gt;
&lt;p&gt;"Yes it is, yes it is." I pat Bills shoulder and the three of us walk of into the moonlight.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;small&gt;fictional languages, any resemblance to real languages is pure coincidence...&lt;/small&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Less cheesy preface&lt;/h3&gt;
&lt;p&gt;Okay, that last part may have been a little bit over the top...&lt;/p&gt;
&lt;p&gt;But before we dive into Scheme I want to take away the strange light that this language and its users are being put in by some people.
It is true that Schemers (people using Scheme) are smug-lisp-weenies (or smug-scheme-weenies or even smug-list-weenies, ha!), but that is not a &lt;em&gt;bad&lt;/em&gt; thing.&lt;/p&gt;
&lt;p&gt;From my personal experience, Schemers have been the best and most competent programmers that I have worked with so far.
And yes, they can be smug, really smug, but only when it is &lt;em&gt;justified&lt;/em&gt; to be so. When another language fails horribly, Scheme most of the time has a much better alternative.
A &lt;em&gt;good&lt;/em&gt; Schemer is smug by pointing out how it can be done better, safer and faster. A &lt;em&gt;good&lt;/em&gt; Schemer will never, ever be smug on a personal level.&lt;/p&gt;
&lt;p&gt;Scheme, or it's ancestor LISP, is a language that is designed around a totally different view then most, current programming languages.
It has been around long enough to see the birth of all the current hip and cool languages.
And it goes back all the way to the 1950's, quite close to the birth of the modern day computer. &lt;em&gt;And it is still here.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Before I start sounding like and evangelist who should start a Church Of Scheme, there are, of course, other nice and elegant languages.
To name a few: Python, Erlang, Pascal, ... . There are dozens of decent languages out there.
Using Scheme does not exclude you from using other languages or vice versa. It will, however, teach you more about &lt;em&gt;real&lt;/em&gt; programming.
If used correctly, Scheme can teach you good practices that you can also use (to a certain extend) in other programming languages.&lt;/p&gt;
&lt;p&gt;It's a &lt;em&gt;minimalistic&lt;/em&gt; language with an almost human readable notation, without almost any syntax hassle and which invites you, no, &lt;em&gt;encourages&lt;/em&gt; you to contribute to extend its functionality.&lt;/p&gt;
&lt;p&gt;Good, now that we have that off the table, its time to get our hands dirty!&lt;/p&gt;
&lt;h3&gt;What is CHICKEN?&lt;/h3&gt;
&lt;p&gt;First things first, what is this CHICKEN I keep referring to?&lt;/p&gt;
&lt;p&gt;To understand this we have to take a look at how Scheme is used to form various "dialects".
Scheme itself is rarely found, most of the time it is an interpretation of a &lt;em&gt;specification&lt;/em&gt; that you will use to program in.&lt;/p&gt;
&lt;p&gt;These so-called dialects are based on specifications that aim at making the different Schemes lightweight languages. This lightweight aspect is in contrast to &lt;em&gt;Common Lisp&lt;/em&gt; (Schemes twin survivor of the old LISP mother) which includes everything and the kitchen sink.&lt;/p&gt;
&lt;p&gt;The specifications that are used &lt;em&gt;as guidelines&lt;/em&gt; to build the various Scheme dialects are called the R&lt;em&gt;n&lt;/em&gt;RS specs. And just recently, the first draft for the latest spec (R7RS) was released.&lt;/p&gt;
&lt;p&gt;Because &lt;em&gt;anyone&lt;/em&gt; with some degree of Scheme knowledge can build its own implementation, there are literally thousands of dialects.
Most of them never make it out of the developers computer though, as they are mere experiments to get to know the language better.
But some do make it out and CHICKEN is one such dialect.&lt;/p&gt;
&lt;p&gt;Conjured up by &lt;a href="http://spin.atomicobject.com/2013/05/02/chicken-scheme-part-1/" title="Reddit article about Felix Winkelmann"&gt;Felix Winkelmann&lt;/a&gt; in 2000, CHICKEN is a Scheme implementation based on the R5RS spec.
It is one of the few Schemes out there with a very rich ecosystem of supporting modules (from now on referred to as &lt;em&gt;eggs&lt;/em&gt;) that extend CHICKEN's core functionality.
And in my personal experience, the CHICKEN community consists of very, very friendly people who are always willing to help, whether you are an absolute nooby or a seasoned Schemer.&lt;/p&gt;
&lt;h3&gt;How do you "get" CHICKEN?&lt;/h3&gt;
&lt;p&gt;Before we can start programming using CHICKEN, we have to install it first.
This can be done on a &lt;a href="http://wiki.call-cc.org/platforms" title="CHICKEN WIKI entry for installing on different platforms."&gt;wide variety of platforms&lt;/a&gt; ranging from Linux, BSD, OSX and even Windows, but for the scope of these posts I will be using Linux.&lt;/p&gt;
&lt;p&gt;On most Linux systems there are binaries available that you can use to get up and running quickly.&lt;/p&gt;
&lt;p&gt;I use Arch Linux as my main development platform, so I will stick to that for setting everything up.
To install CHICKEN you can simply let your package manager do the heavy lifting:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;pacman -S chicken
&lt;/pre&gt;


&lt;p&gt;That's it! You now have a fully functional CHICKEN system.&lt;/p&gt;
&lt;p&gt;There are three programs that have been installed that you should take note of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;csc: The &lt;em&gt;C&lt;/em&gt;HICKEN &lt;em&gt;S&lt;/em&gt;cheme &lt;em&gt;C&lt;/em&gt;ompiler&lt;/li&gt;
&lt;li&gt;csi: The &lt;em&gt;C&lt;/em&gt;HICKEN &lt;em&gt;S&lt;/em&gt;cheme &lt;em&gt;I&lt;/em&gt;nterpretor&lt;/li&gt;
&lt;li&gt;chicken-install: The chicken egg installer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let us go over them briefly.&lt;/p&gt;
&lt;h4&gt;csc&lt;/h4&gt;
&lt;p&gt;This is the &lt;em&gt;CHICKEN compiler&lt;/em&gt; and is used to "convert" or compile Scheme code into raw C.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;What is compiling, you ask?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Before the day of C, PASCAL or FORTRAN (which are all referred to as "low level" programming languages) you had to completely rewrite you code for every different architecture that you wanted your program to run on. This was a big, time consuming hassle and the computing industry needed something more flexible, something more &lt;em&gt;portable&lt;/em&gt;. A &lt;em&gt;generic&lt;/em&gt; language that programmers could use. The C programming language was born. Well, to be more accurate, FORTRAN was first, and is considered the oldest language still in use. But because FORTRAN is more in the field of scientific computing, C became a more popular general purpose language to program in.&lt;/p&gt;
&lt;p&gt;This introduced a more fluid way of working but also introduced an extra step before you could run your portable code on a specific architecture.
This step is called &lt;em&gt;compiling&lt;/em&gt;. Because the different chipsets still needed their own, specific instructions the code still needed to be converted into their supported &lt;em&gt;binary&lt;/em&gt; format.&lt;/p&gt;
&lt;p&gt;To this day of age, this principle is unchanged. We are still stuck to the same multi architectural differences. Computers haven't actually evolved much since the old days.&lt;/p&gt;
&lt;p&gt;Because by modern day standards C itself isn't the most practical, friendly nor safe language to program in, the same idea happened here as well.
So called "high level" programming languages where build on top of C (or along side C) that where more soothing to program in.&lt;/p&gt;
&lt;p&gt;And yet another step was introduced.&lt;/p&gt;
&lt;p&gt;Before these high level languages could be run by the computer, most of them have to be compiled to portable C code which, in turn, compiles it to architecture specific binary code.
The compilation to C is, in most cases, necessary because the C compiler is one of the few compilers that knows almost &lt;em&gt;every&lt;/em&gt; dirty, nitty gritty detail about every chipset, every instructions set available out there. If you want to cut out the C compiler and compile directly to binary code, you will have to implement &lt;em&gt;every goddamn&lt;/em&gt; chipset yourself. Since this is generally considered the work of a mad man, people tend to use the C compiler in the final step to spit out binary code.&lt;/p&gt;
&lt;p&gt;And that is exactly what happens with the CHICKEN compiler. You compile your Scheme code to portable C code, and then use a C compiler (usually GCC) to compile to a binary file.&lt;/p&gt;
&lt;p&gt;What is interesting for us in this stage is the optimization that happens before &lt;em&gt;csc&lt;/em&gt; compiles the portable C code.
This is an in-between step that will produce a more optimized version of your CHICKEN code so that the compiler can make more smart decisions.
The optimization step gives as a nice report at the end of the optimized CHICKEN file which we can read and use to "clean up" our source code.&lt;/p&gt;
&lt;p&gt;Don't worry about this too much, it will be more clear when we actually come to this step in chapter 2.&lt;/p&gt;
&lt;h4&gt;csi&lt;/h4&gt;
&lt;p&gt;This is the &lt;em&gt;CHICKEN interpreter&lt;/em&gt; and is used to quickly throw some code at and see the results without the need to compile everything.
Another name for this is a &lt;em&gt;REPL&lt;/em&gt;, which is short for &lt;em&gt;R&lt;/em&gt;ead, &lt;em&gt;E&lt;/em&gt;valuate and &lt;em&gt;P&lt;/em&gt;rint &lt;em&gt;L&lt;/em&gt;oop:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You punch in a line of code that it &lt;em&gt;reads&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;The interpreter goes and &lt;em&gt;evaluates&lt;/em&gt; that code&lt;/li&gt;
&lt;li&gt;It &lt;em&gt;prints&lt;/em&gt; the result of that evaluation&lt;/li&gt;
&lt;li&gt;Then it goes back into read mode, waiting for your input and thus making a &lt;em&gt;loop&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You will be using the REPL a lot when developing. Keep in mind though that the interpreter is considerably slower then when you compile your code. So, in CHICKEN at least, its perfect for development purposes, but not for use in "the real world". &lt;/p&gt;
&lt;h4&gt;chicken-install&lt;/h4&gt;
&lt;p&gt;This is the &lt;em&gt;CHICKEN Egg installer&lt;/em&gt; which you can use to...well...install eggs and extend the functionality of your local CHICKEN install.&lt;/p&gt;
&lt;h3&gt;Outlining the Egg&lt;/h3&gt;
&lt;p&gt;Okay, now that we have the basics up and running on our system, its time to build a clear picture of what we want to make.&lt;/p&gt;
&lt;p&gt;In my case, I wanted to build an egg that would format user input (the user here being the programmer using this egg) into a JSON-RPC 2.0 valid string.&lt;/p&gt;
&lt;p&gt;If you don't know what JSON is, keep reading!&lt;/p&gt;
&lt;p&gt;I found that there was no such egg available in the &lt;a href="http://wiki.call-cc.org/chicken-projects/egg-index-4.html" title="Index of CHICKEN v4 eggs"&gt;egg index&lt;/a&gt;, so I decided to write it myself and do a contribution to the CHICKEN ecosystem.&lt;/p&gt;
&lt;p&gt;This egg is actually part of a larger plan I have in mind, that is, to control my XBMC media box from a terminal application.
In my mind, this larger plan would consist out of three eggs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;A JSON-RPC translator&lt;/em&gt; (the one we will build now):
   The XBMC system uses JSON to let other devices communicate with and control it. So on a basic level we need the instructions that we sent to be valid JSON-RPC.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;A XBMC API in CHICKEN&lt;/em&gt;:
   XBMC has an elaborate API, in JSON of course, that we have to abstract into Scheme. This is done with the help of the JSON-RPC egg.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;An end-user program&lt;/em&gt;:
   A program, which implements the above XBMC in Scheme API, that the end-user can actually use to control their XBMC box.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But for now, you can forget about the last two and focus on the JSON-RPC egg.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;What is JSON?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;JSON is an acronym for &lt;em&gt;Javascript Object Notation&lt;/em&gt; and is a standardized way to exchange textual information between systems. It's as simple as that.
It uses the JavaScript language representation of data and puts in it a serialized form we call a string.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Then, what is a JSON-RPC string?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;JSON-RPC is a &lt;a href="http://www.jsonrpc.org/specification" title="JSON-RPC version 2.0 specification"&gt;specification&lt;/a&gt; that standardizes a way of invoking RPC's or &lt;em&gt;Remote Procedure Calls&lt;/em&gt;. RPC is nothing more then a fancy term which means the same as a way to start a "procedure" on another machine.
Because we are dealing with data &lt;em&gt;exchange&lt;/em&gt; we have a client and a server part:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client:
  The client can send a &lt;em&gt;request&lt;/em&gt; object to the server&lt;/li&gt;
&lt;li&gt;Server:
  The Server can send back a &lt;em&gt;response&lt;/em&gt; object if the request object was understood and an &lt;em&gt;error&lt;/em&gt; object if the request was in error.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since the JSON-RPC egg that I made only focuses on the client side (for now) we can concentrate on the &lt;em&gt;request&lt;/em&gt; object only.
According to the spec the request string consists out of four different entities where one entity is optional:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A string containing the JSON-RPC &lt;em&gt;version number&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;A string containing the &lt;em&gt;method&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;An &lt;em&gt;optional&lt;/em&gt; array (named or positional) containing the &lt;em&gt;parameters&lt;/em&gt; (called params)&lt;/li&gt;
&lt;li&gt;A unique &lt;em&gt;ID&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So a JSON string build according to this spec would look something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nt"&gt;"jsonrpc"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;"method"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"subtract"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;"params"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nt"&gt;"id"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;What we want our egg to do is to accept, in some form, some data (version, method, params and id), construct this JSON string and finally output it.&lt;/p&gt;
&lt;p&gt;But how?&lt;/p&gt;
&lt;h3&gt;(CHICKEN) Data types&lt;/h3&gt;
&lt;p&gt;CHICKEN does not output JSON, even more so, CHICKEN does not &lt;em&gt;know&lt;/em&gt; JSON. To CHICKEN, JSON is just a string containing a bunch of characters.
So to be able to work with JSON inside of CHICKEN, it's important that we think of a way we can represent JSON in CHICKEN.
This representation is done trough CHICKEN data types.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Data types?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Every programming language has data types. They are vital building blocks. A data type is a defined &lt;em&gt;container&lt;/em&gt; which can hold a specific type of data.
The data type &lt;em&gt;number&lt;/em&gt; (in Scheme), for example, can only hold integers or the data type &lt;em&gt;boolean&lt;/em&gt; can only hold true or false.
They tell the system something about the data they contain.&lt;/p&gt;
&lt;p&gt;In the world of programming languages we have two data type systems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dynamically typed (Scheme (CHICKEN), Python, Erlang, JavaScript, Ruby ...)&lt;/li&gt;
&lt;li&gt;Statically typed (C, Haskell, Pascall ...)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is &lt;em&gt;great&lt;/em&gt; discussion as to which type system is better (not to mention the subtypes "weak" and "strong").
I'll not go into the hairy discussion (for it is unshavably hairy), let us just settle by saying that both systems have their advantages.&lt;/p&gt;
&lt;p&gt;With a &lt;em&gt;strong dynamically&lt;/em&gt; typed language like CHICKEN, the type is added to the value and not to the variable itself. So you can put a string into a variable that held a number before, but you cannot, for instance, add up a number type (1) and a string type (containing the character 1). It catches programming errors early (during compilation) and puts in a layer of security (data and data types cannot be mixed up). &lt;/p&gt;
&lt;p&gt;For now I would be happy if you just remember there are two types and CHICKEN is of the dynamic kind.&lt;/p&gt;
&lt;p&gt;So what we have to do next is look at which data types we can use to represent a JSON-RPC valid string in Scheme.&lt;/p&gt;
&lt;h3&gt;Medea, the JSON egg&lt;/h3&gt;
&lt;p&gt;As we have seen before JSON is a JavaScript based textual representation of data which means that JavaScript is the only language where a JSON string &lt;em&gt;does&lt;/em&gt; make sense.
Actually, a JSON string contains JavaScript data types!&lt;/p&gt;
&lt;p&gt;Having this info we don't have to figure out everything by ourselves, we just need to make a mapping from JavaScript data types to CHICKEN data types and we have our representation.&lt;/p&gt;
&lt;p&gt;Simple, right? Even more simple with an egg called &lt;a href="http://wiki.call-cc.org/eggref/4/medea" title="The Wiki entry for the Medea egg."&gt;Medea&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This egg does &lt;em&gt;exactly&lt;/em&gt; what we described above: map JSON (JavaScript) data types to CHICKEN data types and the other way around.&lt;/p&gt;
&lt;p&gt;Whoohoo!&lt;/p&gt;
&lt;p&gt;But Medea does a conversion for almost &lt;em&gt;every&lt;/em&gt; data type, so first we have to look at which data types we actually need.
Since our starting point is an existing JSON-RPC string we have to start by looking at the JavaScript side of things.
Let us introduce a XBMC JSON-RPC string to dissect:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nt"&gt;"jsonrpc"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;"method"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;"params"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nt"&gt;"playerid"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="nt"&gt;"id"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;In this string we find two different JavaScript data types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A string&lt;/li&gt;
&lt;li&gt;An object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Not too shabby, hey? Just two data types we have to concern ourselves with. If we feed these two data types to Medea, what will it spit out?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A string becomes a &lt;em&gt;string&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;An object becomes a &lt;em&gt;associative list&lt;/em&gt; or &lt;em&gt;alist&lt;/em&gt; in short.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, not too much to handle.&lt;/p&gt;
&lt;p&gt;Actually, according to the JSON-RPC spec, we can have an object &lt;em&gt;or&lt;/em&gt; an array.
The object can be used to give &lt;em&gt;named&lt;/em&gt; params (as in the example above), the array can be used to gives &lt;em&gt;positional&lt;/em&gt; params. In CHICKEN a &lt;em&gt;positional&lt;/em&gt; array can be translated to a &lt;em&gt;vector&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So we actually have three data types to look at. Still not too bad!&lt;/p&gt;
&lt;p&gt;Let us look at each of them and see what they look like in CHICKEN.&lt;/p&gt;
&lt;p&gt;A string in CHICKEN looks like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"This is a string"&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Just the same as in most languages. A sequences of characters wrapped in double quotes.
On to the next one, a vector (this would be a normal array in another language):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="s"&gt;"bar"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This is a vector containing two strings. It is represented as a list proceeded with a hash symbol.
And finally an associative list (this would be a hash table or associative array in another language):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;faa&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;bor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Also, not too scary, just a list containing pairs.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Waah, wait, what are all these parenthesis doing there? And what are these lists you speak of?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Phew, I thought you would never ask!&lt;/p&gt;
&lt;p&gt;These lists and the parenthesis that represent them are a &lt;strong&gt;very&lt;/strong&gt; important part of the language syntax.
This is what many programmers (who don't use a Scheme) see as difficult and sometimes define it as incomprehensible.
If you show a piece of Scheme code to a non-Schemer, many time they let out a girly shriek, scared by the hundreds of parenthesis crawling over their screen.&lt;/p&gt;
&lt;p&gt;And most of the time their first reaction (after the shriek) is: "How can you even read this stuff?".&lt;/p&gt;
&lt;p&gt;The answer is simple: You just &lt;em&gt;do&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In the beginning you will find this strange and maybe less clear to read. But the more you &lt;em&gt;actually program&lt;/em&gt; with a Scheme, the more this syntax will start to feel natural.
And eventually you will feel that these lists and parenthesis will free you from the syntax horror that some other languages can bestow upon you.&lt;/p&gt;
&lt;p&gt;The reasoning behind these lists lies in history. In the beginning of the post, we talked about Scheme being a remainder of the old LISP mother.
LISP, which is short for &lt;em&gt;LIS&lt;/em&gt;t &lt;em&gt;P&lt;/em&gt;rocessing, is a language developed in the 1950's by John McCarthy at the MIT University.&lt;/p&gt;
&lt;p&gt;In this language (and all the successors) everything is a list (that not entirely true, but let us forget that for now).
In the beginning lists where simply the way this language represented data, but as the language grew more mature, lists quickly proofed to give an excellent solution to something LISP languages are very good at.&lt;/p&gt;
&lt;p&gt;What is that you ask? This: &lt;em&gt;code is data and data is code&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I will not be going deeper into this right now as it is beyond the scope of these posts, but just know that this is one of the reasons why Schemers love their parenthesis.&lt;/p&gt;
&lt;p&gt;Oh, and one other important thing, Schemers like to refer to lists as &lt;em&gt;s-expressions&lt;/em&gt;. Well, actually &lt;em&gt;lists&lt;/em&gt; are &lt;em&gt;s-expressions&lt;/em&gt; but &lt;em&gt;s-expressions&lt;/em&gt; don't have to be &lt;em&gt;lists&lt;/em&gt;. In Scheme &lt;em&gt;symbols&lt;/em&gt;, &lt;em&gt;vectors&lt;/em&gt;, &lt;em&gt;strings&lt;/em&gt;, ... are all &lt;em&gt;s-expressions&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Okay, after this very brief run trough history, let us turn back to our data types we just saw.&lt;/p&gt;
&lt;p&gt;We have concluded that we want to use the Medea egg to translate our CHICKEN data types in JSON and we have determined which data type we want to use.
The next logical step is too see how we can actually use Medea inside of CHICKEN to do the conversion for us.&lt;/p&gt;
&lt;p&gt;Its time to use...the &lt;em&gt;REPL&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;Yes, after all this talk, we can finally get our hands dirty!
As we have seen before, the REPL in CHICKEN is called &lt;em&gt;csi&lt;/em&gt;, so open up a terminal and punch the command &lt;em&gt;csi&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;You will see a small greeting and a blinking cursor waiting for your input.
By default, the interpreter has no extra modules loaded. If we want to use Medea, we first have to load in that module.
So punch in this line and hit enter:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="nv"&gt;medea&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And we have....an error. Ah, aren't I a sneaky bastard...CHICKEN does not know this module "Medea" that you want to use. Why? Because we haven't installed it yet.
So leave you interpreter by typing:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;q&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Before you can install any egg, you have to be root.
So become root and install Medea:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;chicken-install medea
&lt;/pre&gt;


&lt;p&gt;Now switch back to your user and start the interpreter again.&lt;/p&gt;
&lt;p&gt;It's important to know that when you exit the interpreter it will reset and forget everything you have done in that session.
So you have to load in Medea again. Now it should show a bunch of lines telling you want it imported and return back to read mode.&lt;/p&gt;
&lt;p&gt;Every egg in CHICKEN comes with documentation, so its important you read it carefully before using it or asking help on mailings lists or IRC.
According to Medea's documentation we have two procedures we can use to read or write JSON.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;What's a procedure?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A procedure can be compared with a function in another language. It's a bunch of lists that do something, usually return a value.&lt;/p&gt;
&lt;p&gt;Small note about &lt;em&gt;lists&lt;/em&gt;: I just told you a little lie, I said that procedures are lists, but actually, in CHICKEN, they are only &lt;em&gt;represented&lt;/em&gt; as lists and are their own thing entirely when compiled. There is a common misconception that in CHICKEN or Scheme everything is a list. This comes from the old LISP, where this &lt;em&gt;was&lt;/em&gt; true. However, one of the things that separates Scheme from LISP is the very fact that &lt;em&gt;not everything&lt;/em&gt; are lists anymore. Just keep a mental note of that.&lt;/p&gt;
&lt;p&gt;Okay, let us continue.&lt;/p&gt;
&lt;p&gt;By loading in the egg we have many new procedures at our disposal.
There are two of them which we can use directly in the REPL to see the conversion in action:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;read-json&lt;/span&gt; &lt;span class="nv"&gt;datum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;write-json&lt;/span&gt; &lt;span class="nv"&gt;datum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;&lt;em&gt;Datum&lt;/em&gt; is a placeholder used to describe any form of data that can be put there.
Let us take the JSON string we dissected above and see what Medea makes of it.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;read-json&lt;/span&gt; &lt;span class="s"&gt;"{\"jsonrpc\": \"2.0\", \"method\": \"Player.PlayPause\", \"params\": { \"playerid\": 0 }, \"id\": 1}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;As you know a string in CHICKEN is wrapper in double quotes. JSON also uses double quotes inside its serialized string.
So to not confuse CHICKEN, we have to escape the JSON double quotes. Escaping of characters inside a CHICKEN string is done with a backslash.
If you input this into your interpreter you will get the following output:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;params&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;playerid&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Let us take a closer look at this return value as there are some new things hidden here.&lt;/p&gt;
&lt;p&gt;We have four pairs, corresponding to the four entities we have in our JSON-RPC spec.&lt;/p&gt;
&lt;p&gt;These pairs are also referred to as &lt;em&gt;cons cells&lt;/em&gt;, the building blocks of a list inside CHICKEN.
You may notice that the members of each cons cell are separated by a dot. This is the true, correct way of writing down a pair.&lt;/p&gt;
&lt;p&gt;Let us first break down the cons cells that are required according to the JSON-RPC spec (version, method, id):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This cons cell describes the JSON-RPC spec version we will use, being 2.0.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This cons cell describes the method we send to the server, being a string known to the XBMC api.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And here yet another simple cons cell telling which ID this request object will have.&lt;/p&gt;
&lt;p&gt;Now let us look at the optional one, the params:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;params&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;playerid&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This cons cell looks different. In fact, it is a cons cell withing a cons cell.&lt;/p&gt;
&lt;p&gt;Here we introduce another part of why list notation is useful: &lt;em&gt;hierarchy&lt;/em&gt;. You can use lists within lists within lists ...&lt;/p&gt;
&lt;p&gt;What the above snippet tells us is that we have a cons cell from which the second element is another cons cell, or I should better say, the &lt;em&gt;cdr&lt;/em&gt; is another cons cell.&lt;/p&gt;
&lt;h3&gt;car, cdr &amp;amp; cons&lt;/h3&gt;
&lt;p&gt;This gives us a nice little bridge to talk about &lt;em&gt;car&lt;/em&gt; and &lt;em&gt;cdr&lt;/em&gt;, two more vital parts of the Scheme programming language.&lt;/p&gt;
&lt;p&gt;In our cons cells we used above we have a &lt;em&gt;car&lt;/em&gt;, the &lt;em&gt;first&lt;/em&gt; element of the pair and a cdr, the &lt;em&gt;rest&lt;/em&gt; of the pair.
Car and cdr are two primitive procedures, introduced by John McCarthy himself, that you have available in every Scheme (or every LISP remainder for that matter).&lt;/p&gt;
&lt;p&gt;Both procedures have only one parameter being a list and will return one value being either the first element of the list in case of &lt;em&gt;car&lt;/em&gt; or everything &lt;em&gt;but&lt;/em&gt; the first element in case of &lt;em&gt;cdr&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;There is nothing more to it.&lt;/p&gt;
&lt;p&gt;Before you can ask the car or cdr from a pair, you have the &lt;em&gt;have&lt;/em&gt; a pair first. So, if you have two primitive elements, say &lt;em&gt;strings&lt;/em&gt;, how can we make a pair out of them?&lt;/p&gt;
&lt;p&gt;Using &lt;em&gt;cons&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;Cons is another primitive procedure that &lt;em&gt;creates&lt;/em&gt; a pair.
This procedure takes &lt;em&gt;two&lt;/em&gt; arguments and returns the two items &lt;em&gt;consed&lt;/em&gt; onto each other.&lt;/p&gt;
&lt;p&gt;To demonstrate, try this in the REPL:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="s"&gt;"faa"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;It will result in:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"faa"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;But the elements don't have to be primitive elements, they can also be lists.
That means we can do this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons &lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"faa"&lt;/span&gt; &lt;span class="s"&gt;"fii"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And get this in return:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="s"&gt;"faa"&lt;/span&gt; &lt;span class="s"&gt;"fii"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We just consed the &lt;em&gt;atom&lt;/em&gt; "foo" onto the list '("faa" "fii").
Not that difficult I would presume!&lt;/p&gt;
&lt;p&gt;Well, I haven't told you everything yet.&lt;/p&gt;
&lt;p&gt;First, I just threw a new term at you: the &lt;em&gt;atom&lt;/em&gt;. An atom in CHICKEN is the most basic &lt;em&gt;s-expression&lt;/em&gt; that you can find and &lt;em&gt;almost&lt;/em&gt; always &lt;em&gt;evaluates to itself&lt;/em&gt;.
If you type the string "foo" inside the REPL, it will return "foo" to you. Meaning the string "foo" evaluates to itself.
Strings, numbers, booleans (true and false) all are atoms and all evaluate to themselves.&lt;/p&gt;
&lt;p&gt;There are, however, some atoms that &lt;em&gt;do not&lt;/em&gt; evaluate to themselves. The &lt;em&gt;symbol&lt;/em&gt; for instance.
The symbol, most of the time, is used as an identifier for a variable, so it evaluates not to its name, but to the values it is referring to.&lt;/p&gt;
&lt;p&gt;Second, it is important to know what a cons cell &lt;em&gt;really&lt;/em&gt; is, okay, we know it is a pair, but what is the deeper meaning of it?
A cons cell is actually a pair of two &lt;em&gt;pointers&lt;/em&gt;, two references to places inside your computers memory.
The car of the cons cell points to the s-expression you want to have as the first element and the cdr points to another s-expression.
In case you have a pair, this is what actually happens:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="nv"&gt;----&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"foo"&lt;/span&gt;
   &lt;span class="nv"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"bar"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;             &lt;span class="nv"&gt;-----&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
           &lt;span class="nv"&gt;|&lt;/span&gt;                &lt;span class="nv"&gt;|&lt;/span&gt;
           &lt;span class="nv"&gt;----&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"bar"&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
                    &lt;span class="nv"&gt;|&lt;/span&gt;
                    &lt;span class="nv"&gt;----&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"bar"&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The car of the cons cell ("foo" . "bar") points to the atom "foo" in memory.
The cdr points to another list in memory. You don't actually see it, but every (proper) list ends with the empty list '().
So the cdr of this cons cell is actually not "bar" but rather a small list:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"bar"&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;With this profound new knowledge, let us take another peek at the CHICKEN s-expression that Medea gave us.
This time I will indent it a little bit differently:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;params&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;playerid&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This should now look like a piece of cake (nom . nom)!&lt;/p&gt;
&lt;p&gt;We have seen how can get from a JSON string to a CHICKEN s-expression, but what about the other way around?
As seen above we can use the following procedure:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;write-json&lt;/span&gt; &lt;span class="nv"&gt;datum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Let us see if we can convert the s-expression we got above back to a JSON string.
This is rather simple:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;write-json&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;jsonrpc&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;mathod&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"Player.PlayPause"&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;params&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;playerid&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Actually, this is exactly the same s-expression that we got back from Medea!&lt;/p&gt;
&lt;p&gt;Well, almost, there is one small detail: we put the whole s-expression inside a &lt;em&gt;quoted&lt;/em&gt; list.&lt;/p&gt;
&lt;p&gt;This is a small example of the &lt;em&gt;data is code and code is data&lt;/em&gt; statement from earlier.
By putting this s-expression inside another list that has a quote before it, CHICKEN knows that this has to be treated as data.
If you drop the quote, CHICKEN will see it as code and try to evaluate it.&lt;/p&gt;
&lt;p&gt;It may not seem as much right now...but this is &lt;strong&gt;AWESOME&lt;/strong&gt;, ahum...sorry for that.&lt;/p&gt;
&lt;p&gt;Good, we now have a &lt;em&gt;basic&lt;/em&gt; understanding of how we can use Medea.
We also know what s-expression we have to build in order to be JSON-RPC valid.&lt;/p&gt;
&lt;p&gt;What's next?&lt;/p&gt;
&lt;p&gt;Now we have to actually &lt;em&gt;construct&lt;/em&gt; the code that will build this JSON-RPC valid s-expression.
Also, we have to give the user of our egg an easy to use interface for putting in its data.
We don't want them to be bothered with the whole JSON-RPC and Medea thing, that all happens behind curtains.
We want them to be able to call a simple procedure with a few arguments and be done with it.&lt;/p&gt;
&lt;h3&gt;Hatching an egg&lt;/h3&gt;
&lt;p&gt;So I think it is time to actually start to create our egg file! &lt;em&gt;Finally!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A basic egg in CHICKEN is nothing more then a directory containing four files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;The source code file(s):&lt;/em&gt;
  This will contain the actual code that makes up your egg&lt;/li&gt;
&lt;li&gt;&lt;em&gt;A setup file:&lt;/em&gt;
  Contains information on how to compile your egg&lt;/li&gt;
&lt;li&gt;&lt;em&gt;A meta file:&lt;/em&gt;
  Contains information about the license, author, documentation, title, etc. for your egg&lt;/li&gt;
&lt;li&gt;&lt;em&gt;A release info file:&lt;/em&gt;
  Contains the location of your egg on a code hosting site and the version(s) you release&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These last three files only matter for when you are ready to release your egg, stuff we will do in chapter 2 (that rhymes).&lt;/p&gt;
&lt;p&gt;For now we can concentrate on building the code for our JSON-RPC egg (the source code file).
Open up your favorite editor and create a file called &lt;em&gt;json-rpc-client.scm&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We know that we want to communicate with a server, this implies we need to &lt;em&gt;talk&lt;/em&gt; with the server over a &lt;em&gt;connection&lt;/em&gt;. On a OS level, this connection is made by connecting to a &lt;em&gt;port&lt;/em&gt;, the same as you are now connected to port 80 of the Shisaa server to read this very post. In CHICKEN ports can be represented by, well, &lt;em&gt;ports&lt;/em&gt;. They carry the same name, but are something different of course. The &lt;em&gt;ports&lt;/em&gt; in CHICKEN are &lt;em&gt;objects&lt;/em&gt; that you can write to or read from. It is even possible to make a &lt;em&gt;connection&lt;/em&gt; with &lt;em&gt;ports&lt;/em&gt; to a string. You can then wrtie to a string or read from it. In CHICKEN, reading a writing is done from two different ports, the &lt;em&gt;output&lt;/em&gt; and the &lt;em&gt;input&lt;/em&gt; port.&lt;/p&gt;
&lt;p&gt;Because the &lt;em&gt;ports&lt;/em&gt; system in CHICKEN is so flexible, we can use it to communicate over a variety of protocols. One of the more common ones is TCP, which is used to communicate with other machines using an &lt;em&gt;IPv4&lt;/em&gt; or IPv6&lt;em&gt; address and a &lt;/em&gt;physical* port number. Others include HTTP, WebSockets, ...&lt;/p&gt;
&lt;p&gt;Our XBMC server, for example, supports three different protocols to communicate over: TCP, HTTP and WebSockets. Since we are writing a &lt;em&gt;general&lt;/em&gt; implementation of &lt;em&gt;JSON-RPC&lt;/em&gt; we cannot make any assumptions as to which protocol the user wants to use. So for now we don't have to worry about which protocol to use, we only need to make sure one is an input port and the other is an output port.&lt;/p&gt;
&lt;p&gt;The other important thing to note is that the server we communicate with supports a certain version of the JSON-RPC specification.
When laying a connection with the server, we also want to declare which version of the spec we want to use.&lt;/p&gt;
&lt;p&gt;These three things are all we need to setup a connection and they are all we need to &lt;em&gt;define&lt;/em&gt; our procedure that we will call &lt;em&gt;json-rpc-server&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;There we have it, our first line of code and the first line of our procedure. We defined it, set the name to &lt;em&gt;json-rpc-server&lt;/em&gt; and gave it three arguments &lt;em&gt;input&lt;/em&gt;, &lt;em&gt;output&lt;/em&gt; and &lt;em&gt;version&lt;/em&gt;. The three dots indicate that this code is not finished yet and thus cannot be copy and pasted into the REPL.&lt;/p&gt;
&lt;p&gt;What would be even better is to explicitly set our version to "2.0", because that's the only version we will support in this egg:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;!key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now "version" is set to "2.0" by default and the user can omit it when calling this procedure.&lt;/p&gt;
&lt;p&gt;Next we have to write the &lt;em&gt;body&lt;/em&gt; (the part of the procedure that holds the actual code) of this procedure, because now it is empty, and thus not quite useful.&lt;/p&gt;
&lt;p&gt;The first thing we need in this procedure is to check if the given arguments are valid. And if not valid, give the user some useful feedback.
To check each argument, we can use so called &lt;em&gt;predicates&lt;/em&gt;. These are procedures that check their argument and simply return true or false.
Build in to CHICKEN are predicates to check for a valid input-port or output-port, so let us use them to check our first two arguments:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;and&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Neat!&lt;/p&gt;
&lt;p&gt;For the third parameter, however, we will have to do a little bit more work. Because "version" is something specific to our egg, we will have to make our own predicate.&lt;/p&gt;
&lt;p&gt;To do this, simply start to declare a new procedure which we will call &lt;em&gt;is-valid-version?&lt;/em&gt;.
It is common to put a question mark behind the name of a predicate to distinguish them from "other" procedures. In contrast with many other languages, in CHICKEN you can use almost &lt;em&gt;any&lt;/em&gt; character inside a variable name. So a question mark is perfectly fine! Just don't use characters like &lt;em&gt;(&lt;/em&gt;, &lt;em&gt;)&lt;/em&gt; or &lt;em&gt;'&lt;/em&gt; or you may confuse CHICKEN into thinking it is the start or end of a list. You can, of course, &lt;em&gt;escape&lt;/em&gt; characters inside variable names, but you do not have to worry about that now.&lt;/p&gt;
&lt;p&gt;From reading the JSON-RPC spec we know that &lt;em&gt;version&lt;/em&gt; has to be a string containing exactly "2.0"...so that is what we have to check for:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-version?&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;string=? &lt;/span&gt;&lt;span class="nv"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;That's it, we define &lt;em&gt;is-valid-version?&lt;/em&gt; with only one argument &lt;em&gt;version&lt;/em&gt;.
Next we check with &lt;em&gt;another predicate&lt;/em&gt; called &lt;em&gt;string=?&lt;/em&gt; if the given argument "version" is equal to "2.0".&lt;/p&gt;
&lt;p&gt;Instead of using &lt;em&gt;string=?&lt;/em&gt; we could also have used &lt;em&gt;equal?&lt;/em&gt;, but &lt;em&gt;equal?&lt;/em&gt; is a generic predicate then can not only check strings, but many other types as well.
But because we &lt;em&gt;know&lt;/em&gt; that &lt;em&gt;version&lt;/em&gt; is a string  we can be more specific and only preform a &lt;em&gt;string comparison&lt;/em&gt; here.
By doing that, the compiler (who will eventual compile our egg) also has to do less checks and can make some smart shortcuts.&lt;/p&gt;
&lt;p&gt;Okay, so now we have three predicates we can use for our three arguments. But &lt;em&gt;how&lt;/em&gt; do we use them?&lt;/p&gt;
&lt;p&gt;Well, put them inside your procedure!&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;!key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;is-valid-version?&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The above snippet introduces a new keyword &lt;em&gt;cond&lt;/em&gt;. You may already guessed it, it's short for &lt;em&gt;condition&lt;/em&gt;.
And as you can see, we have three conditions. All three have to return &lt;em&gt;true&lt;/em&gt; or &lt;em&gt;#t&lt;/em&gt; for the &lt;em&gt;cond&lt;/em&gt; to continue to the next piece of code.&lt;/p&gt;
&lt;p&gt;This is already quite okay, but if one of the predicates is &lt;em&gt;false&lt;/em&gt; or &lt;em&gt;#f&lt;/em&gt;, what happens?
Well, the procedure is stopped, without any feedback to the user.&lt;/p&gt;
&lt;p&gt;That is not very nice! We have to be as useable as possible, so we have to tell the user &lt;em&gt;why&lt;/em&gt; the code cannot continue.
To do this, we must provide decent &lt;em&gt;exception handling&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;What is exception handling?&lt;/h4&gt;
&lt;p&gt;In the world of software, &lt;em&gt;exception handling&lt;/em&gt; is a way to respond to a situation that was not expected.
By good usage of these you can prevent your program from a "crash and burn" situation and you can give helpful feedback to your user.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Always provide your code with decent exception handing!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In CHICKEN &lt;a href="http://wiki.call-cc.org/man/4/Exceptions" title="CHICKEN Exceptions WIKI page"&gt;you have various ways&lt;/a&gt; of doing so, one of them being &lt;em&gt;signal&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;With &lt;em&gt;signal&lt;/em&gt; you can raise a &lt;em&gt;continuable&lt;/em&gt; exception. This means that the program does not stop, but simply alerts the user and waits for further input.
We can use &lt;em&gt;signal&lt;/em&gt; inside a procedure that we make, a custom exception handler that we will construct specifically for setting up a correct JSON-RPC connection.&lt;/p&gt;
&lt;p&gt;Let me give you the full code of such an exception handler:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="nv"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;expected&lt;/span&gt; &lt;span class="nv"&gt;given&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;signal&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-property-condition&lt;/span&gt;
      &lt;span class="ss"&gt;'exn&lt;/span&gt; &lt;span class="ss"&gt;'message&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sprintf&lt;/span&gt; &lt;span class="s"&gt;"Cannot setup connection, the ~S is invalid. Excepted ~A type but got ~A."&lt;/span&gt;
          &lt;span class="nv"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;expected&lt;/span&gt; &lt;span class="nv"&gt;given&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Let us chew this one, piece by piece.&lt;/p&gt;
&lt;p&gt;As you are already familiar with, we define a new procedure that I decided to call &lt;em&gt;server-setup-arguments-error&lt;/em&gt;, that accepts three arguments.
This procedure calls &lt;em&gt;signal&lt;/em&gt; (to make it a continuable exception) which accepts one parameter, in our case &lt;em&gt;make-property-condition&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Make-property-condition&lt;/em&gt; is a CHICKEN specific procedure that belongs to CHICKEN's &lt;a href="http://wiki.call-cc.org/man/4/Exceptions" title="CHIKEN WIKI entry for exception handling"&gt;exception handling system&lt;/a&gt;.
It accepts an exception kind &lt;em&gt;'exn&lt;/em&gt; and key/value pairs, in our case one pair &lt;em&gt;'message&lt;/em&gt; and &lt;em&gt;sprintf&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;'message&lt;/em&gt; we construct using the procedure &lt;em&gt;sprintf&lt;/em&gt;. The latter may look familiar from other programming languages.
With &lt;em&gt;sprintf&lt;/em&gt; you can construct a string with placeholders, and then fill in the placeholders later.
In our case, we fill in these placeholders with the arguments we give to our custom exception handler.&lt;/p&gt;
&lt;p&gt;To be able to ue &lt;em&gt;sprintf&lt;/em&gt; we have to load in the &lt;em&gt;extras&lt;/em&gt; library. To load in libraries or modules, we can use the &lt;em&gt;use&lt;/em&gt; procedure as we have seen when loading in Medea on the REPL.
Put this in the top of your file so that the procedures of &lt;em&gt;extras&lt;/em&gt; always get loaded in:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;use&lt;/span&gt; &lt;span class="nv"&gt;extras&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The placeholders themselves are documented in on the &lt;a href="http://wiki.call-cc.org/man/4/Unit%20extras#sprintf" title="Sprintf WIKI entry"&gt;CHICKEN wiki&lt;/a&gt;.
We use &lt;em&gt;~S&lt;/em&gt; and &lt;em&gt;~A&lt;/em&gt; which are stand for &lt;em&gt;writing&lt;/em&gt; or &lt;em&gt;displaying&lt;/em&gt; the next argument.&lt;/p&gt;
&lt;p&gt;What is the difference between &lt;em&gt;writing&lt;/em&gt; and &lt;em&gt;displaying&lt;/em&gt;?&lt;/p&gt;
&lt;p&gt;A very good question! And also an essential question. &lt;em&gt;Writing&lt;/em&gt; and &lt;em&gt;displaying&lt;/em&gt; are specified in the &lt;em&gt;RnRS&lt;/em&gt; Scheme standards and differ in the way they handle outputting the argument they represent. If you &lt;em&gt;write&lt;/em&gt; an argument you will put the quoted and escaped representation of, say, a string. With &lt;em&gt;display&lt;/em&gt; you will put the &lt;em&gt;unquoted and unescaped&lt;/em&gt; representation:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;write &lt;/span&gt;&lt;span class="s"&gt;"foo (bar)"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Will give you the same, quoted and escaped output:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"foo (bar)"&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Where as&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;display &lt;/span&gt;&lt;span class="s"&gt;"foo (bar)"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Will give you a an unquoted and unescaped output:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;In our case we wish to display the given and the excepted arguments as there unquoted and unescaped representation.&lt;/p&gt;
&lt;p&gt;So now that we have a basic but decent error handling concept, let us see how we can use it if our above predicates turn out to be false.
Let us take a look at the first line of the predicates:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;If we simply put our exception handler there, it would look like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"input port"&lt;/span&gt; &lt;span class="s"&gt;"input-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;But now something is not quite correct. If you look closely, the above snipped says: If the give input is indeed a valid input-port then trigger the exception handler.
The is not what we want, we want it to trigger when it is &lt;em&gt;not&lt;/em&gt; a valid input-port. How? Simple, we use &lt;em&gt;not&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"input port"&lt;/span&gt; &lt;span class="s"&gt;"input-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now we have "inverted" the condition. If (input-port?) is &lt;em&gt;#f&lt;/em&gt;, then trigger the exception handler. If it is &lt;em&gt;#t&lt;/em&gt;, just continue to the next line.&lt;/p&gt;
&lt;p&gt;If we implement this into all of our predicates, our code would look like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;!key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"input port"&lt;/span&gt; &lt;span class="s"&gt;"input-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"output port"&lt;/span&gt; &lt;span class="s"&gt;"ouput-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-version?&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"version"&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We have three predicate checks (one for every argument), with three exception handlers of the same kind that we call with slightly different arguments depending on the situation.&lt;/p&gt;
&lt;p&gt;Among the three arguments that we give to our custom exception handler is hidden another procedure (get-type) that gets one argument.&lt;/p&gt;
&lt;p&gt;Why is that?&lt;/p&gt;
&lt;p&gt;Well, as we said before, we want to be as helpful to our users as we can, that is one of the main reasons that we want to use decent exception handling.
But I wanted to go a small step further by making a message that gives a little bit more information about the arguments the user entered.&lt;/p&gt;
&lt;p&gt;In this case, I want to tell the user which data type I expected and which data type they gave the procedure.
For this I created so called &lt;em&gt;helper function&lt;/em&gt;, &lt;em&gt;helper procedure&lt;/em&gt; or &lt;em&gt;helper&lt;/em&gt; that checks which data type the given argument is and returns some information that we can print it in our message.&lt;/p&gt;
&lt;p&gt;As you can see, this &lt;em&gt;helper&lt;/em&gt; is called "get-type" and accepts one argument being the argument that the user gave us.
The helper consists of mere predicates for the most common data types we have. It looks like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"an input port"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"an output port"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;number? &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"a mumber"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;pair? &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"a pair"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;string? &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"a string"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;list? &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"a list"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;vector? &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"a vector"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;boolean? &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"a boolean"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;else&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"something unknown"&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;By now, this sort of thing should not look scary to you at all.&lt;/p&gt;
&lt;p&gt;What happens here is we have a &lt;em&gt;cond&lt;/em&gt; expression which checks a series of conditions.
If one of the given conditions return true it returns with a string, if none of them are true, the final expression, &lt;em&gt;else&lt;/em&gt;, will be returned being &lt;em&gt;something unknown&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To illustrate in further detail how this whole chain of procedures and predicates work, let us assume we call our procedure with an erroneous argument:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;xbmc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;valid-input&lt;/span&gt; &lt;span class="s"&gt;"foobar"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;We call our &lt;em&gt;json-rpc-server&lt;/em&gt; procedure with two arguments (version is implicit). Our input-port argument is perfect, our output-port is not so.
What happens in our chain? Let us see step by step:&lt;/p&gt;
&lt;p&gt;First the procedure enters the predicate checks. The first one we encounter is our input check:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"input port"&lt;/span&gt; &lt;span class="s"&gt;"input-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Since our input-port is correct, this predicate returns true and the &lt;em&gt;cond&lt;/em&gt; statement goes to the next line:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"output port"&lt;/span&gt; &lt;span class="s"&gt;"ouput-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now the predicate returns &lt;em&gt;#f&lt;/em&gt;, the string "foobar" is not a valid output-port, and thus the &lt;em&gt;not&lt;/em&gt; statement is executed.
The &lt;em&gt;not&lt;/em&gt; statement has our custom exception handler as its second argument, so that one is called.&lt;/p&gt;
&lt;p&gt;While calling this &lt;em&gt;server-setup-arguments-error&lt;/em&gt; handler, its arguments are parsed.
The first two are simple strings, but the third is our &lt;em&gt;helper&lt;/em&gt; "get-type" with the given output-port as an argument, being the string "foobar" here.&lt;/p&gt;
&lt;p&gt;Before we can enter the &lt;em&gt;body&lt;/em&gt; of our exception handler procedure, we first have to find out what the return value of "get-type" is.
When we call "get-type" here, it will look like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="s"&gt;"foobar"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Since "foobar" is a string, the following predicate will return &lt;em&gt;#t&lt;/em&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;string? &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"a string"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The argument "x" being our string "foobar". this will make the procedure end and return "a string" to its &lt;em&gt;caller&lt;/em&gt;.
Our &lt;em&gt;caller&lt;/em&gt; is the exception handler that is waiting for this return value so it can know its third argument and can continue to its &lt;em&gt;body&lt;/em&gt;.
We now know this third argument and our call now looks like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"output port"&lt;/span&gt; &lt;span class="s"&gt;"ouput-port"&lt;/span&gt; &lt;span class="s"&gt;"a string"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;So now the exception handler can finally execute and throw an exception with a custom message, constructed with the arguments we gave it.
The messages returned will look like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s2"&gt;"Cannot setup connection, the output-port is invalid. Excepted output-port type but got a string."&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Okay, we now have a decent start, we check our user input and respond to it in a correct manner.
It's now time to build the rest of our procedure.&lt;/p&gt;
&lt;p&gt;If all the predicates pass, what should happen next?&lt;/p&gt;
&lt;p&gt;Well, we want this procedure to return &lt;em&gt;another&lt;/em&gt; procedure that the user can use to actually send the commands.&lt;/p&gt;
&lt;p&gt;We have seen how we can call our procedure:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;xbmc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;valid-input-port&lt;/span&gt; &lt;span class="nv"&gt;valid-output-port&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Now we have defined &lt;em&gt;xbmc&lt;/em&gt;. When we now call &lt;em&gt;xbmc&lt;/em&gt;, this will actually be a new procedure waiting for its method and optional params.
Like we said before, when defining &lt;em&gt;json-rpc-server&lt;/em&gt;, in this case &lt;em&gt;xbmc&lt;/em&gt;, we define the connection.
Later, we can use this connection to send over the commands by calling this new procedure.&lt;/p&gt;
&lt;p&gt;You can see it as a keyboard in a box. By correctly calling our &lt;em&gt;json-rpc-procedure&lt;/em&gt; we have unlocked the box.
In that box we find a keyboard that is now linked to our server and that we can use to type in our commands (by calling it with correct arguments).&lt;/p&gt;
&lt;p&gt;Not making sense yet? Don't worry!&lt;/p&gt;
&lt;p&gt;Let us first continue writing our code.&lt;/p&gt;
&lt;p&gt;How do we continue after our predicates return &lt;em&gt;#t&lt;/em&gt;? When using a &lt;em&gt;cond&lt;/em&gt; you can do this by using the &lt;em&gt;else&lt;/em&gt; statement.
In our code this would look like so:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;!key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"input port"&lt;/span&gt; &lt;span class="s"&gt;"input-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"output port"&lt;/span&gt; &lt;span class="s"&gt;"ouput-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-version?&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"version"&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;After this &lt;em&gt;else&lt;/em&gt; we can now put the code that will be executed when all the arguments where correct.
Again, we want &lt;em&gt;json-rpc-server&lt;/em&gt; to return another procedure that the user can call to actually send something over the wire.
How to we make a procedure return another procedure?&lt;/p&gt;
&lt;p&gt;With &lt;em&gt;lambda&lt;/em&gt;!&lt;/p&gt;
&lt;h4&gt;What is this Lambda?&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;Lambda&lt;/em&gt; or &lt;em&gt;Lambda Calculus&lt;/em&gt; is a system in computer programming that allows you to write functions or procedures without naming them.. that's all you need to know for now.&lt;/p&gt;
&lt;p&gt;Actually, we have been using lambda's the whole time, I just did not tell you. Every time you declare a new procedure in CHICKEN, you are using a lambda.
When &lt;em&gt;defining&lt;/em&gt; a new procedure, we wrote this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt; &lt;span class="nv"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;But this is actually a shorthand for this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;But because this is quite a cramp to type every time, we can use the shorthand notation.&lt;/p&gt;
&lt;p&gt;Back to our egg, we want our procedure to return a procedure.
Here we cannot use a shorthand, we have to tell it to return a &lt;em&gt;nameless&lt;/em&gt; procedure or lambda.
Implementing this, it would look something like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json-rpc-server&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;!key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input-port? &lt;/span&gt;&lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"input port"&lt;/span&gt; &lt;span class="s"&gt;"input-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;output-port? &lt;/span&gt;&lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"output port"&lt;/span&gt; &lt;span class="s"&gt;"ouput-port"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-type&lt;/span&gt; &lt;span class="nv"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-valid-version?&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;server-setup-arguments-error&lt;/span&gt; &lt;span class="s"&gt;"version"&lt;/span&gt; &lt;span class="s"&gt;"2.0"&lt;/span&gt; &lt;span class="nv"&gt;version&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;else&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;method&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;params&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Here is our entire procedure so far, returning a nameless procedure (lambda) if all the given arguments where correct.
And now our story starts over again, well, partially anyway. Since we now enter a new procedure with its own, new arguments, we have to do the same thing as before.&lt;/p&gt;
&lt;p&gt;What is that?&lt;/p&gt;
&lt;p&gt;Why, check the user input and throw exceptions if needed of course!&lt;/p&gt;
&lt;p&gt;But that will be food for chapter 2, for this is already enough to chew on in one chapter.&lt;/p&gt;
&lt;p&gt;Congrats if you have made it this far and if you understood my blabberings.
Before I leave you hanging for the next chapter, let us take a quick review of what we have seen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We have seen that Scheme is not so strange as many people think it is&lt;/li&gt;
&lt;li&gt;We have seen how we could get CHICKEN installed and running on our system&lt;/li&gt;
&lt;li&gt;We have briefly touched on compiling&lt;/li&gt;
&lt;li&gt;We have seen an outline of what we want to build in these three chapters&lt;/li&gt;
&lt;li&gt;We have seen an egg called Medea for converting CHICKEN data types into JSON data types and vice versa&lt;/li&gt;
&lt;li&gt;We have seen how to use this egg to convert both ways&lt;/li&gt;
&lt;li&gt;By doing so we have seen what s-expressions, atoms, cons cells, car, cdr and cons are&lt;/li&gt;
&lt;li&gt;We have seen the skeleton of an egg&lt;/li&gt;
&lt;li&gt;We have laid the basis of our egg and looked at exception handling, predicates and lambdas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That's it for know folks. Relax and clear your mind!
If you did not understand something I suggest you go and read it again until the mental light bulb flips on.&lt;/p&gt;
&lt;p&gt;The next chapter will be online soon!&lt;/p&gt;
&lt;p&gt;And as always...thanks for reading!&lt;/p&gt;&lt;/div&gt;</description><category>chicken</category><category>json rpc</category><category>scheme</category><guid>http://shisaa.jp/postset/chicken-scheme-1.html</guid><pubDate>Fri, 23 Aug 2013 19:30:00 GMT</pubDate></item></channel></rss>